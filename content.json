{"meta":{"title":"Leo","subtitle":"勇敢做自己","description":null,"author":"Leo","url":"http://leo.dropsec.xyz"},"pages":[{"title":"tags","date":"2017-07-07T10:13:07.000Z","updated":"2017-08-19T09:30:33.494Z","comments":true,"path":"tags/index.html","permalink":"http://leo.dropsec.xyz/tags/index.html","excerpt":"","text":"所有标签：| 最大的幸福,莫过于我看你的时候,你也在看着我 杂儿 废纸篓 C++ JAVA Python Assembly ACM CTF 二进制逆向 工具or软件| 嘿,此时,你正看着我,而Leo也静静看着你呢..."}],"posts":[{"title":"CrackMe 003","slug":"CrackMe-003","date":"2017-08-19T07:13:59.000Z","updated":"2017-08-19T09:11:48.526Z","comments":true,"path":"2017/08/19/CrackMe-003/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/19/CrackMe-003/","excerpt":"算法部分又出新花样，在第二题之上加入了浮点运算，加上战线拉的长，需要耐心分析方可得出Key… en,最后再加个解除延时… [多看看浮点汇编运算]","text":"算法部分又出新花样，在第二题之上加入了浮点运算，加上战线拉的长，需要耐心分析方可得出Key… en,最后再加个解除延时… [多看看浮点汇编运算] 观察运行程序ei？这里好像有一个延时吖，嗯，是的。输入test 1234 确定目标一.找到注册机二.解除延时 一.找到注册机加载进入OD，查找错误提示字符串，找到对应汇编代码查看上面相关代码，很容易找到关键跳然后就开始分析算法了…找到这个函数开始，下断，然后F9，一步步找到有用代码函数开始到关键跳代码比较冗长，只跳关键部分进行重点分析第一部分： 004081E3 FF15 18B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; **get input name 004081E9 8B95 50FFFFFF mov edx,dword ptr ss:[ebp-0xB0] 004081EF 8B45 E4 mov eax,dword ptr ss:[ebp-0x1C] ; **eax=name 004081F2 50 push eax 004081F3 8B1A mov ebx,dword ptr ds:[edx] 004081F5 FF15 F8B04000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBs&gt;; **get length of name 004081FB 8BF8 mov edi,eax ; **edi=name length 004081FD 8B4D E8 mov ecx,dword ptr ss:[ebp-0x18] ; **ecx=name 00408200 69FF 385B0100 imul edi,edi,0x15B38 ; **edi*=0x15B38 00408206 51 push ecx 00408207 0F80 B7050000 jo AfKayAs_.004087C4 ; *jump overflow 0040820D FF15 0CB14000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;] ; **get name[0] 00408213 0FBFD0 movsx edx,ax ; **edx=name[0] 计算第一个字符的ASCII码值 00408216 03FA add edi,edx ; **edi+=name[0] 00408218 0F80 A6050000 jo AfKayAs_.004087C4 ; *jump overflow 0040821E 57 push edi 0040821F FF15 F4B04000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;; **hex-&gt;dec EDI结果转成10进制数 00408225 8BD0 mov edx,eax 00408227 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20] 这段汇编代码与CrackMe2中的代码的流程是一样的，算法就是（name的长度）*0x15B38+第一个字符的ASCII码值，转成10进制字符串，这个简单。之后，我们再向后看，肯定有不同的位置，发现出现了浮点数运算:我们继续对代码进行分析，到跳转条件前一共主要出现了四段浮点数的汇编部分:第二部分： 004082E7 8B19 mov ebx,dword ptr ds:[ecx] 004082E9 FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; name转换成浮点数,结果在浮点寄存器里 004082EF D905 08104000 fld dword ptr ds:[0x401008] ; **将0401008中的硬编码实型存入st0 004082F5 833D 00904000 0&gt;cmp dword ptr ds:[0x409000],0x0 004082FC 75 08 jnz short AfKayAs_.00408306 004082FE D835 0C104000 fdiv dword ptr ds:[0x40100C] 00408304 EB 0B jmp short AfKayAs_.00408311 00408306 FF35 0C104000 push dword ptr ds:[0x40100C] 0040830C E8 578DFFFF call &lt;jmp.&amp;MSVBVM50._adj_fdiv_m32&gt; 00408311 83EC 08 sub esp,0x8 00408314 DFE0 fstsw ax ; **将st0中的值复制到ax中 00408316 A8 0D test al,0xD 00408318 0F85 A1040000 jnz AfKayAs_.004087BF 0040831E DEC1 faddp st(1),st ; **将st(num)和st相加，用和来替换st(num),将st出栈 00408320 DFE0 fstsw ax 00408322 A8 0D test al,0xD 00408324 0F85 95040000 jnz AfKayAs_.004087BF 0040832A DD1C24 fstp qword ptr ss:[esp] 0040832D FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt; 00408333 8BD0 mov edx,eax 其实这部分并没有做什么实质上的工作，不过通过浮点数运算对内存中的数据进行改动(我们后面会发现这些内存地址都用了，但我们并不需要考虑这些，直接当做硬编码处理就可以了)。第三部分： 004083F3 8B19 mov ebx,dword ptr ds:[ecx] 004083F5 FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt; 004083FB DC0D 10104000 fmul qword ptr ds:[0x401010] ; **name=name*3 00408401 83EC 08 sub esp,0x8 00408404 DC25 18104000 fsub qword ptr ds:[0x401018] ; **name=name-2 0040840A DFE0 fstsw ax 0040840C A8 0D test al,0xD 0040840E 0F85 AB030000 jnz AfKayAs_.004087BF 00408414 DD1C24 fstp qword ptr ss:[esp] ; **结果存入堆栈 00408417 FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt; 0040841D 8BD0 mov edx,eax 可以看到，这部分对输入的name进行了简单的浮点运算:name=name*3-2第四部分： 004084DD 8B19 mov ebx,dword ptr ds:[ecx] 004084DF FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt; 004084E5 DC25 20104000 fsub qword ptr ds:[0x401020] ; **str-(-15) 004084EB 83EC 08 sub esp,0x8 004084EE DFE0 fstsw ax 004084F0 A8 0D test al,0xD 004084F2 0F85 C7020000 jnz AfKayAs_.004087BF 004084F8 DD1C24 fstp qword ptr ss:[esp] 004084FB FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt; 00408501 8BD0 mov edx,eax 又对name进行了简单的操作，name=name-(-0x15);第五部分： 004085C8 FF15 18B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt; 004085CE 8B45 E8 mov eax,dword ptr ss:[ebp-0x18] ; **eax=input serial 004085D1 50 push eax ; **serial转换成浮点数 004085D2 FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; 004085D8 8B4D E4 mov ecx,dword ptr ss:[ebp-0x1C] 004085DB DD9D 1CFFFFFF fstp qword ptr ss:[ebp-0xE4] 004085E1 51 push ecx ; **我们输入的serila转化成浮点数 004085E2 FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt; 004085E8 833D 00904000 0&gt;cmp dword ptr ds:[0x409000],0x0 004085EF 75 08 jnz short AfKayAs_.004085F9 004085F1 DCBD 1CFFFFFF fdivr qword ptr ss:[ebp-0xE4] ; **name/serial值存入st0 004085F7 EB 11 jmp short AfKayAs_.0040860A 004085F9 FFB5 20FFFFFF push dword ptr ss:[ebp-0xE0] 004085FF FFB5 1CFFFFFF push dword ptr ss:[ebp-0xE4] 00408605 E8 888AFFFF call &lt;jmp.&amp;MSVBVM50._adj_fdivr_m64&gt; 0040860A DFE0 fstsw ax 0040860C A8 0D test al,0xD 0040860E 0F85 AB010000 jnz AfKayAs_.004087BF 00408614 FF15 34B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFpR8&gt;&gt; 0040861A DC1D 28104000 fcomp qword ptr ds:[0x401028] ; **判断name/serial==1？ 00408620 DFE0 fstsw ax 00408622 F6C4 40 test ah,0x40 00408625 74 07 je short AfKayAs_.0040862E 这一部分实现的就是上面步骤生成的serial与我们输入的serial进行比较，只不过利用了有一点迷糊性质的浮点数除法，判断结果是否等于1而已。我们在总结一下算法，Name/Serial关系为： Serial = (strlen(Name)0x15B38+Name[0]+2.0)3.0-2.0+15写出注册机:（python） # coding=utf8 s = raw_input(&quot;name:&quot;) print &quot;password:&quot;+str((len(s)*0x15B38+ord(s[:1])+2)*3-2+15) 最后总结一下，其实算法很简单，不过用浮点数汇编来迷惑罢了。 二.解除延时打开程序，首先会出现如下界面程序会停在该界面若干秒，然后才进入主界面，我们要去掉这个延时界面。使用OllyDbg工具打开程序，进入调试运行，程序首先断在系统领空右键-&gt;查找-&gt;所以模块中的名称，在弹出的All names窗口中找到SetTimer双击SetTimer代码所在位置，然后设置断点调试运行，程序断在刚才设置的断点处，此时查看堆栈：可知延时界面的滞留时间为7000ms，相应的十六进制值为0x00001B58去掉这个延时界面只需将该时间修改得足够小但是该时间位于系统领空，无法直接用OllyDbg进行修改保存，我们借助WinHex工具使用WinHex工具打开程序，在菜单中选择Search -&gt; Find Hex Values，查找十六进制值581B0000将该值修改为01000000，即延时时间为0x00000001ms，保存即可。然后运行程序，发现不再延迟喽… ………………………………………………………分割线…………………………………………….其实自己也没必要太过灰心，毕竟自己也是刚开始学逆向没多久，根据汇编代码来推出算法对自己来说虽然还有难度，其实多遇到些题目，多总结经验慢慢的就很容易了。（其实现在做的题还是蛮难的，高手也得吮吮手指头呢…) hhh","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"CrackMe 002","slug":"CrackMe-002","date":"2017-08-18T13:45:03.000Z","updated":"2017-08-19T07:14:05.105Z","comments":true,"path":"2017/08/18/CrackMe-002/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/18/CrackMe-002/","excerpt":"直接转入正题…","text":"直接转入正题… 观察程序随便输入数据可知还是老思路 查壳，并且获取语言信息无壳，VB写的 破解加载进OD，字符串搜索Try Again,找到对应汇编代码，上下观看相关代码，发现战线拉得有点长，不过没关系，耐心一点就没问题。向上翻会找到关键跳转然后分析跳转上面的代码，找到函数开头（有点远），下断点，开始分析 00402310 &gt; \\55 push ebp 00402311 . 8BEC mov ebp,esp 00402313 . 83EC 0C sub esp,0xC 00402316 . 68 26104000 push &lt;jmp.&amp;MSVBVM50.__vbaExceptHandler&gt; ; SE 处理程序安装 0040231B . 64:A1 0000000&gt;mov eax,dword ptr fs:[0] 00402321 . 50 push eax 00402322 . 64:8925 00000&gt;mov dword ptr fs:[0],esp 00402329 . 81EC B0000000 sub esp,0xB0 0040232F . 53 push ebx 00402330 . 56 push esi 00402331 . 8B75 08 mov esi,dword ptr ss:[ebp+0x8] ; Afkayas_.&lt;ModuleEntryPoint&gt; 00402334 . 57 push edi 00402335 . 8BC6 mov eax,esi 00402337 . 83E6 FE and esi,-0x2 0040233A . 8965 F4 mov dword ptr ss:[ebp-0xC],esp 0040233D . 83E0 01 and eax,0x1 00402340 . 8B1E mov ebx,dword ptr ds:[esi] 00402342 . C745 F8 08104&gt;mov dword ptr ss:[ebp-0x8],Afkayas_.0040&gt; 00402349 . 56 push esi 0040234A . 8945 FC mov dword ptr ss:[ebp-0x4],eax 0040234D . 8975 08 mov dword ptr ss:[ebp+0x8],esi 00402350 . FF53 04 call dword ptr ds:[ebx+0x4] 00402353 . 8B83 10030000 mov eax,dword ptr ds:[ebx+0x310] 00402359 . 33FF xor edi,edi 0040235B . 56 push esi 0040235C . 897D E8 mov dword ptr ss:[ebp-0x18],edi 0040235F . 897D E4 mov dword ptr ss:[ebp-0x1C],edi 00402362 . 897D E0 mov dword ptr ss:[ebp-0x20],edi 00402365 . 897D DC mov dword ptr ss:[ebp-0x24],edi 00402368 . 897D D8 mov dword ptr ss:[ebp-0x28],edi 0040236B . 897D D4 mov dword ptr ss:[ebp-0x2C],edi 0040236E . 897D C4 mov dword ptr ss:[ebp-0x3C],edi 00402371 . 897D B4 mov dword ptr ss:[ebp-0x4C],edi 00402374 . 897D A4 mov dword ptr ss:[ebp-0x5C],edi 00402377 . 897D 94 mov dword ptr ss:[ebp-0x6C],edi 0040237A . 8985 40FFFFFF mov dword ptr ss:[ebp-0xC0],eax 00402380 . FFD0 call eax 00402382 . 8D4D D4 lea ecx,dword ptr ss:[ebp-0x2C] 00402385 . 50 push eax 00402386 . 51 push ecx 00402387 . FF15 0C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaObjSe&gt;; msvbvm50.__vbaObjSet 0040238D . 8B9B 00030000 mov ebx,dword ptr ds:[ebx+0x300] 00402393 . 56 push esi 00402394 . 8985 50FFFFFF mov dword ptr ss:[ebp-0xB0],eax 0040239A . 899D 3CFFFFFF mov dword ptr ss:[ebp-0xC4],ebx 004023A0 . FFD3 call ebx 004023A2 . 8D55 DC lea edx,dword ptr ss:[ebp-0x24] 004023A5 . 50 push eax 004023A6 . 52 push edx ; ntdll.KiFastSystemCallRet 004023A7 . FF15 0C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaObjSe&gt;; msvbvm50.__vbaObjSet 004023AD . 8BD8 mov ebx,eax 004023AF . 8D4D E8 lea ecx,dword ptr ss:[ebp-0x18] 004023B2 . 51 push ecx 004023B3 . 53 push ebx 004023B4 . 8B03 mov eax,dword ptr ds:[ebx] 004023B6 . FF90 A0000000 call dword ptr ds:[eax+0xA0] 004023BC . 3BC7 cmp eax,edi 004023BE . 7D 12 jge short Afkayas_.004023D2 004023C0 . 68 A0000000 push 0xA0 004023C5 . 68 5C1B4000 push Afkayas_.00401B5C 004023CA . 53 push ebx 004023CB . 50 push eax 004023CC . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj 004023D2 &gt; 56 push esi 004023D3 . FF95 3CFFFFFF call dword ptr ss:[ebp-0xC4] 004023D9 . 8D55 D8 lea edx,dword ptr ss:[ebp-0x28] 004023DC . 50 push eax 004023DD . 52 push edx ; ntdll.KiFastSystemCallRet 004023DE . FF15 0C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaObjSe&gt;; msvbvm50.__vbaObjSet 004023E4 . 8BD8 mov ebx,eax 004023E6 . 8D4D E4 lea ecx,dword ptr ss:[ebp-0x1C] 004023E9 . 51 push ecx 004023EA . 53 push ebx 004023EB . 8B03 mov eax,dword ptr ds:[ebx] 004023ED . FF90 A0000000 call dword ptr ds:[eax+0xA0] ; **get the Name we input** 004023F3 . 3BC7 cmp eax,edi 004023F5 . 7D 12 jge short Afkayas_.00402409 004023F7 . 68 A0000000 push 0xA0 004023FC . 68 5C1B4000 push Afkayas_.00401B5C 00402401 . 53 push ebx 00402402 . 50 push eax 00402403 . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj 00402409 &gt; 8B95 50FFFFFF mov edx,dword ptr ss:[ebp-0xB0] 0040240F . 8B45 E4 mov eax,dword ptr ss:[ebp-0x1C] ; **save Name to EAX** 00402412 . 50 push eax 00402413 . 8B1A mov ebx,dword ptr ds:[edx] 00402415 . FF15 E4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBs&gt; **get length of Name** 0040241B . 8BF8 mov edi,eax ; **EDI = length of Name** 0040241D . 8B4D E8 mov ecx,dword ptr ss:[ebp-0x18] ; **save Name to ECX** 00402420 . 69FF FB7C0100 imul edi,edi,0x17CFB ; **EDI *= 0x17CFB** 00402426 . 51 push ecx 00402427 . 0F80 91020000 jo Afkayas_.004026BE 判断是否溢出的，溢出就直接ERROR 0040242D . FF15 F8404000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;] **get the 1&apos;st char of Name** 00402433 . 0FBFD0 movsx edx,ax ; edx=a[0] 00402436 . 03FA add edi,edx ** EDI += Name[0] remember as _res** 00402438 . 0F80 80020000 jo Afkayas_.004026BE 0040243E . 57 push edi 0040243F . FF15 E0404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;; _str = itos(_res) 00402445 . 8BD0 mov edx,eax 00402447 . 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20] 0040244A . FF15 70414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrMo&gt;; msvbvm50.__vbaStrMove 00402450 . 8BBD 50FFFFFF mov edi,dword ptr ss:[ebp-0xB0] 00402456 . 50 push eax 00402457 . 57 push edi 00402458 . FF93 A4000000 call dword ptr ds:[ebx+0xA4] 0040245E . 85C0 test eax,eax 00402460 . 7D 12 jge short Afkayas_.00402474 00402462 . 68 A4000000 push 0xA4 00402467 . 68 5C1B4000 push Afkayas_.00401B5C 0040246C . 57 push edi 0040246D . 50 push eax 0040246E . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj 00402474 &gt; 8D45 E0 lea eax,dword ptr ss:[ebp-0x20] 00402477 . 8D4D E4 lea ecx,dword ptr ss:[ebp-0x1C] 0040247A . 50 push eax 0040247B . 8D55 E8 lea edx,dword ptr ss:[ebp-0x18] 0040247E . 51 push ecx 0040247F . 52 push edx ; ntdll.KiFastSystemCallRet 00402480 . 6A 03 push 0x3 00402482 . FF15 5C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;; msvbvm50.__vbaFreeStrList 00402488 . 83C4 10 add esp,0x10 0040248B . 8D45 D4 lea eax,dword ptr ss:[ebp-0x2C] 0040248E . 8D4D D8 lea ecx,dword ptr ss:[ebp-0x28] 00402491 . 8D55 DC lea edx,dword ptr ss:[ebp-0x24] 00402494 . 50 push eax 00402495 . 51 push ecx 00402496 . 52 push edx ; ntdll.KiFastSystemCallRet 00402497 . 6A 03 push 0x3 00402499 . FF15 F4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeO&gt;; msvbvm50.__vbaFreeObjList 0040249F . 8B06 mov eax,dword ptr ds:[esi] 004024A1 . 83C4 10 add esp,0x10 004024A4 . 56 push esi 004024A5 . FF90 04030000 call dword ptr ds:[eax+0x304] 004024AB . 8B1D 0C414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaOb&gt;; msvbvm50.__vbaObjSet 004024B1 . 50 push eax 004024B2 . 8D45 DC lea eax,dword ptr ss:[ebp-0x24] 004024B5 . 50 push eax 004024B6 . FFD3 call ebx ; &lt;&amp;MSVBVM50.__vbaObjSet&gt; 004024B8 . 8BF8 mov edi,eax 004024BA . 8D55 E8 lea edx,dword ptr ss:[ebp-0x18] 004024BD . 52 push edx ; ntdll.KiFastSystemCallRet 004024BE . 57 push edi 004024BF . 8B0F mov ecx,dword ptr ds:[edi] 004024C1 . FF91 A0000000 call dword ptr ds:[ecx+0xA0] 004024C7 . 85C0 test eax,eax 004024C9 . 7D 12 jge short Afkayas_.004024DD 004024CB . 68 A0000000 push 0xA0 004024D0 . 68 5C1B4000 push Afkayas_.00401B5C 004024D5 . 57 push edi 004024D6 . 50 push eax 004024D7 . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj 004024DD &gt; 56 push esi 004024DE . FF95 40FFFFFF call dword ptr ss:[ebp-0xC0] 004024E4 . 50 push eax 004024E5 . 8D45 D8 lea eax,dword ptr ss:[ebp-0x28] 004024E8 . 50 push eax 004024E9 . FFD3 call ebx 004024EB . 8BF0 mov esi,eax 004024ED . 8D55 E4 lea edx,dword ptr ss:[ebp-0x1C] 004024F0 . 52 push edx ; ntdll.KiFastSystemCallRet 004024F1 . 56 push esi 004024F2 . 8B0E mov ecx,dword ptr ds:[esi] 004024F4 . FF91 A0000000 call dword ptr ds:[ecx+0xA0] 004024FA . 85C0 test eax,eax 004024FC . 7D 12 jge short Afkayas_.00402510 004024FE . 68 A0000000 push 0xA0 00402503 . 68 5C1B4000 push Afkayas_.00401B5C 00402508 . 56 push esi 00402509 . 50 push eax 0040250A . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj 00402510 &gt; 8B45 E8 mov eax,dword ptr ss:[ebp-0x18] ** eax=input serial** 00402513 . 8B4D E4 mov ecx,dword ptr ss:[ebp-0x1C] 00402516 . 8B3D 00414000 mov edi,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaSt&gt;; msvbvm50.__vbaStrCat 0040251C . 50 push eax ; push the serial we input 0040251D . 68 701B4000 push Afkayas_.00401B70 ; **AKA-** 00402522 . 51 push ecx ; **_str** 00402523 . FFD7 call edi ; **get the correct serial &quot;AKA-&quot;+_str** 00402525 . 8B1D 70414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaSt&gt;; msvbvm50.__vbaStrMove 0040252B . 8BD0 mov edx,eax 0040252D . 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20] 00402530 . FFD3 call ebx ; &lt;&amp;MSVBVM50.__vbaStrMove&gt; 00402532 . 50 push eax ; push the correct serial 00402533 . FF15 28414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCm&gt;; **compare** 00402539 . 8BF0 mov esi,eax ; ESI = 0 if equal，1 if not 0040253B . 8D55 E0 lea edx,dword ptr ss:[ebp-0x20] 0040253E . F7DE neg esi ; ESI = -ESI 00402540 . 8D45 E8 lea eax,dword ptr ss:[ebp-0x18] 00402543 . 52 push edx ; ntdll.KiFastSystemCallRet 00402544 . 1BF6 sbb esi,esi ; ESI = ESI-ESI-CF 00402546 . 8D4D E4 lea ecx,dword ptr ss:[ebp-0x1C] 00402549 . 50 push eax 0040254A . 46 inc esi ; ESI++ 0040254B . 51 push ecx 0040254C . 6A 03 push 0x3 0040254E . F7DE neg esi ; ESI = -ESI =&gt; -1 if equal，0 if not 00402550 . FF15 5C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;; msvbvm50.__vbaFreeStrList 00402556 . 83C4 10 add esp,0x10 00402559 . 8D55 D8 lea edx,dword ptr ss:[ebp-0x28] 0040255C . 8D45 DC lea eax,dword ptr ss:[ebp-0x24] 0040255F . 52 push edx ; ntdll.KiFastSystemCallRet 00402560 . 50 push eax 00402561 . 6A 02 push 0x2 00402563 . FF15 F4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeO&gt;; msvbvm50.__vbaFreeObjList 00402569 . 83C4 0C add esp,0xC 0040256C . B9 04000280 mov ecx,0x80020004 00402571 . B8 0A000000 mov eax,0xA 00402576 . 894D 9C mov dword ptr ss:[ebp-0x64],ecx 00402579 . 66:85F6 test si,si 0040257C . 8945 94 mov dword ptr ss:[ebp-0x6C],eax 0040257F . 894D AC mov dword ptr ss:[ebp-0x54],ecx 00402582 . 8945 A4 mov dword ptr ss:[ebp-0x5C],eax 00402585 . 894D BC mov dword ptr ss:[ebp-0x44],ecx 00402588 . 8945 B4 mov dword ptr ss:[ebp-0x4C],eax 0040258B . 74 58 je short Afkayas_.004025E5 分析可得： Name/Serial关系为： _res = strlen(Name)* 0x17CFB +Name[0] Serial = “AKA-_res” python脚本如下： name = raw_input(&apos;please input name:&apos;) serial = len(name)*int(&apos;17cfb&apos;,16) + ord(name[0]) print &apos;AKA-%d&apos;%serial 测试几组数据，正确.","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"点滴算法","slug":"点滴算法","date":"2017-08-18T08:03:20.000Z","updated":"2017-08-18T08:10:58.735Z","comments":true,"path":"2017/08/18/点滴算法/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/18/点滴算法/","excerpt":"我是有一点算法情节的。而我也一直认为学好算法是从事计算机相关行业人员所必备的。里面是我收集的对学习算法有帮助的一些知识。","text":"我是有一点算法情节的。而我也一直认为学好算法是从事计算机相关行业人员所必备的。里面是我收集的对学习算法有帮助的一些知识。 字符转数字、数字转字符: http://blog.sina.com.cn/s/blog_4c8a2a870100qgq7.html","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://leo.dropsec.xyz/tags/ACM/"}]},{"title":"CrackMe 001","slug":"CrackMe-001","date":"2017-08-17T14:02:50.000Z","updated":"2017-08-18T02:05:08.806Z","comments":true,"path":"2017/08/17/CrackMe-001/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/17/CrackMe-001/","excerpt":"适合新手破解的160个crackme练手…好难呀，理解不了我能有什么办法~~ 我也是很无奈哦… 想了想还是需要硬着头皮做下去，谁让我是学计算机的呢？立个flag，之后每天攻克一道crackme…","text":"适合新手破解的160个crackme练手…好难呀，理解不了我能有什么办法~~ 我也是很无奈哦… 想了想还是需要硬着头皮做下去，谁让我是学计算机的呢？立个flag，之后每天攻克一道crackme… 先来观察一下程序点击主界面Serial/Name按钮，进入Name Serial子界面：点击主界面Serial按钮，进入Serial子界面： 明确目标：1.破解Serial子界面的序列号2.破解Name Serial子界面的用户名/序列号 查壳：用PEiD查壳结果为Borland Delphi 3.0，无壳。 破解使用OllyDbg工具打开Acid burn.exe，先破解破解SerialSerial子界面的错误提示框为：智能查找字符串Failed,找到对应汇编代码往上寻找判断代码，很容易发现关键跳所以jnz上面那个Call是比较输入Serial与正确Serial的，下个断点，重载程序，运行，选择Serial模块，输入test程序断在call处，观察此时eax edx的值，结合汇编代码可以得出正确的Serial为:”Hello Dude!” 然后破解Name Serial子界面的用户名/序列号Name Serial子界面的错误提示框为：查找字符串Sorry,找到对应汇编代码 0042FA57 |. 83F8 04 cmp eax,0x4 //长度 &gt;=4 0042FA5A |. 7D 1D jge short 01.0042FA79 0042FA5C |. 6A 00 push 0x0 0042FA5E |. B9 74FB4200 mov ecx,01.0042FB74 ; Try Again! 0042FA63 |. BA 80FB4200 mov edx,01.0042FB80 ; Sorry , The serial is incorect ! 0042FA68 |. A1 480A4300 mov eax,dword ptr ds:[0x430A48] 0042FA6D |. 8B00 mov eax,dword ptr ds:[eax] 0042FA6F |. E8 FCA6FFFF call 01.0042A170 0042FA74 |. E9 BE000000 jmp 01.0042FB37 0042FA79 |&gt; 8D55 F0 lea edx,[local.4] 0042FA7C |. 8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC] 0042FA82 |. E8 D1AFFEFF call 01.0041AA58 0042FA87 |. 8B45 F0 mov eax,[local.4] ; kernel32.763D8744 0042FA8A |. 0FB600 movzx eax,byte ptr ds:[eax] 0042FA8D |. F72D 50174300 imul dword ptr ds:[0x431750] 0042FA93 |. A3 50174300 mov dword ptr ds:[0x431750],eax 0042FA98 |. A1 50174300 mov eax,dword ptr ds:[0x431750] 0042FA9D |. 0105 50174300 add dword ptr ds:[0x431750],eax 0042FAA3 |. 8D45 FC lea eax,[local.1] 0042FAA6 |. BA ACFB4200 mov edx,01.0042FBAC ; CW 0042FAAB |. E8 583CFDFF call 01.00403708 0042FAB0 |. 8D45 F8 lea eax,[local.2] 0042FAB3 |. BA B8FB4200 mov edx,01.0042FBB8 ; CRACKED 0042FAB8 |. E8 4B3CFDFF call 01.00403708 0042FABD |. FF75 FC push [local.1] 0042FAC0 |. 68 C8FB4200 push 01.0042FBC8 ; - 0042FAC5 |. 8D55 E8 lea edx,[local.6] 0042FAC8 |. A1 50174300 mov eax,dword ptr ds:[0x431750] 0042FACD |. E8 466CFDFF call 01.00406718 0042FAD2 |. FF75 E8 push [local.6] 0042FAD5 |. 68 C8FB4200 push 01.0042FBC8 ; - 0042FADA |. FF75 F8 push [local.2] ; kernel32.BaseThreadInitThunk 0042FADD |. 8D45 F4 lea eax,[local.3] 0042FAE0 |. BA 05000000 mov edx,0x5 0042FAE5 |. E8 C23EFDFF call 01.004039AC 0042FAEA |. 8D55 F0 lea edx,[local.4] 0042FAED |. 8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0] 0042FAF3 |. E8 60AFFEFF call 01.0041AA58 0042FAF8 |. 8B55 F0 mov edx,[local.4] ; kernel32.763D8744 0042FAFB |. 8B45 F4 mov eax,[local.3] 0042FAFE |. E8 F93EFDFF call 01.004039FC 0042FB03 |. 75 1A jnz short 01.0042FB1F 0042FB05 |. 6A 00 push 0x0 0042FB07 |. B9 CCFB4200 mov ecx,01.0042FBCC ; Congratz !! 0042FB0C |. BA D8FB4200 mov edx,01.0042FBD8 ; Good job dude =) 0042FB11 |. A1 480A4300 mov eax,dword ptr ds:[0x430A48] 0042FB16 |. 8B00 mov eax,dword ptr ds:[eax] 0042FB18 |. E8 53A6FFFF call 01.0042A170 0042FB1D |. EB 18 jmp short 01.0042FB37 0042FB1F |&gt; 6A 00 push 0x0 0042FB21 |. B9 74FB4200 mov ecx,01.0042FB74 ; Try Again! 0042FB26 |. BA 80FB4200 mov edx,01.0042FB80 ; Sorry , The serial is incorect ! 0042FB2B |. A1 480A4300 mov eax,dword ptr ds:[0x430A48] 0042FB30 |. 8B00 mov eax,dword ptr ds:[eax] 0042FB32 |. E8 39A6FFFF call 01.0042A170 0042FB37 |&gt; 33C0 xor eax,eax 分析可得0x0042FA57处的指令”CMP EAX,4”限制了输入的Name的长度必须大于等于40x0042FA79 - 0x0042FAFE的代码验证了输入的Name/Serial是否正确，根据验证结果进行跳转将0x0042FA87 - 0x0042FAFE的代码单独拎出来，分析如下： 0042FA87 |. 8B45 F0 mov eax,[local.4] ; save name sddress 0042FA8A |. 0FB600 movzx eax,byte ptr ds:[eax] ; save first char of name to eax 0042FA8D |. F72D 50174300 imul dword ptr ds:[0x431750] ; eax *= 41 0042FA93 |. A3 50174300 mov dword ptr ds:[0x431750],eax ; [0x431750] = EAX 0042FA98 |. A1 50174300 mov eax,dword ptr ds:[0x431750] ; EAX = [0x431750] 0042FA9D |. 0105 50174300 add dword ptr ds:[0x431750],eax ; eax*=2 标记为 _res 0042FAA3 |. 8D45 FC lea eax,[local.1] 0042FAA6 |. BA ACFB4200 mov edx,01.0042FBAC ; CW 0042FAAB |. E8 583CFDFF call 01.00403708 0042FAB0 |. 8D45 F8 lea eax,[local.2] 0042FAB3 |. BA B8FB4200 mov edx,01.0042FBB8 ; CRACKED 0042FAB8 |. E8 4B3CFDFF call 01.00403708 0042FABD |. FF75 FC push [local.1] ; push CW 0042FAC0 |. 68 C8FB4200 push 01.0042FBC8 ; - 0042FAC5 |. 8D55 E8 lea edx,[local.6] 0042FAC8 |. A1 50174300 mov eax,dword ptr ds:[0x431750] ; eax= _res 0042FACD |. E8 466CFDFF call 01.00406718 ; itos(), remember the result as _str 0042FAD2 FF75 E8 push dword ptr ss:[ebp-0x18] ; push _str 0042FAD5 68 C8FB4200 push 01.0042FBC8 ; - 0042FADA |. FF75 F8 push [local.2] ; push &quot;CRACKED&quot; 0042FADD |. 8D45 F4 lea eax,[local.3] 0042FAE0 |. BA 05000000 mov edx,0x5 0042FAE5 |. E8 C23EFDFF call 01.004039AC ; get the correct serial &quot;CW-&quot;+_str+&quot;-CRACKED&quot; 0042FAEA |. 8D55 F0 lea edx,[local.4] 0042FAED |. 8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0] 0042FAF3 |. E8 60AFFEFF call 01.0041AA58 0042FAF8 |. 8B55 F0 mov edx,[local.4] ; get the real serial we input 0042FAFB |. 8B45 F4 mov eax,[local.3] ; the real serial 0042FAFE |. E8 F93EFDFF call 01.004039FC ; compare 可知正确的Name/Serial关系为 _res = Name[0] 0x29 2，Serial = “CW-_res-CRACKED”能够写注册机了： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #define N 10000 using namespace std; int main() { char buffer[N]; short int c; cout&lt;&lt;&quot;please input name:\\n&quot;; gets(buffer); if(strlen(buffer)&lt;4) //判断序列号长度 { cout&lt;&lt;&quot;Error!&quot;&lt;&lt;endl; } else { c=buffer[0]; c=c*0x29; c=c*2; cout&lt;&lt;&quot;serial:&quot;&lt;&lt;endl; printf(&quot;Serial: CW-%4d-CRACKED\\r\\n&quot;,c); } return 0; } PS:分析算法真是让人头疼…","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"在线小工具推介","slug":"在线小工具推介","date":"2017-08-16T07:24:58.000Z","updated":"2017-08-16T07:37:33.708Z","comments":true,"path":"2017/08/16/在线小工具推介/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/16/在线小工具推介/","excerpt":"这里对你而言可能会有一些比较好用的在线小工具哦。 更新ing…","text":"这里对你而言可能会有一些比较好用的在线小工具哦。 更新ing… 草料二维码生成器 http://cli.im电脑二维码扫描器 https://cli.im/deqrMD5加密 https://md5jiami.51240.com各种查询工具 https://www.51240.com有道翻译 http://fanyi.youdao.com进制转换 http://tool.oschina.net/hexconvert二级域名查询 http://i.links.cn/subdomain","categories":[],"tags":[{"name":"工具or软件","slug":"工具or软件","permalink":"http://leo.dropsec.xyz/tags/工具or软件/"}]},{"title":"合天 CTF-REVERSE练习之.NET WP","slug":"合天-CTF-REVERSE练习之-NET-WP","date":"2017-08-13T11:37:47.000Z","updated":"2017-08-13T11:55:50.495Z","comments":true,"path":"2017/08/13/合天-CTF-REVERSE练习之-NET-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/13/合天-CTF-REVERSE练习之-NET-WP/","excerpt":"想学好逆向、想打好CTF，想学好网安，需要掌握的知识很多吖，就一个简单的逆向想做好就关系到.NET、C#，还要熟悉其语法写出脚本，而我现在什么都还不会…唉，骚年，在最平静的大学生活中努力吧。","text":"想学好逆向、想打好CTF，想学好网安，需要掌握的知识很多吖，就一个简单的逆向想做好就关系到.NET、C#，还要熟悉其语法写出脚本，而我现在什么都还不会…唉，骚年，在最平静的大学生活中努力吧。REVERSE是CTF竞赛中的一种常见题型，除了对常见的二进制程序进行逆向分析之外，对.NET程序的分析也是一个考查点。本实验通过实例讲解如何对简单的.NET程序进行逆向分析，并介绍.NET逆向分析工具ILSpy的使用。 这个实验的核心在于熟练.NET及其反编译软件，也涉及到加密与解密的算法，而我还很菜很菜，目前这个水平还不能完全驾驭它，故请大家来看标准的实验指导书","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"合天 CTF-REVERSE练习之病毒分析 WP","slug":"合天-CTF-REVERSE练习之病毒分析-WP","date":"2017-08-13T10:28:17.000Z","updated":"2017-08-13T10:51:52.899Z","comments":true,"path":"2017/08/13/合天-CTF-REVERSE练习之病毒分析-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/13/合天-CTF-REVERSE练习之病毒分析-WP/","excerpt":"病毒分析，停起来很厉害的一个名字，首次接触，在做完这个实验之后，感觉也没什么好写的，可能是自己水平还是太低，没能体会到其精髓吧…故暂且将实验指导书拿来。","text":"病毒分析，停起来很厉害的一个名字，首次接触，在做完这个实验之后，感觉也没什么好写的，可能是自己水平还是太低，没能体会到其精髓吧…故暂且将实验指导书拿来。其中推荐的三个沙箱都用不了哦。………………………………………..在查询“后门文件”是什么的时候，偶然发现这个:https://zhidao.baidu.com/question/1669211327117057667.html可以尝试一下哦… 小小分享：MD5在线加密 https://md5jiami.51240.com/有道在线翻译 http://fanyi.youdao.com/各种查询工具 https://www.51240.com/ （ ￣︶￣ ）↗","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"合天 CTF-REVERSE练习之信息提取 WP","slug":"合天-CTF-REVERSE练习之信息提取-WP","date":"2017-08-13T08:02:40.000Z","updated":"2017-08-13T09:05:56.591Z","comments":true,"path":"2017/08/13/合天-CTF-REVERSE练习之信息提取-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/13/合天-CTF-REVERSE练习之信息提取-WP/","excerpt":"有两个比较喜欢的女歌手我一直搞混，曲婉婷、范玮琪。总是想起来这个而记不起那个，记得之前高三的时候跟二百说这个，他说这两个人风格完全不一样，怎么会混淆…( ╯□╰ )OK,开始切入正题…","text":"有两个比较喜欢的女歌手我一直搞混，曲婉婷、范玮琪。总是想起来这个而记不起那个，记得之前高三的时候跟二百说这个，他说这两个人风格完全不一样，怎么会混淆…( ╯□╰ )OK,开始切入正题…本实验主要介绍了CTF-REVERSE信息提取，通过本实验的学习，你能够掌握十六进制编辑器C32Asm的基本用法，了解图片Exif信息，以及快速提取二维码中信息的方法，了解PNG图片格式的基本特征。我也是首次接触这个吖 预备知识一：C32Asm一款非常不错的国产静态反编译工具，C32Asm现具有如下功能：快速静态反编译PE格式文件(Exe、Dll等)，提供Hex文件编辑功能，功能强大，提供内存Dump、内存编辑、PE文件Dump、PE内存ImageSize修正等多种实用功能。通常主要讲C32Asm当做16进制编辑器来使用，因为成熟的静态反编译工具如IDA等已经非常强大了，本实验中也只使用C32Asm的十六进制编辑器功能。C32Asm可以十分方便的进行十六进制编辑操作，同时支持对指定的数据块进行各种运算操作，包括异或运算等。 二：二维码二维码（Quick Response Code），又称二维条码。它是用特定的几何图形按一定规律在平面（二维方向）上分布的黑白相间的图形，是所有信息数据的一把钥匙。在现代商业活动中，二维码的应用十分广泛，如：产品防伪/溯源、广告推送、网站链接、数据下载、商品交易、定位/导航、电子商务应用、车辆管理、信息传递等。如今的二维码应用十分的广泛，许多手机APP都可以进行二维码信息的识别以及二维码图片生成等，互联网上也有许多支持二维码生成以及二维码信息提取的网站，如http://cli.im 等。 三：Exif信息Exif是一种图象文件格式，它的数据存储与JPEG格式是完全相同的。实际上Exif格式就是在JPEG格式头部插入了数码照片的信息，包括拍摄时的光圈、快门、白平衡、ISO、焦距、日期时间等各种和拍摄条件以及相机品牌、型号、色彩编码、拍摄时录制的声音以及全球定位系统（GPS）、缩略图等。简单地说，Exif=JPEG+拍摄参数。因此，你可以利用任何可以查看JPEG文件的看图软件浏览Exif格式的照片，但并不是所有的图形程序都能处理Exif信息。 操作打开给的文件，发现是一张图片,提示语：奇怪的狗尾巴！汪汪汪通常拿到图片之后，首先查看图片的属性信息中是否存在Exif提示信息，我们通过查看文件属性，发现程序没有Exif信息，如图所示：然后用C32Asm打开文件，发现文件开头字节是BM说明它确实是BMP位图。根据“奇怪的狗尾巴！汪汪汪”给我们的提示，可能是在文件末尾有信息。拉到最下面，在C32Asm中拖动到文件末尾，发现了一个IEND字符串，如图所示注意在PNG图片格式中，PNG数据由一个一个数据块（Data Chunk）组成。每个数据块都有一个4字节长度的标识，典型的有IHDR、IDAT、IEND等。完整的PNG数据总是以一个IHDR块开头，最终以一 个IEND块结束的，而真正表示图像数据的IDAT块则嵌在IHDR块和IEND块之间。这里可以猜测在BMP图片的末尾附加了一个PNG图片，那么继续往上查找，我们看到了IHDR标志，找到IHDR前面的PNG标志，复制出PNG数据。详细步骤如下1）在C32Asm中使用鼠标选择从0xB6C16开始的数据，直到文件末尾2）右键，拷贝-&gt;拷贝3）在文件中新建十六进制文件，在新键文件中选中自带的00右键粘贴4）文件中保存文件为test.png图片打开这张图片发现是一张二维码，保存，打开http://cli.im/deqr ，选择“上传二维码图片”，将刚刚保存的二维码图片进行上传识别，得到一个URLhttp://blog.sina.com.cn/s/blog_703d65470102v6tf.html 访问这个URL，看到一篇文章“一张美美的图片”，提示信息为“二维码图片末尾还有数据哦，尝试进行异或运算，key为0x88”。再次使用C32Asm打开test.png二维码图片，按下Ctrl+A选择所有数据，单击鼠标右键，在弹出的菜单中选择“修改数据”， 在弹出的“修改数据”对话框中，选择“异或”运算，后边填入88，单击确定按钮，就可以看到flag信息了，如图所示：我们看到图片的末尾为“flag{CtF_Re_iS_FuN}”，这就是我们要找的flag了。 小小提示：电脑扫二维码网址：http://cli.im/deqr二维码制作网址：http://cli.im","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"合天 CTF-REVERSE练习之脱壳分析 WP","slug":"合天-CTF-REVERSE练习之脱壳分析-WP","date":"2017-08-13T03:28:40.000Z","updated":"2017-08-15T04:26:37.565Z","comments":true,"path":"2017/08/13/合天-CTF-REVERSE练习之脱壳分析-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/13/合天-CTF-REVERSE练习之脱壳分析-WP/","excerpt":"这个脱壳分析实验和之前写的“壳与ESP定律“内容有些是重复的，因为这个实验就使用了ESP定律来脱壳的，但是这个实验在某些方面比较详细，是一个不错的补充，特别是脱壳后对软件的修复…","text":"这个脱壳分析实验和之前写的“壳与ESP定律“内容有些是重复的，因为这个实验就使用了ESP定律来脱壳的，但是这个实验在某些方面比较详细，是一个不错的补充，特别是脱壳后对软件的修复… 运行这个软件是这样的用PEID查壳，发现是UPX壳这个时候如果拖进IDA去分析的话会弹出一些提示意味着程序经过加壳处理，最好不要用IDA去进行分析，因为加壳后的程序很难通过IDA的静态分析来理解程序的内部执行逻辑。所以我们用OD打开，接下来就是运用ESP定律来脱壳了F8单步，发现只有ESP、EIP寄存器变红的时候就可以用ESP了然后选择ESP的内容，右键-&gt;数据窗口中跟随，然后在数据窗口中选中对应数据 ，右键，断点-&gt;硬件访问-&gt;对应字节。然后就设置好硬件断点了。F9运行到断点然后就可以删除断点了 ，调试-&gt;硬件断点-&gt;删除。F7单步，会有一个循环很烦人，所以选中循环下的语句，F4直接运行到这里F8单步到004094F8，这就是OEP，右键选择用OD脱壳注意94F8才是程序入口。然后脱壳输入文件名保存。现在请不要关闭OD，后面还需要进行修复操作。对UPX脱壳而言，进行到这一步就可以了，但是如果是另外一些壳，可能还需要对程序的输入表进行修复操作。 修复脱壳后的程序注意在继续进行实验之前，请确保你停留在实验步骤二中最后的一步。现在打开桌面上的ImportREC程序，首先在进程列表中选择C:\\Reverse\\6\\crackme6.exe，然后在OEP中填入94F8（也就是在OD中找到的一个信息），然后点击“IAT AutoSearch”按钮，接着点击“GetImports”按钮，就可以看到程序的输入表信息了。点击右侧的“Show Invalid”按钮，看看是否存在无效的输入表项目。无效的输入表项目前面带有问号（？），如果有可以使用右键菜单删除。这里没有无效的输入表项目，所以选择“Fix Dump”按钮，对我们的dumped.exe进行修复，得到dumped.exe程序。现在对程序的脱壳以及修复操作已经全部完成，使用PEiD对dumped.exe程序查壳，可以看到提示“Microsoft Visual C++ 6.0”信息，dumped_.exe程序也可以正常运行，至此脱壳完成。…………………………………………………………………………………………………………………………..以上是合天的一个实验指导，当我在实验吧看到一个类似的实验时，发现实验吧对这个类似题目处理的步骤增多了，下面简单补充： 在用OD的脱壳工具查看OEP之后，发送到LordPE软件，选择带脱壳的软件，右键选择“修正镜像大小”，单机确定按钮；然后再次选择带脱壳软件，右键选择“完整保存”，保存即可。 然后将它发送到ImportREC软件，下拉对话框中选择程序，输入OEP，单击IAT自动查找，然后单击获取导入表，然后单击显示无效函数，有的话右键删除，没有就单击修正转存，保存即可。（完成脱壳）…………………………………………………………………………………………………………………………..以上两步应该算是软件的修复吧，有些软件还需要去除软件大小自校验将脱壳后的软件发送到OD，菜单栏选择插件-&gt;APId断点设置工具-&gt;常用断点设置，弹出窗口选择文件处理-&gt;GetFileSize,F9运行，断点处暂停单击堆栈窗口，右键选择在反汇编窗口中跟随单击反汇编窗口调用函数的代码行，F2，然后切换到断点窗口（B），删除GetFileSize断点 ，程序中的GetFileSize函数获取了脱壳后程序的大小，然后利用命令cmp eax,0xc6c8命令比较，不相等则跳转 ，脱壳后程序要比源程序大，所以跳转退出程序。。把两个Ja的命令NOP掉，去除软件大小限制，然后选择所以修改保存即可。然后运行程序发现可以正常运行了…(有些软件以上三步缺一步就不可以正常 运行…)","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"合天 CTF-REVERSE练习之算法分析2 WP","slug":"合天-CTF-REVERSE练习之算法分析2-WP","date":"2017-08-12T13:27:21.000Z","updated":"2017-08-13T10:55:35.460Z","comments":true,"path":"2017/08/12/合天-CTF-REVERSE练习之算法分析2-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/12/合天-CTF-REVERSE练习之算法分析2-WP/","excerpt":"本实验以自定义算法为例，讲解如何编写一个注册机。 积累经验喽…","text":"本实验以自定义算法为例，讲解如何编写一个注册机。 积累经验喽…本题的核心在于分析自定义算法，进而写出注册机，所以这里直接看关键代码。长方形括住的的是核心代码，简化为 szUsername[v1] ^ byte_423678[v1] == szPassword[v1]根据异或运算的性质，上述条件可以转换为 szPassword [v1] ^ byte_423678[v1] == szUsername [v1]我们需要把byte_423678的内容提取出来，为： 1, 2, 3, 4, 1, 5, 1, 5, 1, 3, 6, 5, 4, 8, 5, 3, 1, 2, 3, 4, 5, 3, 5, 7, 2, 3, 2, 4, 8, 2, 5, 6, 4 这就是我们找到的XOR密钥数组。程序的注册算法为：将用户名的每一个字符与XOR密钥数组中的对应下标的字符进行异或运算，产生注册码字符串对应的字符。 我们编写这样一段Python脚本即可： def crack(username): key = [1, 2, 3, 4, 1, 5, 1, 5, 1, 3, 6, 5, 4, 8, 5, 3, 1, 2, 3, 4, 5, 3, 5, 7, 2, 3, 2, 4, 8, 2, 5, 6, 4] pwd = [] for i in xrange(0, len(username)): pwd.append(chr(ord(username[i]) ^ key[i])) return &quot;&quot;.join(pwd) if __name__ == &quot;__main__&quot;: while True: username = raw_input(&quot;input username:&quot;) serial = crack(username) print &quot;serial: %s&quot; % serial 我们输入用户名Wins0n，就可以得到注册码为Vkmw1k，输入程序可以成功注册","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"合天 CTF-REVERSE练习之算法分析1 WP","slug":"合天-CTF-REVERSE练习之算法分析1-WP","date":"2017-08-12T09:48:25.000Z","updated":"2017-08-13T10:55:22.615Z","comments":true,"path":"2017/08/12/合天-CTF-REVERSE练习之算法分析1-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/12/合天-CTF-REVERSE练习之算法分析1-WP/","excerpt":"有点伤心、有的无奈，实验指导书中并不是全部步骤都十分理解，但是我还是需要尝试着写一下，万一再琢磨一下就懂了呢？","text":"有点伤心、有的无奈，实验指导书中并不是全部步骤都十分理解，但是我还是需要尝试着写一下，万一再琢磨一下就懂了呢？算法分析是CTF REVERSE题型中的一个常见考察点，相对于字符串明文跟踪而言，算法分析具有更大的挑战性，参赛选手需要仔细理解程序内部关键算法的过程，才能编写出注册机（Keygen）。本实验以MD5算法为例，讲解如何识别程序内部使用的算法类型，并讲解IDA的一些基本功能来加速我们的理解过程。 实验准备一、PEiD密码算法分析插件PEiD有一个叫做Krypto ANALyzer的插件，使用这个插件可以对程序进行扫描，通过特征匹配来识别程序内部可能用到的一些标准算法。Krypto ANALyzer的使用方法为：点击PEiD主界面右下角的“=&gt;”按钮，选择“插件”菜单项，然后选择“Krypto ANALyzer”，就可以弹出Krypto ANALyzer插件了。Krypto ANALyzer插件会自动分析程序内部可能用到的标准算法下图中显示了程序中在地址00401E5C处存在MD5算法的特征： 二、IDA重命名等功能在IDA中，我们可以通过按下N键来对一个变量/函数/标记等进行重命名操作，函数和变量命名对于帮主我们理解程序的内部逻辑非常重要，就好比我们在编程的时候，培养良好的编程风格非常重要一样。比如如果函数sub_4012E0经过我们分析之后，确定其功能为将传入的字符串转为大写形式，那么我们可以选中sub_4012E0后按下N键对其进行重命名（将函数名命名为fnStringToUpper）：IDA通过还可以给汇编指令或者伪代码来添加注释。如果要对某一条汇编指令添加注释，只需要在汇编指令所在行按下封号（即;）即可弹出对话框来接收注释；如果要给伪代码添加注释，则只需在伪代码所在行按下斜杠（即/）即可弹出对话框来接收注释。OD也可以给汇编指令添加注释，只需要在汇编指令所在行后一列的空白处双击鼠标左键即可，如图所示： 实际操作通过API交叉引用快速定位关键代码观察程序，运行这个程序后要求输入一个用户名和密码进行注册，当注册失败的时候，程序将弹出一个消息框提示不正确，如图所示：那么我们可以通过IDA的交叉引用功能来定位这一块的代码。使用IDA载入CrackMe4.exe程序，待分析结束后，通过Imports TAB页面找到MessageBoxA，双击来到反汇编视图，在MessageBoxA按下X按键对其进行交叉引用查找，经过一个一个进行分析，我们发现sub_4016B0就是我们所要找的关键函数，我们通过F5得到这个函数的伪代码。通过对伪代码添加注释，以及对变量进行重命名操作，我们得到如下的代码片段：上面的伪代码有两个错误，就是在第一个if语句中会判断密码的长度是否为33，如果不是33就弹出错误提示。其实这里是32（而用户名的长度则不能大于10）只是Hex-Rays Decompiler这个插件生成伪代码时出错了，所以需要记住，F5生成的伪代码并不保证完全正确。32这个长度对应汇编指令中的代码片段如下：通过上面的伪代码的分析，我们发现只有sub_401510这个函数的功能并不清楚，通过双击sub_401510查看对应的伪代码，发现有点复杂，暂时无法理解，不过这并不要紧。 使用PEiD的Krypto ANALyzer识别算法如果程序使用了标准算法进行处理，那么可以使用PEiD的Krypto ANALyzer进行快速识别，将CrackMe4.exe载入PEiD，点击PEiD主界面右下角的“=&gt;”按钮，选择“插件”菜单项，然后选择“Krypto ANALyzer”，就可以弹出Krypto ANALyzer插件了，Krypto ANALyzer提示程序使用了MD5算法，如下图所示：我们记住00401E5C这个地址，在IDA的反汇编指令视图（IDA View）中按下G键，输入00401E5C，就会自动跳转到计算MD5的函数代码中，如图所示：从这里并不能得到什么有用的信息，我们需要通过不断的回溯来理解程序的代码逻辑。通过往上查阅代码，我们知道00401E5C 位于函数sub_401D10之中，我们对sub_401D10进行交叉引用查找，如图所示：可以从sub_401D10回溯到sub_4026F0，继续通过交叉引用往上回溯，依次为sub_4027B0、sub_401C00、sub_401BB0、sub_401510，而sub_401510就是我们在实验步骤一种为一个暂时不理解的函数。那么我们可以猜测sub_401510这个函数就是用来计算用户名的MD5值的，我们可以通过OD动态调试来验证我们的想法。通过阅读IDA中的反汇编代码，我们知道在00401752处调用了sub_401510这个函数现在OD载入CrackMe4.exe程序，在00401752处设置一个断点，然后按F9运行程序，用户名输入test，密码输入一个32个字符的任意字符串，单击“注册”按钮，程序便会自动断下，断下后按F8进行单步跟踪，执行sub_401510这个函数后，我们看到eax寄存器的值为098F6BCD4621D373CADE4E832627B4F6，这个恰好就是test的MD5值。 编写注册机现在我们已经将程序的注册算法分析清楚了，下面就可以编写一个注册机了。程序的注册算法为：将用户名进行MD5计算得到一个哈希值，将哈希值转换为大写字符串即可，其中用户名的长度在1~10之间，不能超过10.Python内置了MD5算法，可以非常方便的计算MD5值，我们编写这样一段脚本即可： import hashlib while True: username = raw_input(&quot;input username:&quot;) md5 = hashlib.md5(username).hexdigest().upper() serial = md5[::-1] # 翻转字符串 print &quot;serial: %s&quot; % serial 我们输入用户名Wins0n，就可以得到注册码为51F561458ADAEEBA43A57CF7E59F6CC4，输入程序可以成功注册，如图所示： “抄”完的我快难受死了….","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"合天 CTF-REVERSE练习之API断点 WP","slug":"合天-CTF-REVERSE练习之API断点-WP","date":"2017-08-12T06:28:27.000Z","updated":"2017-08-13T10:55:05.511Z","comments":true,"path":"2017/08/12/合天-CTF-REVERSE练习之API断点-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/12/合天-CTF-REVERSE练习之API断点-WP/","excerpt":"通过OD的API参考断点以及IDA中针对API的交叉引用查找功能，可以快速定位到调用特定API的位置。但通过API动态调用技术，可以有效对抗这种逆向分析方法。本实验通过对API直接设置断点以及利用MessageBox的阻塞特性，介绍了针对API动态调用的逆向分析方法。","text":"通过OD的API参考断点以及IDA中针对API的交叉引用查找功能，可以快速定位到调用特定API的位置。但通过API动态调用技术，可以有效对抗这种逆向分析方法。本实验通过对API直接设置断点以及利用MessageBox的阻塞特性，介绍了针对API动态调用的逆向分析方法。这个程序基本上和前两个是一样的马甲，但是如果你尝试用之前的方法来找到密码，是很难行的通的。so,我们来学习新东西… 一：利用API断点跟踪关键函数代码该程序外形和之前的一样，再次不在赘述，直接OD载入，Ctrl+G,在窗口中输入MessageBoxA,确定,来到MessageBoxA的调用点，F2下断点F9运行，在弹出窗口输入test，确定。程序在MessageBoxA的第一条指令断下，点击菜单栏调试-&gt;执行到用户代码，这时候CrackMe的错误提示消息框将会弹出来，我们点击消息框的“确定”按钮，程序在OD中会再次断下。这次是因为点击了“执行到用户代码”的原因，OD会在调用了MessageBoxA的下一条指令自动断下，如图所示：可以知道004015F6处的call就是调用了MessageBoxA函数F8单步跟踪，消息框中出现字符串，它就是我们想要的密码…………………………………………………… 在上面步骤中，我们在MessageBoxA断下后，通过“执行到用户代码”回到CrackMe空间的代码，通过简单的F8单步跟踪，就很幸运的看到了过关密码。然而在实际调试过程中，可能需要跟踪很久才能发现一点蛛丝马迹，那么我们可以结合IDA的静态分析功能来加速我们的逆向过程。在前面的分析中，我们知道在004015F6这个地址调用了MessageBoxA函数，现在使用IDA载入CrackMe3.exe，待分析结束后按下G，然后输入“004015F6”后点击OK按钮，就会自动跳转到004015F6这个地方了，如图所示：F5查看伪代码，很容易发现密码 实际逆向过程中，要学会OD与IDA熟练结合使用。扬长避短。 …………………………………………………… 二：利用MessageBox的阻塞特性定位关键代码我们知道MessageBox是一个阻塞的API，就是当调用这个API的时候，会弹出一个消息框，此时程序的代码执行流就会自动阻塞在调用MessageBox的地方，直到点击提示框上的按钮或者关闭提示框时，程序才会继续往下执行。那么在程序弹出MessageBox的时候，我们可以在OD中让程序断下来，然后通过“执行到用户代码”来回到调用MessageBox的地方，这就是说MessageBox本身就类似于“断点”。使用OD载入CrackMe3.exe，如果之前设置了断点，为了防止干扰，我们需要先清除掉之前设置的断点。F9运行程序，在窗口输入test，点击确定，出现错误提示窗口，不要点击确定。F12暂停程序。选择菜单调试-&gt;执行到用户代码。错误提示窗口点击确定，程序在OD中会再次断下。这次是因为点击了“执行到用户代码”的原因，OD会在调用了MessageBoxA的下一条指令自动断下，如图所示然后你突然就懂了…(F8。。。)","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"合天 CTF REVERSE练习之API定位 WP","slug":"合天-CTF-REVERSE练习之API定位-WP","date":"2017-08-11T08:56:14.000Z","updated":"2017-08-13T10:54:02.869Z","comments":true,"path":"2017/08/11/合天-CTF-REVERSE练习之API定位-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/11/合天-CTF-REVERSE练习之API定位-WP/","excerpt":"通过字符串引用查找来定位关键函数代码是一种常用的简单有效的分析方法，而在字符串经过处理时，这种方法就失效了，本实验将介绍一种新的分析方法：通过关键API交叉引用查找以及通过对关键API下断点来定位关键函数的代码。","text":"通过字符串引用查找来定位关键函数代码是一种常用的简单有效的分析方法，而在字符串经过处理时，这种方法就失效了，本实验将介绍一种新的分析方法：通过关键API交叉引用查找以及通过对关键API下断点来定位关键函数的代码。一样，先用PEID查看程序是否加壳，发现没壳。然后观察程序，发现貌似和第一题一样加载进OD，不妨按照第一题的思路那样查找字符串，发现找不到这是因为字符串是通过LoadString加载的，OD无法通过字符串查找的方法来定位资源中定义的字符串条目。so，只能开辟新的途径喽…右键反汇编窗口选择查找-&gt;当前模块中的名称（标签），在跳出的窗口中直接输入messageboxa,右键这条语句，窗口中选择“在每个参考上设置断点”，在OD最下方的状态栏上会看到“已设置 2 个断点”的提示。F9运行，弹出窗口输入test，确定，暂停到对messageboxa调用的地方然后，查看其附近的代码，发现上方出现了密码。…………………………………………………………..接下来用IDA实现，载入程序，点击Imports TAB页面，直接输入messageboxa，双击这条语句，来到messageboxa定义的位置，选中messageboxa后按X键，弹出交叉引用列表窗口，共有四条我们并不能直接看出哪一个引用就是我们所要找的引用，所以需要一个一个进行查看（根据前面使用OD对程序的分析，我们知道在MessageBoxA之前有许多对LoadString的调用，因此通过对比几个交叉引用，可以断定sub_401450就是我们要找的函数）使用F5还原sub_401450函数的伪代码，伪代码如下：我们断定LoadString加载资源ID为0x6A的字符串就是我们要找的密码，现在使用Restorator打开CrackMe2.exe程序来查看字符串资源，如图所示，0x6A的十进制即106，因此可以知道密码就是HeeTianLab了。 额外补充： IDA的交叉引用功能能针对系统API，也能对自定义函数发挥作用 即使对字符串做加密处理也不能阻止通过API来定位关键函数代码 IDA也无法通过Strings Window来查看资源中定义的字符串条目","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"合天 CTF-REVERSSE练习之逆向初探 WP","slug":"合天-CTF-REVERSSE练习之逆向初探-WP","date":"2017-08-11T06:31:26.000Z","updated":"2017-08-13T10:56:00.418Z","comments":true,"path":"2017/08/11/合天-CTF-REVERSSE练习之逆向初探-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/11/合天-CTF-REVERSSE练习之逆向初探-WP/","excerpt":"暑假任务书上让做实验吧上的实验，并且需要写下WP，那我就听话写一写呗…","text":"暑假任务书上让做实验吧上的实验，并且需要写下WP，那我就听话写一写呗…拿到题目先观察，是这个样子的：不输入密码点确定是这个样子的：随便输入一个密码(比如test)是这个样子的“然后开始逆向，先用PEID查看 是否带壳：发现没有带壳，然后选择OD或IDA进行逆向分析，这里先用OD查看，载入程序，右键选择智能查找字符串-&gt;ASCII,出现字符串窗口Ctrl+f查找关键字，如密码错误找到关键字符双击进入对应反汇编窗口发现关键字上边有一个明显的jnz向错误提示跳转，它就是关键跳转，NOP掉就可以实现爆破了。这里我们来寻找注册码。从jnz往上看代码，会发现有部分风格完全变的不一样，就在这里下个断点重新载入程序，F9，在弹出的窗口中输入test，F8单步运行，运行到00401490出时在信息窗口中出现输入的错误密码test，及HeeTianLab猜测HeeTianLab就是正确的密码，结合附近上下的代码分析，此处在拿输入的密码和正确的进行一一比较，不一样则跳转到错误语句。把HeeTianLab输入到另外一个新程序中,密码正确。………………………………………………….也可以用IDA进行分析，载入程序，shift+F12，查找关键字符串，双击进入，选中对应字符串，按X进行交叉引用查找，来到引用字符串的地方F5查看伪代码，发现就是那输入字符串与HeeTianLab进行比较。故得到正确密码。 注意：按F5查看伪代码，有时候会发现界面没反应，原因有可能是没有选对正确位数的IDA。","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"壳与ESP定律","slug":"壳与ESP定律","date":"2017-08-10T12:58:45.000Z","updated":"2017-08-16T06:09:38.809Z","comments":true,"path":"2017/08/10/壳与ESP定律/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/10/壳与ESP定律/","excerpt":"好不容易略懂了一点ESP…","text":"好不容易略懂了一点ESP… 一：知识准备 通过前面的学习，学会了利用暴力破解达到绕过注册机制和追踪注册码来达到“合法”用软件的方法，但是我们往往会遇到代码经过混淆器混淆的程序，此类混淆器可以称之为壳，壳又可分为压缩壳（常见的有UPX、北斗、ASDPack、Npack、PECompact等）和保护壳（如强壳Safengine、VMprotect、winlicense、Themida等），压缩壳作用是把程序进行体积缩小化处理，保护壳主要作用是混淆或加密代码防止他人进行逆向程序、破解程序。我们可以通过一些侦壳程序进行识别，但有些壳会采用伪装技术来混淆侦壳程序。 ESP定律的原理：堆栈平衡原理。ESP定律是堆栈平衡原理在实践中的一个应用。所谓堆栈平衡原理，即加壳程序运行时，需要先保存原程序的初始现场，将现场状态压入堆栈，待壳运行完毕后，将原程序的现场状态出栈，此时开始运行原程序。在具体应用时，通过记录堆栈寄存器存储原程序初始现场状态的地址，并使程序在为将初始状态出栈而访问以记录的地址时中断，程序中断处便在OEP附近。 ESP定律的适用范围是什么？几乎全部的压缩壳，部分加密壳。只要是在JMP到OEP后，ESP=0012FFC4的壳，理论上我们都可以使用。但是在何时下断点避开校验，何时下断OD才能断下来，这还需要多多总结和多多积累。ESP定律法的步骤ESP定理脱壳（ESP在OD的寄存器中，我们只要在命令行下ESP的硬件访问断点，就会一下来到程序的OEP了！）（1）开始就点F8，注意观察OD右上角的寄存器中ESP有没突现（变成红色）（这只是一般情况下，更确切的说我们选择的ESP值是关键句之后的第一个ESP值）当有且只有ESP和EIP为红色时，我们可以用ESP定律了（2）在命令行下：dd XXXXXXXX(指在当前代码中的ESP地址，或者是hr XXXXXXXX)，按回车（3）选中下断的地址，断点—&gt;硬件访问—&gt;WORD断点（4）按一下F9运行程序，直接来到了跳转处，按下F8，到达程序OEP二：实战操作1.查壳用PEID查壳结果如下：2.寻找OEP(1)OD载入程序(2).按F8，发现只有ESP、EIP是红色。记下此时ESP的值0019FF64（每个人机器上运行这个值有可能不同）(3).在Command命令行中输入dd 0019FF64,回车(4).选中要下断点的0019FF64那一行，右键，依次选择断点 -&gt; 硬件访问 -&gt; Word(5).在菜单栏调试（D）下的硬件断点（H）下选项下可以看到我们设置的硬件断点,确定。(6).然后按一下F9运行程序，如下：(7).运用F8很快会到达程序的OEP(8).然后我们就可以脱壳了，脱壳前我们先把断点清理掉，以免出错【调试→硬件断点→删除】3.脱壳（使用OD自带插件）右击程序当前位置第一行代码，选择OllyDump脱壳调试进程,然后我们在弹出的窗口中选择脱壳，然后输入要另存为的文件名此时，我们已经脱壳结束，检查下程序能否正常运行,再看下PEID对比脱壳前和脱壳后的不同.到此，脱壳就完成了。 小小总结文中用到的加壳程序下载地址：http://download.csdn.net/detail/qiurisuixiang/4363770 参考链接1：http://blog.csdn.net/qiurisuixiang/article/details/7649799参考链接2：http://www.cnblogs.com/ichunqiu/p/6213852.html参考链接3：http://www.52pojie.cn/thread-236872-1-1.html","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"十天的放逐","slug":"十天的放逐","date":"2017-08-08T02:59:26.000Z","updated":"2017-08-13T10:56:54.601Z","comments":true,"path":"2017/08/08/十天的放逐/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/08/十天的放逐/","excerpt":"就是这样如此巧合 2017.8.7 返校 立秋我已经进入了秋天","text":"就是这样如此巧合 2017.8.7 返校 立秋我已经进入了秋天7.27–8.7 整整在家呆了十天上大学以来 这是第三次回家自小到大 跟大部分同龄人相比回家好像对于我来说好像没有特别大的诱惑力 小学一个月回一次家高中几个星期回一次家到现在可能一年回几次家都是如此我不会像其他人那样焦急地去等待 该回家的时候拎起书包回家不该回家回家的时候不去过多的想念这好像就是我回家的一贯原则因此 不止一个人曾称呼我为野孩子哈哈哈。。。 十天的前几天回老家看望爷爷其他时间都在县城里和一部分好友聚了聚骑车在熟悉的县城里逛了逛其他时间也就那样什么也没干 让我感到惭愧的是我没能正真的、深层次的去理解自己的父母与家庭几天之中还是把自己最坏的脾气展示给了最亲的人 对于我来说每回一次家都是对自己精神的一次洗礼让我重新认识自己其中，我的亲人是主要的讲师 ………………………………….暑假还剩不到一个月其中大约有五天计划和朋友去趟天津剩下大约二十天对我来说是一个黄金时间也应该是我暑假浓墨重彩的一笔简单立个Flag: 每天至少上传一个自己感觉有价值的逆向题目WP。最后至少需要有二十个题解。 抽时间学习一下Py,能写出简单的脚本。 多看别人的博客，学习新东西。 追随逐梦者的脚步","categories":[],"tags":[{"name":"杂儿","slug":"杂儿","permalink":"http://leo.dropsec.xyz/tags/杂儿/"}]},{"title":"暑假一练 WriteUp","slug":"暑假一练-WriteUp","date":"2017-07-20T07:36:24.000Z","updated":"2017-08-11T10:25:53.549Z","comments":true,"path":"2017/07/20/暑假一练-WriteUp/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/20/暑假一练-WriteUp/","excerpt":"也算是第一次正式的接触这种题目吧，在聪大佬的指引下大概领悟了点，咱也写一些WriteUp…","text":"也算是第一次正式的接触这种题目吧，在聪大佬的指引下大概领悟了点，咱也写一些WriteUp… 第一题 Hellow 分值:50首先运行一下程序，看看是什么样子： 可知本题应该是输入用户名、注册码之类。然后将程序加载进IDA，shift+F12查询程序中的关键字符串 在前几行会看到有我们需要找到字符串，选择程序开始的提示“Please input your name”双击进入。 这个界面是数据段，选中对应语句，按ctrl+x出现一个弹框，选择对应语句并OK 按F5尝试得到伪代码发现不行 按空格键结合流程图大致看看程序的思路，再回到主界面根据白色提示信息，往下浏览代码，发现在输入name之后有聚集的cmp比较语句，在输入password后也有聚集的cmp比较语句 再结合验证机制，可以确定这部分语句就是核心所在。然后依次把比较语句中的十六进制数字选中按“R”键转换成对应字符。便可得到用户名与注册码 注意：1.不要漏字符 2.留意字符是否存在顺序 3.看清楚0和O和o最后用户名是：Syclover 注册码是：Hell0_W0rld 第二题 注册码 分值:100依然是先运行程序 可知此题与第一题有些相似，均为求注册码类型的题目。但是考察的内容可能略有不同，毕竟分值大了，也就是说难了，或者说需要略有思考或者计算才能解决。不管那么多，先拖进IDA再说。按照第一题的步骤一步步来，当按下shift+F12后感觉目的字符串不好找的话可以按ctrl+f查找关键字符串。比如此题可以用“name”作为关键字来查找。 找到之后双击进入，选中，ctrl+x进入调用段，F5查看伪代码 仔细分析算法，依次算出V7便是答案。最后注册码为：Ygspiqcb (聪哥之前写的脚本…) 第三题 R_KEY 分值:200 &lt;敬请期待&gt;","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"汇编语言 王爽 章节知识点总结","slug":"汇编语言 王爽 章节知识点总结","date":"2017-07-15T12:04:11.000Z","updated":"2017-08-13T10:56:22.866Z","comments":true,"path":"2017/07/15/汇编语言 王爽 章节知识点总结/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/15/汇编语言 王爽 章节知识点总结/","excerpt":"王爽老师的书差不多看了一半，听很多人说这位老师的书写的很不错，为了看完之后不至于很容易的忘记，故结合前人笔记草草回顾一遍…","text":"王爽老师的书差不多看了一半，听很多人说这位老师的书写的很不错，为了看完之后不至于很容易的忘记，故结合前人笔记草草回顾一遍… 第一章 基础知识1.存储单元为1Byte，即字节。微小信息单位为1bit，其中1Byte=8bit。（一个存储单元可以存储8个bit，即8位二进制数。） 1GB=1024MB 1MB=1024KB 1KB=1024B 1B=8bit2.存储单元从零开始顺序编号。 第二章 寄存器3.8086CPU有14个寄存器，AX(accumulate) BX(base) CX(count) DX(data) SI DI指针寄存器：SP BP IP段寄存器：CS SS DS ES标志寄存器：PSW4.AX可分为AH(高8位）和AL(低8位)，均可以当做独立寄存器使用，互不影响。5.对于实验中溢出的数据，由PSW寄存器保存溢出值。6.8086CPU采用段地址和偏移地址，通过地址加法器来合成物理地址物理地址=段地址x 16 + 偏移地址（段的大小=偏移地址的长度）7.偏移地址16位，其变化范围为0—FFFFH；仅用偏移地址来寻址最多可寻64KB个内存单元。 第三章 寄存器（内存访问）8.字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元，将起始地址为N的字单元简称为N地址字单元。9.8086CPU不支持数据直接入段寄存器10.栈：LIFO（后进先出） 8086CPU入栈（PUSH）和出栈（POP）以字为单位；11.SS：SP 任意时刻始终指向栈顶元素，PUSH AX由下面两步构成：（1）SP=SP-2，SS：SP指向当前栈顶前面的单元，以当前栈顶前面的单元作为新的栈顶；（2）将AX中的内容送入SS：SP指向的内存单元处，SS：SP此时指向新栈顶. （栈顶指针指向的元素最终都是有效的）12.8086CPU入栈时，栈顶从高地址向低地址方向移动，栈为空的时候，SS：SP指向最底部的字单元的偏移地址+2。13.出栈后，SS：SP指向新的栈顶，但之间栈顶的元素还在，只是不在栈中，在之后PUSH移动至此后，此数据将会被覆盖。 第4章 第一个程序14.一个汇编程序由多个段组成，这些段分别用来存放代码，数据，后者当做栈空间，一个有意义的汇编程序中至少有一个段，这个段用来存放代码。 第5章 【bx】和loop指令15.① 【 】表示偏移地址，也表示一个内存单元 ②（ ）表示“一个寄存器或一个内存单元中的内容” ③ Idata表示常量16.Loop指令的格式：loop 标号①（CX）＝（CX）- 1；②（CX）≠0，则转至标号处循环执行（CX）＝0，则继续向下执行 第7章 更灵活的定位内存地址的方法17.在汇编程序中，数据不能以字母开头(+0)18.伪指令：dw 定义字型数据；db 定义字节型数据；dd 定义双字型数据19.Si和Di不能够分成两个8位寄存器，功能和BX相近。20.大小写的转化方法：and al，11011111 b（大写）or al，00100000 b (小写) 第8章 数据处理的两个基本问题21.Reg（寄存器）：AX，BX，CX，DX（及其8位高低寄存器），SP，BP，Si, DiSreg（段寄存器）：DS，SS，CS，ES8086CPU只有BX，Si，Di, BP可以用【】来进行内存单元寻址，可以单独出现，或BXBX BPBP SiDi SiDi 组合出现22.在【】中使用BP，如果指令没有显性给出段地址，默认在SS中23.指令在执行前，所要处理的数据可以在3个地方：CPU内部，内存，端口24.div指令（除法指令）8位除数 16位除数16位被除数 32位被除数{ AX （低16位）DX（高16位）}AL（商）AH（余数） AX（商）DX（余数）25.伪指令dupdb/dw/dd 重复次数 dup（重复的字节/字型/双字型）dw 0, 0, 0, 0, 0, 0 ,0, 0 = dw 8 dup（0） 第9章 转移指令的原理26.转移指令：可以修改IP，或同时修改CS和IP的指令。8086CPU的转移行为：段间转移（修改CS：IP）段内转移（只修改IP）短转移：IP修改范围-128—127 近转移：IP修改范围 -32768—3276727.offset 取得标号处的偏移地址nop 空指令（占位置/用于程序对齐/设标号/延时）28.jmp指令 依据位移转移的jmp指令（CPU在执行jmp指令的时候不要需要转移的目的地址）jmp short 标号 段内短转移 功能：IP=IP+8位位移（标号处地址-jmp指令后第一个字节地址）jmp near ptr 标号 段内近转移 功能：IP=IP+16位位移 转移的目的地址在指令中的jmp指令jmp far ptr 标号 段间转移 功能：CS=标号所在段的段地址，IP=标号在段中的偏移地址 转移地址在寄存器中的jmp指令jmp 16位reg 功能：IP=（16位reg） 转移地址在内存中的jmp指令Jmp word ptr 内存单元地址（段内转移）功能：转移的偏移地址是内存单元中的内容Jmp dword ptr 内存单元地址（段间转移）功能：内存单元中的高地址处为转移的段 地址，低地址处是转移的目的偏移地址29.jcxz指令jcxz 标号 功能：相当于if(（cx）==0）jmp short 标号30.loop指令loop 标号 功能：相当于（cx）– ； if（（cx）!=0）jmp short 标号 第10章 CAll和RET指令31.call指令（和jmp指令进行比较） 依据位移转移的call指令（CPU在执行call指令的时候不要需要转移的目的地址）call 标号 相当于push IP /jmp near ptr 标号； 转移的目的地址在指令中的call指令call far ptr 标号 相当于push CS / push IP / jmp far ptr 标号 转移目的地址在寄存器中的call指令call 16位reg 相当于push IP / jmp 16位reg； 转移地址在内存中的call指令call word ptr 内存单元地址 相当于push IP / jmp word ptr 内存单元地址；call dword ptr 内存单元地址 相当于push CS / push IP /jmp dword ptr 标号32.ret和retf指令ret指令用栈中的数据，修改IP的内容，从而实现近转移，相当于pop IP；retf指令用栈中的数据，修改CS和IP中的内容，从而实现远转移；相当于pop IP/pop CS33.mul指令格式：mul reg 或者mul 内存单元；结果：8位乘法，结果放在AX中，16位乘法，则高位放在DX中，低位放在AX中 第11章 标志寄存器34.8086CPU的flag寄存器的结构35.adc指令（带进位的加法指令）格式：adc 操作对象1 操作对象2功能：操作对象1=操作对象1 + 操作对象2 + CF36.sbb指令（带借位的减法指令）格式：sbb 操作对象1 操作对象2功能：操作对象1=操作对象1 - 操作对象2 - CF37.cmp指令 （比较指令，不保存结果，影响相关标志位的值）格式：cmp 操作对象1 操作对象2功能： 操作对象1 - 操作对象238.检验比较结果的条件转移指令 （e:equal ；a:above ；b:below；）39.rep movsb相当于： s:movsb loop s rep的作用是根据CX的值，重复执行后面的穿传送指令。由于每执行一次movsb指令si和di都会递增或递减指向后一个单元或前一个单元，则rep movsb就可以循环实现(CX)个字符的传送。执行movsb相当于进行以下几步操作： ((es)16+(di))=((ds)16+(si)) 如果df=0 则si=si+1 di=di+1如果df=1 则si=si-1 di=di-1 40.cld 将标志寄存器的DF置0，正向std 将标志寄存器的DF置1，逆向pushf 将标志寄存器入栈popf 将标志寄存器出栈 第12章 内中断41.内中断就是CPU不再处理执行中的指令，而是转去处理这个特殊的信息 内中断的产生包括以下几个：除法错误（div指令产生的除法溢出） 中断类型码：0单步执行 中断类型码：1执行into指令 中断类型码：4执行int指令 中断类型码：n （int n） 42.关于中断过程CPU收到中断信息—生成中断类型码—查找中断向量表—找到中断处理程序入口（设置段地址和偏移地址）对于8086CPU，中断向量表存在于内存0000:0000—0000:03FF的1024个单元中，由于其中有一些空白的地方，所以我们一般将自己编写的中断程序放在0000:0020—0000:02FF的256个字节空间里。PC机的中断例程是由CPU硬件完成，在接受到中断信息后，会执行一下操作：① 产生中断类型码② 标志寄存器的值入栈（pushf）③ 设置标志寄存器中的IF和TF的值为0（原因在书P250和P273）④ CS内容入栈 （push CS）⑤ IP内容入栈 （push IP）⑥ IP=中断类型码4 （N4）⑦ CS=中断类型码4+2 （N4+2）43.编写中断处理程序的步骤① 保存用到的寄存器② 处理中断③ 恢复用到的寄存器④ 用iret指令返回44.Iret指令的功能用汇编语言描述为： POP IPPOP CSpopf 第13章 int指令45.int指令引发的中断（int n）过程：1.取得中断类型码n2.标志寄存器入栈，IF，TF设置为03.CS，IP入栈4.（IP）=（n 4），（CS）=（n 4 + 2） 46.BIOS中主要包含的内容 硬件系统的检测和初始化程序外部中断和内部中断的中断例程用于对硬件设备进行的I/O操作的中断例程其他和硬件系统相关的中断例程 第14章 端口47.shl（左移）和shr（右移）指令将一个寄存器或内存单元中的数据向左（向右）移位将最后移出的一位写入CF中最低位（最高位）用0补充 第15章 外中断48.外中断：对外部设备进行控制外放的输入—相关接口芯片的端口—CPU内存…………………………………………………….. 指令系统总结 8086CPU 提供以下几大类指令：1、数据传送指令比如：mov、push、pop、pushf、popf、xchg等都是数据传送指令，这些指令实现寄存器和内存、寄存器和寄存器之间的单个数据传送。2、算术运算指令比如：add、sub、adc、sbb、inc、dec、cmp、imul、idiv、aaa等都是算术运算指令，这些指令实现寄存器和内存中的数据的算数运算。它们的执行结果影响标志寄存器的：sf、zf、of、cf、pf、af位。3、逻辑指令比如：and、or、not、xor、test、shl、shr、sal、sar、rol、ror、rcl、rcr 等都是逻辑指令。除了not指令外，它们的执行结果都影响标志寄存器的相关标志位。4、转移指令可以修改IP ，或同时修改CS 和IP 的指令统称为转移指令。转移指令分为以下几类：（1）无条件转移指令，比如：jmp；（2）条件转移指令，比如：jcxz、je、jb、ja、jnb、jna等；（3）循环指令，比如：loop；（4）过程，比如：call、ret、retf；（5）中断，比如int、iret。5、处理机控制指令这些指令对标志寄存器或其他处理机状态进行设置，比如：cld、std、cli、sti、nop、clc、cmc、stc、hlt、wait、esc、lock等都是处理机控制指令。6、串处理指令这些指令对内存中的批量数据进行处理比如：movsb、movsw、cmps、scas、lods、stos等。若要使用这些指令方便地进行批量数据的处理，则需要和rep、repe、repne等前缀指令配合使用。 end","categories":[],"tags":[{"name":"Assembly","slug":"Assembly","permalink":"http://leo.dropsec.xyz/tags/Assembly/"}]},{"title":"所谓的废纸篓","slug":"所谓的废纸篓","date":"2017-07-14T02:11:36.000Z","updated":"2017-07-14T03:07:05.269Z","comments":true,"path":"2017/07/14/所谓的废纸篓/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/14/所谓的废纸篓/","excerpt":"我喜欢随手记录一些杂而不乱的东西…","text":"我喜欢随手记录一些杂而不乱的东西…MarkDown使用小技巧[http://www.jianshu.com/p/9d94660a96f1]MarkDown使用小技巧[http://www.cnblogs.com/rossoneri/p/4446440.html]看一看ta博客[http://www.cnseay.com/]","categories":[],"tags":[{"name":"废纸篓","slug":"废纸篓","permalink":"http://leo.dropsec.xyz/tags/废纸篓/"}]},{"title":"Summer  第一周","slug":"Summer-第一周","date":"2017-07-11T09:07:40.000Z","updated":"2017-07-11T13:37:23.955Z","comments":true,"path":"2017/07/11/Summer-第一周/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/11/Summer-第一周/","excerpt":"留校第一周的学习周报","text":"留校第一周的学习周报 本周做了哪些学习记录？请分享你做的笔记、博客7.1–7.71.刘爽老师的《汇编语言》看到了第五章。了解了汇编语言的一些基础知识，比如汇编语言的产生、存储器、总线、主板等基本概念。以及寄存器是什么，有哪几种寄存器，不同寄存器的特定作用，怎么读写寄存器，和一些修改寄存器的指令，包括：mov、add、sub、jmp以及栈操作的指令push、pop。还有就是“段”在内存中的概念。 2.搭建了一个自己的博客。用了大约2天的时间，终于搭建好了自己的博客空间，以后自己学到的感觉有趣的知识以及自己的心得感悟都会实时更新到上面，一来是记录，二来是分享。附博客链接[http://leo.dropsec.xyz/] 3.这几天还做了一个事情就是帮助了一位小学妹报志愿。又经历了一次报志愿，其中选择学校时的犹豫、面对高录取分的无奈、未来握在自己手中时的不安。。。有一次经历、又一次感悟。骚年，努力学习吧。 下周的学习目标是什么？1.感觉自己现在还没有真正走进汇编，接下来的几天主要任务就是继续研读汇编，同时多熟悉OD、IDA等相关软件的使用，能读懂汇编语言写的程序。 2.接下来的学习肯定少不了学姐学长在方向上的引领和问题方面的解答，感谢学长学姐。最后一起努力。","categories":[],"tags":[{"name":"杂儿","slug":"杂儿","permalink":"http://leo.dropsec.xyz/tags/杂儿/"}]},{"title":"年少无为，卖马为生","slug":"年少无为，卖马为生","date":"2017-07-08T12:48:06.000Z","updated":"2017-08-13T10:56:44.908Z","comments":true,"path":"2017/07/08/年少无为，卖马为生/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/08/年少无为，卖马为生/","excerpt":"前几天在浏览博客的时候无意间看到有人用“年少无为，卖马为生”来介绍自己，顿时心里五味陈杂…","text":"前几天在浏览博客的时候无意间看到有人用“年少无为，卖马为生”来介绍自己，顿时心里五味陈杂…我自认为我也算是一个有故事的人经历的缘故，在别人眼中我是一个沉稳、严肃、不怎么爱说话的大男孩大一这一年，对我来说无疑是一个有纪念意义的一年 那天刚好是我的生日，独自一人踏上了外地求学的旅程，临走之前我这样都自己说： 新的开始总要拿些新的东西去面对，“勇敢做自己，开拓XX滩。”是我送给每位即将远行好友的一句话，现在亦讲给自己。高考前100天曾这样写过：只知道彼时的我不会大喜也不会大悲，只是怀一颗平静、明朗的心接受自己努力学习的结果，继而换上行装、双手插兜、面带笑容走向远方…… 2016.9.7 踏进北门的那一刻，四年的大学生活就这样拉开了帷幕紧接着竞选了军训负责人并顺利的当选班长我的记忆只存在几秒如果说大一有记忆的话那么班长工作基本就是全部 必须承认这一年在学习上我是没怎么用心的没有长时间投入的做一件事情因此，有些时候会有一种滑稽可笑的想法感觉大一一年什么也没学到哈哈，这不是真的（严肃脸）‘非时’说：你至少学会怎么跟陌生人相处虽然她是一个“奇怪”的人 寒假是我大一生活中浓墨重彩的一笔和几个可以说是陌生人的陌生人去广州打工美资企业 Jabil十个白天九个黑夜自我感觉也没真正的吃到苦除夕前一天晚上游荡在广州塔下其间去了一趟深圳在大梅沙触摸到了沙滩和大海然后穿过亚热带到达了温带重新回到了我喜欢的冬天记忆特别清晰下火车后我内心一阵窃喜同时身体也在发抖…总之第一次远程，整体感觉不错喜欢上了那里一景一物给我带来的特有感觉聆听了我娜姐的故事 娜姐，今晚你给我讲你的故事，几年后，我会找到你给你讲我的故事，到时候请认真听。娜姐，勇敢追寻你的幸福吧，你幸福我便会幸福。2017.2.14 现在我的记忆还停留在寒假结束拉着行李箱走进学校谁会料到转眼之间暑假已经来到 这便是我的大一记忆不多却愈发珍贵 大一的暑假我选择了留校跟着实验室的学长学姐学点东西希望接下来的一年里自己可以静下心、低下头掌握一些真本领做一个技术控、IT男 最后简单整理一下这一年来零碎写下的便签 20160907-20161016，四十天。结束了很多，开始的也很多。遗憾的是其间诸多瞬间感受没有来得及记录下来。发现无论走到哪里，新结识的人很多都可以在某方面与之前的身边的人产生一一对应的关系，比如杰含、东浩、科鹏、雯静、娴梦……除此之外，还有便是以往的瞬间场景经常会与现在的瞬间场景出现惊人的一致性，而每到这个时候，总会不自主的颤抖几下。我想说的，还有，明天的我，明天的我们将会变成什么模样。对了，明天星期一。 既然睡的比较晚，那就晚点睡吧。真的不知道自己一天都干了些什么。微笑不出来。加强时间分配利用能力。睡喽，明天继续微笑。 浮现。管家。佛性童心。纯粹。朴。羽烬。自我与本我。光影低雕灯。冷暖。life&amp;light。书独慰藉。果然(燃)美。缬美。目送。chris。红格调。 我知道每天早起后我会忘记从床上拿下来眼镜、我知道我的眼镜会坏的、我知道 《周鸿祎自述》他们选择和拒绝一款产品，往往来源于人性很小的点。 ——周鸿祎 渐发现，熬夜其实很困，只是心中一直有所期待，有所牵挂的东西，它迟迟让你感觉下一秒可能就会有所惊喜，也许是你孤独惯了，幸福的人是从来不晚睡的。——季箐 每个人年轻的时候，都想离开自己的父母，离的越远越好，不知不觉真就走出很远，与他们相隔千山万水，有一天猛一回头你会发现，无论走多远，总有一根线连着你和他们，那时候父母已经变老，腿脚不再利索，于是你又折回头重回他们身边，和以前不一样的是，你变成了大人，他们变成了孩子。 ​​​​ Notebook that makes your wish come true with fairy magic. 最容易实现的目标是最成功的目标。 想听音乐，闭上眼睛，轻轻地把音响放到左耳边，感觉音量小了点，于是我把音量增加了一点点。再次闭上眼睛，感觉音量又大了一点。我尝试把音量再减一点，结果是感觉音量又小了点。 有些时候，我会循环这样的无聊的动作，然而大部分的时候我是无奈的。 真的想把白天的时间利用起来，晚上该睡就睡。以后每天我要尽量不在宿舍待。除了晚上睡觉回宿舍，其他时间尽量去实验室学点技术。 走过小径，枝叶还能摇摆、；走过楼道，电灯还能变亮；走进窄门，管缝还能喷水；站在那里，影子还能出现。原来，你依然是你，再怎么堕落你依然是你。请善待自己。 现在你拥有的很多东西，甚至是你不想要的，正是其他人想尽各种办法想得到的。这些东西随时都可能丢失，你要学会珍惜你所拥有的。 这个世界上哪里有什么岁月静好，只不过有人替你负重前行。 四年很长，它可以像青春那样长；四年也很短，它也可以像南北苑的距离一样短。 很奇怪，听着一个陌生人的歌，一遍又一遍的循环。我不喜欢晚睡，但我总是不自觉的想晚睡。 大家晚安","categories":[],"tags":[{"name":"杂儿","slug":"杂儿","permalink":"http://leo.dropsec.xyz/tags/杂儿/"}]},{"title":"搭建博客后的资源整合","slug":"搭建博客后的资源整合","date":"2017-07-08T05:14:29.000Z","updated":"2017-08-16T07:46:27.694Z","comments":true,"path":"2017/07/08/搭建博客后的资源整合/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/08/搭建博客后的资源整合/","excerpt":"对于我这样的小白，从开始搭建博客到搭建好，到配置博客的小功能，，再到基本熟悉用Markdown语法写文章并熟悉上传文章的命令，差不多用了三四天的时间。下面就简单整合一下此过程中接触到的一些较为有用的资源。。。","text":"对于我这样的小白，从开始搭建博客到搭建好，到配置博客的小功能，，再到基本熟悉用Markdown语法写文章并熟悉上传文章的命令，差不多用了三四天的时间。下面就简单整合一下此过程中接触到的一些较为有用的资源。。。 如果你想自己动手用GitHub搭建一个属于自己的博客，不妨先去了解一下什么是GitHub,为什么不直接去其他博客平台上注册一个账号，多省事。等你了解完之后，再动手不迟。 首先推荐一个搭建教程[http://www.jianshu.com/p/863f3f2d1733]我就是按他这个教程一步步来的，讲的比较详细。 其中在输入第一条命令时，他讲的不算特别清楚，没有说明是在哪个命令框内输入 这个命令可以去运行命令框中执行。然后继续跟着他的步骤来，后面在设置SSH的时候，需要从Vim编辑器中提取一大串字符，这时候你如果还用Ctrl+C的话会发现复制不下来，这时候你需要使用Vim认可的复制快捷键，这时候你就可以去搜索一下了。其他的都会比较顺利，最后出现博客的基本模型。（其中你可能会遇到一个或两个404错误页面，第一个可能是你在设置GitHub用户名和域名不一样，第二个404需要去仓库中操作一下CNAME，具体怎么搞，这里不再详细解释，可以网上搜索一下，实在搞不清可以邮件联系我。基本模型搭建好以后就该设置它的小功能了。你可能会需要以下工具：功能强大的文本编辑器：Notepad++在线制作网址图标(ico):[http://www.bitbug.net/]小功能设置教程(注意主题的不同）：[http://moxfive.coding.me/yelee/]编辑.md文件的MarkDown下载，win10的下载好之后不能直接用，还需要下载一个软件：awesomium才能使用。同时可以搜一个在线MarkDown编辑器使用。 最后的最后附上主题设计者的博客[http://litten.me/]供大家参考学习。搭建好自己的博客之后，就需要我们坚持写博客喽。 ……………………………………………………………………………………………………………………………..在写博客的过程中，你可能会想怎么写出其他颜色的字体呢？别急，请看下面的链接…CSDN-markdown编辑器语法——字体、字号与颜色 http://blog.csdn.net/testcs_dn/article/details/45719357","categories":[],"tags":[{"name":"工具or软件","slug":"工具or软件","permalink":"http://leo.dropsec.xyz/tags/工具or软件/"}]},{"title":"Markdown 使用语法","slug":"Markdown 使用语法","date":"2017-07-06T12:32:32.000Z","updated":"2017-08-16T07:21:14.094Z","comments":true,"path":"2017/07/06/Markdown 使用语法/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/06/Markdown 使用语法/","excerpt":"Markdown是一个轻量、简单、通用的文档快速排版的标记语言 Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。","text":"Markdown是一个轻量、简单、通用的文档快速排版的标记语言 Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。 欢迎使用Markdown编辑器写博客本Markdown编辑器使用StackEdit修改而来，用它写博客，将会带来全新的体验哦： Markdown和扩展Markdown简洁的语法 代码块高亮 图片链接和图片上传 LaTex数学公式 UML序列图和流程图 离线写博客 导入导出Markdown文件 丰富的快捷键 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z 重做 Ctrl + Y Markdown及扩展 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— [ 维基百科 ] 使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接等，详细语法参考帮助？。 本编辑器支持 Markdown Extra , 扩展了很多好用的功能。具体请参考Github. 表格Markdown Extra 表格语法： 项目 价格 Computer $1600 Phone $12 Pipe $1 可以使用冒号来定义对齐方式： 项目 价格 数量 Computer 1600 元 5 Phone 12 元 12 Pipe 1 元 234 定义列表Markdown Extra 定义列表语法：项目１项目２: 定义 A: 定义 B 项目３: 定义 C : 定义 D &gt; 定义D内容 代码块代码块语法遵循标准markdown代码，例如：12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' 脚注生成一个脚注[^footnote]. [^footnote]: 这里是 脚注 的 内容. 目录用 [TOC]来生成目录： [TOC] 数学公式使用MathJax渲染LaTex 数学公式，详见math.stackexchange.com. 行内公式，数学公式为：$\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。 块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 更多LaTex语法请参考 这儿. UML 图:可以渲染序列图： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 或者流程图： 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 关于 序列图 语法，参考 这儿, 关于 流程图 语法，参考 这儿. 离线写博客即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入write.blog.csdn.net/mdeditor即可。Markdown编辑器使用浏览器离线存储将内容保存在本地。 用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。 博客发表后，本地缓存将被删除。 用户可以选择 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。 注意：虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，请务必及时发表或者保存到服务器草稿箱。 浏览器兼容 目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。 IE９以下不支持 IE９，１０，１１存在以下问题 不支持离线功能 IE9不支持文件导入导出 IE10不支持拖拽文件导入","categories":[],"tags":[{"name":"工具or软件","slug":"工具or软件","permalink":"http://leo.dropsec.xyz/tags/工具or软件/"}]},{"title":"Hello Word","slug":"Hello-Word","date":"2017-07-04T13:53:56.000Z","updated":"2017-07-12T05:34:00.537Z","comments":true,"path":"2017/07/04/Hello-Word/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/04/Hello-Word/","excerpt":"在实验室鹏哥和某些学长的推荐和帮助下，这个博客终于搭建起来了。","text":"在实验室鹏哥和某些学长的推荐和帮助下，这个博客终于搭建起来了。折腾了两天多，在github page上看到自己的博客加载下来时，突然有种错综复杂的恍惚感。是的，它不是qq空间，不是新浪博客，不是豆瓣小站，也不是贴吧。它更像是属于自己的一块小小的领地，因而我满足于这种归属感。我愿在上面安静劳作。 一个农民，通过自身努力终于分到了一块地，不再需要在地主的土地上创造流量价值时，于是翻身作主的他可以宣告说：Hello World。当然这个农民确切来说是个小小的码农。 感谢在搭建过程中给予我帮助的友人们。","categories":[],"tags":[{"name":"杂儿","slug":"杂儿","permalink":"http://leo.dropsec.xyz/tags/杂儿/"}]}]}