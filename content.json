{"meta":{"title":"Leo","subtitle":"勇敢做自己","description":null,"author":"Leo","url":"http://leo.dropsec.xyz"},"pages":[{"title":"It's just a photo album","date":"2017-08-19T10:14:00.000Z","updated":"2017-09-01T07:54:39.633Z","comments":true,"path":"album/index.html","permalink":"http://leo.dropsec.xyz/album/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-07-07T10:13:07.000Z","updated":"2017-09-19T10:40:58.252Z","comments":true,"path":"tags/index.html","permalink":"http://leo.dropsec.xyz/tags/index.html","excerpt":"","text":"所有标签：| 最大的幸福,莫过于我看你的时候,你也在看着我 杂儿 废纸篓 C++ Java Python Assembly ACM CTF 二进制逆向 工具or软件| 嘿,此时你正看着我,而Leo也静静看着你呢..."}],"posts":[{"title":"第五周分享会题目 wp","slug":"第五周分享会题目-wp","date":"2017-10-14T05:07:15.000Z","updated":"2017-10-15T02:34:43.515Z","comments":true,"path":"2017/10/14/第五周分享会题目-wp/","link":"","permalink":"http://leo.dropsec.xyz/2017/10/14/第五周分享会题目-wp/","excerpt":"这三道题目是本周三分享会上给的，假期缘故，就把这三道题目归为第五周分享会题目吧。","text":"这三道题目是本周三分享会上给的，假期缘故，就把这三道题目归为第五周分享会题目吧。 一.CM_3这个题是寻找flag,输入正确的注册码会得到flag.两种思路：1.根据算法找到正确注册码，进而得到flag2.爆破，直接去找flag. 先加载到IDA看看算法，发现比较复杂，正面求解注册码会比较费事。这个时候就寻思用简单的方法了。加载到OD，去爆破跟flag先找到字符在上边适当语句上下断点重新加载，F9,F8单步到输入注册码，随便输一个单步到跳转处修改标志位为1 使其跳转然后接着进入call然后运行到字符提示出就会看到flag然后继续单步OK了 然后在IDA算法里会发现，在判断注册码后有一个生成flag的函数然后进去瞅瞅 int sub_45BFF0() { int v0; // edx@4 int v1; // ST04_4@4 int v2; // ecx@4 char v4; // [sp+Ch] [bp-134h]@1 int v5; // [sp+10h] [bp-130h]@4 int i; // [sp+DCh] [bp-64h]@1 char v7; // [sp+EBh] [bp-55h]@3 int v8; // [sp+F4h] [bp-4Ch]@1 int v9; // [sp+F8h] [bp-48h]@1 int v10; // [sp+FCh] [bp-44h]@1 int v11; // [sp+100h] [bp-40h]@1 int v12; // [sp+104h] [bp-3Ch]@1 int v13; // [sp+108h] [bp-38h]@1 int v14; // [sp+10Ch] [bp-34h]@1 int v15; // [sp+110h] [bp-30h]@1 int v16; // [sp+11Ch] [bp-24h]@1 int v17; // [sp+120h] [bp-20h]@1 int v18; // [sp+124h] [bp-1Ch]@1 int v19; // [sp+128h] [bp-18h]@1 int v20; // [sp+12Ch] [bp-14h]@1 int v21; // [sp+130h] [bp-10h]@1 int v22; // [sp+134h] [bp-Ch]@1 int v23; // [sp+138h] [bp-8h]@1 int savedregs; // [sp+140h] [bp+0h]@4 memset(&amp;v4, 0xCCu, 0x134u); v16 = 7; v17 = 3; v18 = 1; v19 = 8; v20 = 7; v21 = 2; v22 = 3; v23 = 2; v8 = 18; v9 = 19; v10 = 20; v11 = 1; v12 = 15; v13 = 20; v14 = 16; v15 = 11; for ( i = 0; i &lt; 8; ++i ) { v7 = byte_52E000[*(&amp;v16 + i)]; byte_52E000[*(&amp;v16 + i)] = byte_52E000[*(&amp;v8 + i)]; byte_52E000[*(&amp;v8 + i)] = v7; } v5 = 21; byte_52E000[21] = 0; sub_458430(&quot;SYC{%s}\\n&quot;); v1 = v0; sub_457841(&amp;savedregs, &amp;dword_45C134); return sub_456685(v2, v1); } 这就是了然后点进去看看基地址byte_52E000是什么分析算法就可以写出注册机了 a = &quot;01!l...uo__p5_UOsfseD&quot; b = [7,3,1,8,7,2,3,2] c = [18,19,20,1,15,20,16,11] a = list(a) t = &quot;&quot; for i in range(8): t = a[b[i]] a[b[i]] = a[c[i]] a[c[i]] = t str = &quot;&quot;.join(a) print(a) print(str) 运行结果： [&apos;0&apos;, &apos;o&apos;, &apos;p&apos;, &apos;s&apos;, &apos;.&apos;, &apos;.&apos;, &apos;.&apos;, &apos;O&apos;, &apos;D&apos;, &apos;_&apos;, &apos;_&apos;, &apos;1&apos;, &apos;5&apos;, &apos;_&apos;, &apos;U&apos;, &apos;s&apos;, &apos;e&apos;, &apos;f&apos;, &apos;u&apos;, &apos;l&apos;, &apos;!&apos;] 0ops...OD__15_Useful! 二.cm1这好像是一个linux小程序，不能运行（也可以说目前的我不知道怎么运行linux程序）。然后直接IDA打开，按照老套路来看看能不能找到关键算法，然后就找到了 int __cdecl main(int argc, const char **argv, const char **envp) { int result; // eax@2 char s; // [sp+10h] [bp-30h]@1 int v5; // [sp+38h] [bp-8h]@3 int v6; // [sp+3Ch] [bp-4h]@1 printf(&quot;Let me cheack your flag:&quot;, argv, argv); gets(&amp;s); //输入flag v6 = strlen(&amp;s); //v6为flag长度 if ( (unsigned int)cheack_func(&amp;s) ) //进入check_func发现v6==22进入if语句 { v5 = decode1((__int64)&amp;s, v6); //核心算法 judge_func(v5); //符合条件则输出成功找到 result = 0; } else { puts(&quot;Try again~&quot;); result = 0; } return result; } 进入check_func看下 __int64 __fastcall decode1(__int64 a1, int a2) { unsigned int v3; // [sp+14h] [bp-8h]@1 int i; // [sp+18h] [bp-4h]@1 v3 = 0; for ( i = 0; i &lt; a2; ++i ) { if ( (i ^ *(_BYTE *)(i + a1)) != compare[(signed __int64)i] ) return 0LL; ++v3; } return v3; } 算法不是太复杂，容易写出注册机。先来看看compare的数据 (注意区分什么时候是倒的，什么时候是正的）然后就是脚本了 c = &quot;E`1z[F1fkbUFiRFnftMUa{&quot; for i in range(len(c)): print(chr(i^ord(c[i])),end=&quot;&quot;) 运行结果：Ea3y_C7ack_Me_Have_Fun","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"第四周分享会题目 wp","slug":"第四周分享会题目-wp","date":"2017-10-13T05:47:50.000Z","updated":"2017-10-13T12:04:53.050Z","comments":true,"path":"2017/10/13/第四周分享会题目-wp/","link":"","permalink":"http://leo.dropsec.xyz/2017/10/13/第四周分享会题目-wp/","excerpt":"这道题目是国庆中秋放假期间布置的一道题目。","text":"这道题目是国庆中秋放假期间布置的一道题目。 查壳运行程序，无壳，是一道name&amp;serial类型的题目，基本上就是考察算法。拖进IDA，shift+F12,找到关键字符串，然后反汇编得到关键算法伪代码 int __cdecl main(int argc, const char **argv, const char **envp) { int v3; // eax@1 int v4; // eax@5 unsigned int v5; // kr04_4@5 signed int i; // eax@6 char v7; // dl@7 int v9; // [sp+4h] [bp-4Ch]@1 int v10; // [sp+8h] [bp-48h]@1 int v11; // [sp+Ch] [bp-44h]@1 int v12; // [sp+10h] [bp-40h]@1 int v13; // [sp+14h] [bp-3Ch]@1 __int16 v14; // [sp+18h] [bp-38h]@1 char v15; // [sp+1Ah] [bp-36h]@1 int v16; // [sp+1Ch] [bp-34h]@1 int v17; // [sp+20h] [bp-30h]@1 __int16 v18; // [sp+24h] [bp-2Ch]@1 char v19; // [sp+2Bh] [bp-25h]@7 char v20; // [sp+2Ch] [bp-24h]@1 int v21; // [sp+2Dh] [bp-23h]@1 int v22; // [sp+31h] [bp-1Fh]@1 __int16 v23; // [sp+35h] [bp-1Bh]@1 char v24; // [sp+37h] [bp-19h]@1 char v25; // [sp+38h] [bp-18h]@1 v21 = 0; v22 = 0; v23 = 0; v24 = 0; v20 = 0; v16 = 0x7544634D; v17 = 1094741100; v18 = 28277; v9 = 1330405193; v10 = 1130317142; v11 = 6243924; v12 = 976562704; v13 = 53689371; v14 = 8994; v15 = 126; v3 = sub_4013C0(std::cout, &amp;unk_40317C); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, std::endl); sub_401610(std::cin, &amp;v25); //&amp;v25=name if ( strlen(&amp;v25) - 5 &lt;= 3 || strcmp(&amp;v25, (const char *)&amp;v16) ) { printf(Format); //name需要&gt;8 并且需要与&amp;v16进行一一比较，相同为正确 exit(0); } v4 = sub_4013C0(std::cout, &quot;请输入管理员密码：&quot;); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v4, std::endl); sub_401610(std::cin, &amp;v16); //&amp;v16为输入密码 v5 = strlen((const char *)&amp;v16); if ( v5 - 5 &gt; 6 ) //密码长度需要&lt;=11 { printf(&quot;对不起，您输入的密码错误！&quot;); exit(0); } for ( i = 0; i &lt; (signed int)v5; *(&amp;v19 + i) = v7 ) //关键算法 { v7 = *((_BYTE *)&amp;v12 + i) ^ *((_BYTE *)&amp;v16 + i); ++i; } if ( !strcmp((const char *)&amp;v9, &amp;v20) ) //最终比较 printf(&quot;登陆成功！KEY{管理员密码} \\n&quot;); else printf(&quot;对不起，您输入的密码错误！&quot;); system(&quot;pause&quot;); return 0; } 把关键算法拉下来分析 for ( i = 0; i &lt; (signed int)v5; *(&amp;v19 + i) = v7 ) { v7 = *((_BYTE *)&amp;v12 + i) ^ *((_BYTE *)&amp;v16 + i); ++i; } if ( !strcmp((const char *)&amp;v9, &amp;v20) ) printf(&quot;登陆成功！KEY{管理员密码} \\n&quot;); else printf(&quot;对不起，您输入的密码错误！&quot;); &amp;v12与&amp;v16相与的结果赋给&amp;v7,然后&amp;v7的值付给&amp;v19,最后是让&amp;v9的值与&amp;v20(&amp;v19)的值进行最终比较。想求出正确的&amp;v16,只需让&amp;v9和&amp;v12相与即可得到 正确的name可由之前的&amp;v16得到 写注册机得到密码之前先把&amp;v9与&amp;v12的值找到 list1=[0x49,0x5f,0x4c,0x4f,0x56,0x45,0x5f,0x43,0x54,0x46,0x5f] list2=[0x10,0x2a,0x35,0x3a,0x1b,0x3c,0x33,0x33,0x22,0x23,0x7e] for i,j in zip(list1,list2): print(chr(i^j),end=&apos;&apos;) 运行结果：YuyuMylpve! 最后总结：1.一个遗留问题，不明白为什么&amp;v19突然就变成了&amp;v20 2.还不是特别会利用OD进行解题目（不能利用它找到有用的信息）之后要多加练习 3.现在看看这个算法题目也不是特别难，不明白当时自己为什么就懂不懂。积累经验吧。","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"转 一个计算机学院学生四年学习生活的回顾与反思","slug":"转-一个计算机学院学生四年学习生活的回顾与反思","date":"2017-10-06T03:55:10.000Z","updated":"2017-10-06T04:25:16.886Z","comments":true,"path":"2017/10/06/转-一个计算机学院学生四年学习生活的回顾与反思/","link":"","permalink":"http://leo.dropsec.xyz/2017/10/06/转-一个计算机学院学生四年学习生活的回顾与反思/","excerpt":"翻看读者的评论，有些人在感慨为什么不是大学期间看到这篇文章，而你、我正大学…原文链接：http://bbs.taisha.org/thread-1200140-1-1.html","text":"翻看读者的评论，有些人在感慨为什么不是大学期间看到这篇文章，而你、我正大学…原文链接：http://bbs.taisha.org/thread-1200140-1-1.html 昨天想了整整一宿，最后写下下面这些对于大学学习生活的回顾与反思。觉得作为一个“过来人”很有必要将一些问题说给未来将要毕业的同学，希望能够吸取我的教训，少走些弯路。同时以此为鉴，今后努力的改正、提升自己。（没兴趣听我白话者可直接跳读到第六部分总结） 大学生活马上就要结束了，这里不禁感叹时光飞逝，物是人非…… 记得刚刚踏入大学校门的时候，心中踌躇满志，虽然那时甚至不知道C语言是什么东西，但是仍然对于自己四年后的形象充满了无限的憧憬：雄厚的基础知识，良好的学术能力，很高的技术才华，未来之科学栋梁等等……而如今的状况却是：为了得到一个可以糊口的IT民工职位抓破头皮，郁闷与苦恼中为得到一个工作机会而暗自庆幸，至于什么专心学术，什么科学栋梁，似乎距离自己越来越遥远。 直到此刻，我仍然不认为自己的大学是完全堕落的，我也不认为自己读的书是无用的，我更不赞成自己没有学习计算机科学的资质，那么问题究竟出现在什么地方？我想这里有很多原因，绝大部分是自己的，但绝对不能忽视环境的因素。 1. 基础知识薄弱在我东奔西走找工作的时候，才真正的体会到自己原来喜欢炫耀的基础知识是多么的薄弱，而他们又是那么的重要。我曾经在面试时因为说不清进程间的通信机制而当场被无情的BS，也因为对于自己基础能力不自信而放弃一家很牛逼的公司研发部提供的笔试机会。 先要谈及计院的一大问题。其实在这里真正对于计算机感兴趣，并且肯于专心研究，搞学术的学生真的是凤毛麟角。大环境是普遍是网游成风，**猖獗。 真正的没有几个人肯安下心来读书，即使那几个老老实实听课的 “ 好学生 ” 也只不过是为了一个高高的 GPA ，一个可以在家长同学面前显摆的奖学金证书。而真正希望学东西，做学问的人太少了。在我找工作的过程中，手中握着一摞奖学金证书，后来被证明绝对是废纸，任凭你怎么吹嘘自己的成绩，没有单位会真的拿来仔细的看上一看。 回归正题，什么才是真正的基础扎实？我的理解是不仅要牢牢的掌握大学课本中关于计算机核心课程的理论知识，而且还要适当的进行深入。对于该方向非常重要的思想、名词、技术都要有良好的把握。比如可以随手写出快速排序、哈希查找等经典的常用算法，熟记线程与进程的概念、他们的差别，并且能够解释清楚诸如僵尸进程之类的问题。会 Linux 的不仅仅是就会几条 shell 命令，或者干脆就会装个系统。用 C++ 的不仅仅要会语法（估计这是绝大多数毕业生对于 C++ 的理解程度），起码要了解一些常用的标准库，知道什么是 STL ，了解些基本的 OO 思维方法。学过网络的最起码要用过 socket ，了解数据库的不能仅仅就会写几个 SQL 语句，背两条范式等等。 说到这里不禁有点激动，前几天在一个 IT 论坛上看到一个关于大学读书无用论的帖子。说读书无用的人这些基础知识掌握的恐怕也不怎么样，连基础的东西都没弄明白怎么好意思说自己读过书？没读过书怎么他妈的好意思说读书没用？！其实不是读书无用，是肯安心读书的人太少，而书读的足够的人更少。 倘若没有这些基础，仅仅会用这个工具，那个框架，充其量也不过是个 IT 民工，今后的发展必定受到制约，选择只有三条： 1. 做一辈子 IT 民工 2. 将大学中欠下来的债补上 3. 改行 这里我不想说太多，话归正题。如果要我重新的去选择，我一定在学习每一门课程的同时尽量的找到相关的资料，扩展每一个话题。同时，将一些最常用的思想，技术，方法记录下来，并且苦练到可以熟练应用的地步，并且时常的加以回顾。真正基础雄厚的人就应该是可以将常用的基础性知识熟记成诵的人，提到一个基本的名词或者话题能够将其来龙去脉解释清楚的人。 2. 学风不正，**猖獗这里的学风不正，**成风。我想一方面要怪罪于我们自己，对于前途不负责任，将大好的宝贵时光都用在了网游、泡妞、喝酒等事情上；另一方面计院的领导以及老师就真的没责任了吗？ 如今的老师大都想着自己的小项目能赚多少钱，如今的领导多数考虑自己负责的这一块不要出问题而影响到头上的乌纱帽。“一切为了学生”，表面看起来冠冕堂皇，实则是句屁话。老师根本没时间备课（或者没水平备课），上课照本宣科的念幻灯片，考试之前为了保证及格率不忘帮大家“画画范围”。记得大学一年级的计算机导论课，一个老头足足的念了一个学期的幻灯，内容就是C语言，数字逻辑，离散数学课程的前1/3……内容巨枯燥，而且朗读水平超级差劲。也难怪很多人从一开始就认为进入计院如同进入火坑。大学四年学下来不知道计算机专业的学完了究竟能做什么。到了毕业时刻，领导开始担心就业率了，早就内外成患、以涣散堕落为风的计算机学院有岂能在短时间里奋发起来？这个时候开始埋怨大家这个不是，那个不对，仿佛一切问题都是学生的，我想问问你们早干什么来的？之前的那么多时间不好好的调教你的学生，为什么这个时候才想起来教育？在这样的学习环境下，除了主动的自学，多多的上网搜集信息、泡图书馆，还能有什么选择呢？但说回来，我没完全的做到。最终问题还出在自己，不够坚定，有时会随着大环境一起堕落，一起enjoy美好的大学生活…… 3. 实践薄弱，人才位置错放看着自己简历中可怜的实践经验，面对人才市场上实践经验黄金般的价格，自己不禁暗自悔恨…… 很多人都在用理论扎实来搪塞自己实践方面的低能，我想这个借口根本站不住脚。首先，计算机这个学科的性质就决定了没有实践，理论几乎没法理解的扎实透彻。就好比熟记骑自行车手册的人可能根本不会骑车一样。 我们不排除有未来的图灵、 Knuth 一类的大牛，只要即使不写什么重要的代码，理论也是巨牛无比。但是大多数学过数据结构与算法的人来说，能用 C 写个 Dijkstra 最短路算法就算不错了，你要给他个什么城市公交线路选择问题，他保准晕菜，当场崩溃（这样例子我见多了）。 其实我们的同学中真的有些非常的出色，只不过是放错了位置。（尤其是女生，我觉得大多数都不适合去编程）倘若不是在计院，可能他们已经凭借着自己出色的能力在该方向上开始崭露头角了。我不只听到一个人抱怨自己不适合编程，一些人是纯粹的为自己**找借口。这些人往往自己都不知道计算机究竟在学什么，估计换个环境也还是一个逼样。有些人我感觉绝对是高考造成的资源严重错放，他们在感性理解方面确实非常的出色，自己也非常的上进，换专业绝对是非常好的选择。但是大一大二的时候，我们的老师，我们的领导又他妈在干啥呢？一些必要的引导总是你们的职责吧，干麻叫这些同学走过了大学四年才意识到自己不适合学计算机？ 总之，种种因素，大多数同学四年没编过几行代码，课设不过草草了事（据说某些老师甚至推荐同学去校外找人代做毕设），所以毕业时，之前做过的东西根本不敢往简历里写，因为根本没有啥技术含量，都他妈copy的。 4. 项目反思在我向面试官夸夸其谈自己的所谓有技术含量的项目经验时，不住的冒虚汗，甚至还被一个考官当场揭穿并遭到无情的BS。现在想想，更加悔恨不已…… 我也曾经意识到实践的问题。自己也曾经雄心勃勃的要写有技术含量的代码。我大学里自己写过两个自认为是比较有技术含量的项目。不过两个项目最终皆因打不完的补丁，层出不穷的新bug，臃肿而杂乱的代码，以及自己对于继续开发与维护失去信心与兴趣等原因而最终搁浅失败。 究其原因，我总结如下：首先是自己太浮躁。我觉得这个问题在当今的毕业生人群中以及IT行业里是普遍存在的。刚刚会编程就开始yy自己能写出多牛逼的程序，做多牛逼的软件。事实证明，任何牛逼的软件都不是一下子就那么牛逼的，必须要循序渐进的展开。当时，刚刚背熟了C++的语法，就萌生了要写一个牛逼系统证明自己的想法。其实这个想法本没有错，错就错在我没有进行必要的积累，而且缺乏对于系统模块逐步开发并测试的耐心。在网上下了点别人的设计经验，自己就开始照猫画虎的写代码。其结果可想而知，调试了n久代码才能勉强的运行，而且及其不稳定。整个项目乱成一团，打一个补丁又出两个bug那种。 这个时候其实应该吸取经验，对于代码进行重写，系统进行改进，甚至有必要重新设计。而我又开始浮躁了，觉得这个算不了什么，吸取教训，再写个更有技术含量的牛逼程序一定成功。于是竟然无厘头的放弃了那一堆研究了将近一个月的代码，开始了新的项目设计。这个项目的结果更加的可笑，我最终甚至都没有完整的运行整个程序，无论我怎么调试，程序到一半的时候都会莫名其妙的崩溃，而杂乱的设计与垃圾代码使得我想赶紧将这些破玩意放入回收站。这时我一方面感觉自己也没啥能力写软件，估计再写也就是九流货色，没啥发展；另一方面开始责怪学校，为什么没有一丁点编程的氛围，这样也不至于我孤军奋战。我还傻了吧唧的郁闷了好一阵子，之后做了一个我虽然不后悔，但是却觉的是很愚蠢的决定—加入考G大军，并全职学习一年的英语。 其实现在想想那时真是愚蠢的很，明知道做软件一次成功是不可能的，还偏偏犯这种错误。为什么呢？答案就是当时太急功近利了，以为自己多牛逼，写个程序不费事。但实际遇到困难的时候，有没有耐心与毅力去解决，甚至感觉之前的工作是在浪费时间。虽然现在想想可笑，但是此刻很多人（可能我也在内）还在犯着同样的错误。 总之急功近利很容易导致莫名的失败感，并且会为自己的失败（其实这个不能叫失败）找各种借口，然后在借口的安慰下完全的放纵自己。这一点也体现在了我考G的过程中。 5. 借口==障碍当时的挫败感使得我对于计算机学院这个机构完全的失去了信息，眼看就是最最关键的大三了，这将决定我的出路，我该如何是好？ 这个时候我是这样想的，如果考研的话，恐怕会从一个火坑跳到另外一个。从而可能会与许多和我一样迷茫的同学一样继续两年打酱油的生活。因为种种yy以及对于自己不准确的定位，导致我想到了考GT出国。于是花了1000多块钱报了个新东方，成天夹着厚厚的红宝石去图书馆……现在来看，我不后悔当初的决定，因为我确实在这个过程中学到了好多，也认识了很多朋友。而且我觉得，如果当时是因为害怕而没有去尝试的话，自己会在悔恨中渡过前半生。但是我觉得当时的考G绝对是泡沫，它让我产生了种种幻觉，以为自己因为考G水平就高了不少。这个泡沫膨胀了半年多，最后以一个失败的分数为标志迅速的破灭。（就好像金融危机一样） 其实，如果这个时候，我意识到前面问题的严重性，最差也应该把握住考G这个机会。然而，我又一次没有做到。回顾整个考G的过程，我在不断的为自己找借口。我埋怨背单词太苦，于是经常为自己开小差（游**，看看杂书、电影等）。我做题受到打击时，埋怨周围没有人跟我一起准备。我还以考G为借口，糊弄自己的专业课，糊弄自己的课设，糊弄自己的前程！我还经常的受到打击，而每当被天书般的GRE习题打击之后，总是自己傻了吧唧的郁闷，而没有用心的去总结，去努力的提升自己。我因此浪费了不少时间。虽然，在此期间我从没有放纵过自己，每天都尽可能的坚持呆着图书馆或自习室里，但是对于本身英语基础就很薄弱的我来说，面对这样大的挑战，如此糟糕的状态又怎么能成功呢？ 最后的结果可想而知，我用了一年的时间专门学习英语，虽然英文水平有了一些进步，但是与巨额的开销，以及自己辛苦的付出绝对不成比例。现在我的GRE单词也忘的差不多了，不知道这个曾经的美丽留学梦会不会随着我的科学梦一起从此破灭呢…… 6. 总结上面说了好多，此刻心情很激动，思维好杂乱，现在要平静一下，整理一下。 上大学首要任务：明白自己是来干什么的，走出这里的时候自己要收获什么，自己希望会变成什么样子。每个人都必须要有明确的目标，除非你想过四年打酱油的生活。这一点我做到了，虽然做的不好，走了弯路，但是我没有白白荒废四年的时间。 要有扎实的学科基础，不要将自己局限在得一个高分的狭小范围内，仅仅看到眼前的荣誉无疑是目光短浅的表现。要注意学习的扩展性，要努力的去理解并掌握本专业常用的的核心思想与技术，并达到熟记于胸的程度。 发现自己的优势，选择适合自己的出路。不要仅仅看中程序员的高薪水，做最适合自己的方向才是最最重要的。 学过理论要注重实践，可以自己做一些力所能及的小东西。 有意从事计算机方向的同学需要：熟练掌握一门程序设计语言，一个开发工具，一个系统平台，一种编程思想。自己动手做一些有一定技术含量的项目。 最好是能够利用好假期的时间，出去实习。因为这种经历将是毕业时卖身的有力筹码。 切忌浮躁、急功近利，假如以你的实力可以通过5年的时间成为一个领域的高手，如果自己期望缩短到3年的时间甚至更短，最终很可能要用8年的时间甚至永远都做不到。 对于自己的目标和已经决定的选择，要执著的追求，直到在其中获得了你满意的成果。 做事情不为自己找借口，借口==失败。 最后环境的因素，我们希望它会变得越来越好。但是继续这样也没有关系，只有对自己充满信心，相信自己，坚持自己的理想，无论在多垃圾的环境中都会取得自己满意的成绩。","categories":[],"tags":[{"name":"杂儿","slug":"杂儿","permalink":"http://leo.dropsec.xyz/tags/杂儿/"}]},{"title":"转 为什么中工人没有自豪感？","slug":"转-为什么中工人没有自豪感？","date":"2017-10-05T12:57:40.000Z","updated":"2017-10-05T13:10:02.714Z","comments":true,"path":"2017/10/05/转-为什么中工人没有自豪感？/","link":"","permalink":"http://leo.dropsec.xyz/2017/10/05/转-为什么中工人没有自豪感？/","excerpt":"一位学长所写，转发为敬。原文连接：http://www.znczl.com/forum.php?mod=viewthread&amp;tid=62","text":"一位学长所写，转发为敬。原文连接：http://www.znczl.com/forum.php?mod=viewthread&amp;tid=62 最近很多人在群里问我和逐鹿老猫是不是一个学校的，还有类似问题中国原子弹工业大学和中国原子能工业大学附属研究院有什么区别。我看到了也没有回，中工非名校，我想我的问题也是一众人的问题，一众人的问题也是社会的问题。 今天在知乎偶然看到《二本学校就不是学校了吗？》，很难说翻了过半回答之后是什么心情。 印象里很深刻的是2016年在G318川藏线上，队友问我是哪所学校的，我说是在郑州，队友问是郑州大学么，我没有肯定亦没有否定，就含含糊糊应下来。从那时候我就在问自己，为什么二本学校的人，没有自豪感？ 仍记得刚刚高考之后参加高中同学聚会，石家庄二中南校区，一桌子清华同济，还有那时候走出考场的时候还在满脑子疑问“那几道题是不是出错了”就知道要毁的一个我。高考成绩还没有出，每个人都在碰杯，因为注定各奔东西，我忽然想说一句“敬这一场去他妈的人生”。后来有的人哭到路也走不稳，几个人手拉手在街上唱着无人能懂的歌。 再醒来时很多人已经走了。从前的日色变得慢，车，马，邮件都慢，有的人一别，就是一生。 班级里六十多人，五个没有上一本线。后来再聚的许多次，我都没有去。可能过得并不好的我的敏感自尊在寻求着自保来逃避吧。像我这样迷茫的人，像我这样寻找的人，像我这样碌碌无为的人，你还见过多少人。 我高中最后的同桌在桌子上刻了一个“早”字，并且在每个作业本上写上一句“为中华崛起而读书”，那时候我们都觉得自然极了，然而现在我在大学里说“我想拯救中国制造业”就容易被嘲笑。 我不知道这是不是因为二本学校的关系。但是说实话我在离开高中前从未如此频繁地听到“某某是个傻逼”。 而事实证明很多时候都是对的，因为绝大部分人并不会拯救中国文坛，或者拯救中华民族。 环境对人的影响极大，而我也并不是一个内心足够强大的人。曾经对我的自尊伤害最大的应该是高中时候的邸同学和孙同学。 清北的学生或许也存在他们的问题和自傲，但在去了清北的同学那里，我说出任何自己真实的梦想，他们都会鼓励我并相信我能够做到。我想因为他们也有自己的学术理想并且相信自己有能力做到，有“梦想”就像有生活必需品一样正常。 而我现在说起“梦想”，总会不自觉地感到不自然，仿佛那就是一件奢侈品，我穷尽一生难以拥有。我总能想起，高中的一个同桌对我说“穷尽一生追寻梦想”时，她的眼神。她相信的，我也相信，但是我在我的大学里，再没有看到那种眼神了。 曾经和人谈爱情，三句不离你。如今爱情没有谈，梦想似乎也很少被提起。我似乎明白了，在浮躁的时代，跨进了中工的校门，身上就已经被贴上了比上不足比下有余的标签。有的人听之任之，可我不想这样。 课后和朋友聊起“为什么中工人没有自豪感”，说来说去说不出所以然。校风、学风、后勤、建筑、制度、管理……说起来一无是处，校风学风还不如隔壁的三本。综合分析，我觉得还是基础教育的问题。随手扔掉垃圾，并不认为有什么不正常，人人皆知的“不乱扔垃圾”只停留在了书面。 其实洋洋洒洒一千三百字写过，中工人是否有自豪感真的已经不重要了。高山仰止，景行行止。虽不能至，然心向往之。该堕落该迷惘的人还是会迷惘堕落，该受影响的人还是会去受影响。那些下定决心暗自发愤努力的人，也许一开始就不会很关心类似的问题。 对比自己和上名校的高中同学，区别就在有没有足够的决心毅力恒心和魄力去破除万难达到自己的目标。 有一种人的思维方式总是找那些各式各样不利于自己的借口，周围都是不上进的人，天天打游戏逛街追剧，学校老师上课总是照着书念，学校设施也都是陈旧的设备。你看名校同学的条件设施，一开始就站在了最好的平台上，拥有最广阔的机会。所以我的失败都是由于我的平台出身不好。 而有一种人，他们的思维方式总是能看到自己的不足，该做的工作该努力的事是不是尽力了。哪怕最绝望的环境中他们也能够看到对自己有利的部分，然后利用这些有利的条件去达成自己的目的。哪怕希望只有一丝一毫，成功者只有一个，那也是我。学校虽然差，但肯定没有差到连图书馆都没有，室友不上进，不学习，我自己可以去图书馆、自习室。 名校的学生确实可以甩中工的同学几条街，但被甩几条街的原因，是因为在这里有太多同学人云亦云、自怨自艾。没有努力过的人，连失望的资格都没有。而你现在就是这样的人。 宏观的角度和数据分析跟你个人的命运没有任何关系，一所学校的优秀与成败，不在于设施的好坏，不在于有多少名师教授，不在于有多少重点建设学科项目。而是在于学生的行为和价值观，在于学生以什么的态度和世界观面对未来。梦想还是要有的，万一实现了呢。 在知乎的回答里看到一个很有寓意的回答，最后分享给列位—— 陈总身价亿万，酒桌上谈起他的母校，是三流大学，饭桌上的人纷纷附和：“陈总牛逼！英雄不问出处！”于此同时，在另外一个包厢。身价亿万的张总也谈起他的母校，是常春藤名校，饭桌上的人纷纷附和：“张总牛逼，系出名门！”二本不乏风云人物，待你功成名就，重新给你一次机会，你会选择哪里，其实一本又算什么呢？ 毛不易-像我这样的人(Live)无损品质 下载链接：http://pan.baidu.com/s/1c2AiAvI 密码：5zmd 不过四级我是咸鱼 09.30于中原工学院","categories":[],"tags":[{"name":"杂儿","slug":"杂儿","permalink":"http://leo.dropsec.xyz/tags/杂儿/"}]},{"title":"心结_11：11","slug":"心结-1111","date":"2017-09-26T14:04:15.000Z","updated":"2017-10-17T15:21:12.605Z","comments":true,"path":"2017/09/26/心结-1111/","link":"","permalink":"http://leo.dropsec.xyz/2017/09/26/心结-1111/","excerpt":"沉默是最好的思考方式，也是最好做选择的方式。","text":"沉默是最好的思考方式，也是最好做选择的方式。 最近很是不爽整体来说面对种种我的表现还是比较冷静的 但是有些时候心里还是会有些小小的躁动欣慰的是躁动过后会马上意识到自己的问题进而反思自己 我不是什么神人还是允许自己范小小的错误的其实想想 这也是进步的体现ei 2017.9.26 21：55面对电脑屏幕正有些小小的躁动隐约感觉到手机微小的振动过了一会才懒洋洋的拿起手机瞅了一眼我是知道最近有一天是我的生日的印象中还差几天才是紧接着我打开日历然后静静的放下了手机想了想 又拿起手机回了个消息 亲爱的儿子，生日快乐，永远开心，不好意思，现在才想起 2017/9/26 21：55 不好意思、现在才想起的想起却又是那样的及时、准时 这便是所谓的：从来不会想起，却从来不会忘记 OK，带上母亲默默的关心，继续前行。","categories":[],"tags":[{"name":"杂儿","slug":"杂儿","permalink":"http://leo.dropsec.xyz/tags/杂儿/"}]},{"title":"第三周分享会题目 WP","slug":"第三周分享会题目-WP","date":"2017-09-25T12:06:28.000Z","updated":"2017-09-27T13:42:32.418Z","comments":true,"path":"2017/09/25/第三周分享会题目-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/09/25/第三周分享会题目-WP/","excerpt":"第二周分享会题目是暑假布置的三道题，之前称为暑假一练，上周又重新熟悉了一下。这里又来了三道，come on…","text":"第二周分享会题目是暑假布置的三道题，之前称为暑假一练，上周又重新熟悉了一下。这里又来了三道，come on… 一：easy_keygen运行程序，观察发现又是一道用户名and注册码题目。本道题目已经给出了注册码 5B134977135E7D13 求用户名可知这是一道算法题，拉进IDA分析算法以下为反编译出来的关键代码： int __cdecl main(int argc, const char **argv, const char **envp) { signed int v3; // ebp@1 signed int i; // esi@1 int result; // eax@6 char v6; // [sp+Ch] [bp-130h]@1 // char v7; // [sp+Dh] [bp-12Fh]@1 // 注意地址连续 char v8; // [sp+Eh] [bp-12Eh]@1 // char v9; // [sp+10h] [bp-12Ch]@1 char v10; // [sp+11h] [bp-12Bh]@1 __int16 v11; // [sp+71h] [bp-CBh]@1 char v12; // [sp+73h] [bp-C9h]@1 char v13; // [sp+74h] [bp-C8h]@1 char v14; // [sp+75h] [bp-C7h]@1 __int16 v15; // [sp+139h] [bp-3h]@1 char v16; // [sp+13Bh] [bp-1h]@1 v9 = 0; v13 = 0; memset(&amp;v10, 0, 0x60u); v11 = 0; v12 = 0; memset(&amp;v14, 0, 0xC4u); v15 = 0; v16 = 0; v6 = 16; v7 = 32; // 注意地址连续 v8 = 48; sub_4011B9(aInputName); scanf(aS, &amp;v9); //v9为输入name v3 = 0; for ( i = 0; v3 &lt; (signed int)strlen(&amp;v9); ++i ) { if ( i &gt;= 3 ) i = 0; sprintf(&amp;v13, aS02x, &amp;v13, *(&amp;v9 + v3++) ^ *(&amp;v6 + i)); //关键处，算出的注册码存入v13 } memset(&amp;v9, 0, 0x64u); //重置v9 sub_4011B9(aInputSerial); scanf(aS, &amp;v9); //输入注册码重新存入v9 if ( !strcmp(&amp;v9, &amp;v13) ) //比较 { sub_4011B9(aCorrect); result = 0; } else { sub_4011B9(aWrong); result = 0; } return result; } 重要的在于看懂以下代码 for ( i = 0; v3 &lt; (signed int)strlen(&amp;v9); ++i ) { if ( i &gt;= 3 ) i = 0; sprintf(&amp;v13, aS02x, &amp;v13, *(&amp;v9 + v3++) ^ *(&amp;v6 + i)); //关键处，算出的注册码存入v13 } 不要被sprintf的参数影响。用OD动态调试的时候会看到输入的用户名一个一个的变成了十六进制的形式 结合算法，逆推出以下注册机： 一： serial=[] serial11 = &quot;5B134977135E7D13&quot; for i in serial11.decode(&quot;hex&quot;): #十六进制默认两位两位循环 print(i) #辅助 serial.append(ord(i)) name = [] v6 = [16, 32, 48] i = 0 for v3 in range(len(serial)): if (i &gt;= 3): i= 0 name.append(serial[v3] ^ v6[i]) i = i+1 print(name) namestr = &quot;&quot; for j in range(len(name)): namestr += chr(name[j]) print(namestr) （需在Python 2 下才能正确运行） 二： serial = &quot;5B134977135E7D13&quot; b = [0x10, 0x20, 0x30] a = 0 ss = &apos;&apos; for i in range(0, len(serial), 2): print(hex(int(serial[i:i + 2], 16))) #辅助 ss += chr(int(serial[i:i + 2], 16) ^ b[a]) a += 1 if (a &gt;= 3): a = 0 print(ss) 二：baby_tortoise先看一下提示：本题的目的是找到OEP查壳查语言运行程序有壳C/C++语言【经验】 C/C++语言写的程序一般会有连续两个jmp跳转到OEP。方法一：转动鼠标滑轮，寻找连续两个jmp，找到后F4，然后F8，越过灰色山丘成功找到OEP。方法二：加载程序后单步，发现符合ESP定律使用的条件。so,选中ESP后的地址右键选择：HW break [ESP]这是快速设置硬件断点的一个方法然后F9，程序停下之后去快捷菜单删除硬件断点F8几步(结合转动鼠标滑轮观察)就看到连续两个jmp了，然背就没有然后了… 三：S0_ea3y先看一下提示：字符串！字符串！字符串！字符串！还是四遍…无壳，c++语言运行程序看看呗由于提示字符串，直接加载进IDA搜索字符串交叉引用反编译得到关键的伪代码 int __cdecl sub_401080(HWND hDlg) { int result; // eax@5 CHAR String; // [sp+4h] [bp-64h]@1 char v3; // [sp+5h] [bp-63h]@1 //String v3 v4 v5 char v4; // [sp+6h] [bp-62h]@2 //注意地址的连续性 char v5; // [sp+8h] [bp-60h]@3 __int16 v6; // [sp+65h] [bp-3h]@1 char v7; // [sp+67h] [bp-1h]@1 String = 0; memset(&amp;v3, 0, 0x60u); v6 = 0; v7 = 0; GetDlgItemTextA(hDlg, 1000, &amp;String, 100); ** if ( v3 == 97 &amp;&amp; !strncmp(&amp;v4, a5y, 2u) &amp;&amp; !strcmp(&amp;v5, aR3versing) &amp;&amp; String == 69 )** { MessageBoxA(hDlg, Text, Caption, 0x40u); result = EndDialog(hDlg, 0); } else { result = MessageBoxA(hDlg, aIncorrectPassw, Caption, 0x10u); } return result; } 然后根据地址的连续性把比较的字符串连起来得到key：Ea5yR3versing 【注意】 一定不要被变量名误导，要跟进去看它的值；然后就是别忘把对应的ASCII值转成对应的字符","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"跟着崔岩老师学Java","slug":"跟着崔岩老师学Java","date":"2017-09-19T10:39:19.000Z","updated":"2017-10-15T13:59:30.995Z","comments":true,"path":"2017/09/19/跟着崔岩老师学Java/","link":"","permalink":"http://leo.dropsec.xyz/2017/09/19/跟着崔岩老师学Java/","excerpt":"之前在超星算是初步接触过Java，本学期有Java程序设计这门课，我是很高兴的。上过两节课，发现崔岩老师也很给力，更坚定了我学好Java的信心。 这里就用于记录我在崔老师的课堂上的点点收获吧。","text":"之前在超星算是初步接触过Java，本学期有Java程序设计这门课，我是很高兴的。上过两节课，发现崔岩老师也很给力，更坚定了我学好Java的信心。 这里就用于记录我在崔老师的课堂上的点点收获吧。 2017/9/19 Class命名首字母大写（约定），方法命名都要“传情达意”； Ctrl+Shift+f 自动缩进快捷键 （前提是没有语句漂红）； 桩模块（stub) 详细参考： http://blog.csdn.net/chenyt01/article/details/52216857 交互设计（Interaction Design）：定义、设计人造系统的行为的设计领域，它定义了两个或多个互动的个体之间交流的内容和结构，使之互相配合，共同达成某种目的。 学会用程序员的思维去体验产品，体会到一点点feel就是之后自己开发产品时的目标。（类似崔老师提到的以上交互设计…) 熟悉键盘： 一分钟至少中文30英文100. 2017/9/22 先接受，再评价；平和心态，没有什么东西是没用的，存在即是合理。 学会以工程的思维去编码。 (String[],args) &lt;==&gt; (String…,args) 偶然发现 refactor 重构（更改变量名） 程序员要学会“手贱”，用‘删除则不能’的方法搞懂每个东西的作用。 Java里面只有void返回类型，不存在用void定义方法类型。 对于工具书，先看前言与目录，然后在需要用的时候读。 函数里不要有输出语句，运用返回值。 main方法里只需有main一个方法即可 。 log4j插件 日志方式（替换输出) 4==for 2==to 2017/9/26 两个名词：回归测试、分而治之（本节课崔老师主要在示范程序规范与初步介绍debug.） 2017/9/29 【编程思想】：考虑用户不确定的需求，留意程序的本身特性，自己给自己加码。工程意识、客户需求、容错性 模块化、函数化、流式化编程。（本节课崔老师主要结合课后题目展开介绍编程思想） 2017/10/10 编写代码注意： 要有条理性、学会分而治之、（可配置可变化） （必要的“职业病”是可以有的） 精细的去做几道题目，从中学会扩散的挖掘知识比盲目做大量题目要好一点，在过程中总结体会真正的编程思想。 不足之一：看资料看的太慢（知识储备太少） 之后第一遍读东西不用太细致，第一遍要去发掘其中的关键点。 扩散——&gt;回车、多动手实践敲代码、又一次提到练打字、所有导包语句都不要自己写 2017/10/13 Ctrl+shift+o 自动导入所需包 Ctrl+shift+f 自动缩进 编译器的报错信息从下往上看。 学会看源码。对比自己写的代码学习可学习之处。 了解：数组扩容、泛型、多态。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://leo.dropsec.xyz/tags/Java/"}]},{"title":"新手常见的17个Python运行时错误","slug":"新手常见的17个Python运行时错误","date":"2017-09-05T11:37:37.000Z","updated":"2017-09-05T12:24:07.121Z","comments":true,"path":"2017/09/05/新手常见的17个Python运行时错误/","link":"","permalink":"http://leo.dropsec.xyz/2017/09/05/新手常见的17个Python运行时错误/","excerpt":"早计划学习python了，最近一段时间才缓缓展开行动…自我感觉熟练python后可以很随意的编写程序，比C++方便多。","text":"早计划学习python了，最近一段时间才缓缓展开行动…自我感觉熟练python后可以很随意的编写程序，比C++方便多。 当初学 Python 时，想要弄懂 Python 的错误信息的含义可能有点复杂。这里列出了常见的的一些让你程序 crash 的运行时错误。 1）忘记在 if , elif , else , for , while , class ,def 声明末尾添加 ：（导致 “SyntaxError ：invalid syntax”） 该错误将发生在类似如下代码中： if spam == 42 print(&apos;Hello!&apos;) 2)使用 = 而不是 ==（导致“SyntaxError: invalid syntax”） = 是赋值操作符而 == 是等于比较操作。该错误发生在如下代码中： if spam = 42: print(&apos;Hello!&apos;) 3）错误的使用缩进量。（导致“IndentationError：unexpected indent”、“IndentationError：unindent does not match any outer indetation level”以及“IndentationError：expected an indented block”） 记住缩进增加只用在以：结束的语句之后，而之后必须恢复到之前的缩进格式。该错误发生在如下代码中： print(&apos;Hello!&apos;) print(&apos;Howdy!&apos;) 或者： if spam == 42: print(&apos;Hello!&apos;) print(&apos;Howdy!&apos;) 或者： if spam == 42: print(&apos;Hello!&apos;) 4）在 for 循环语句中忘记调用 len() (导致“TypeError: ‘list’ object cannot be interpreted as an integer”) 通常你想要通过索引来迭代一个list或者string的元素，这需要调用 range() 函数。要记得返回len 值而不是返回这个列表。 该错误发生在如下代码中： spam = [&apos;cat&apos;, &apos;dog&apos;, &apos;mouse&apos;] for i in range(spam): print(spam[i]) 5）尝试修改string的值（导致“TypeError: ‘str’ object does not support item assignment”） string是一种不可变的数据类型，该错误发生在如下代码中： spam = &apos;I have a pet cat.&apos; spam[13] = &apos;r&apos; print(spam) 而你实际想要这样做： spam = &apos;I have a pet cat.&apos; spam = spam[:13] + &apos;r&apos; + spam[14:] print(spam) 6）尝试连接非字符串值与字符串（导致 “TypeError: Can’t convert ‘int’ object to str implicitly”） 该错误发生在如下代码中： numEggs = 12 print(&apos;I have &apos; + numEggs + &apos; eggs.&apos;) 而你实际想要这样做： numEggs = 12 print(&apos;I have &apos; + str(numEggs) + &apos; eggs.&apos;) 或者： numEggs = 12 print(&apos;I have %s eggs.&apos; % (numEggs)) 7）在字符串首尾忘记加引号（导致“SyntaxError: EOL while scanning string literal”） 该错误发生在如下代码中： print(Hello!&apos;) 或者: print(&apos;Hello!) 或者: myName = &apos;Al&apos; print(&apos;My name is &apos; + myName + . How are you?&apos;) 8）变量或者函数名拼写错误（导致“NameError: name ‘fooba’ is not defined”） 该错误发生在如下代码中： foobar = &apos;Al&apos; print(&apos;My name is &apos; + fooba) 或者: spam = ruond(4.2) 或者: spam = Round(4.2) 9）方法名拼写错误（导致 “AttributeError: ‘str’ object has no attribute ‘lowerr’”） 该错误发生在如下代码中： spam = &apos;THIS IS IN LOWERCASE.&apos; spam = spam.lowerr() 10）引用超过list最大索引（导致“IndexError: list index out of range”） 该错误发生在如下代码中： spam = [&apos;cat&apos;, &apos;dog&apos;, &apos;mouse&apos;] print(spam[6]) 11）使用不存在的字典键值（导致“KeyError：‘spam’”） 该错误发生在如下代码中： spam = {&apos;cat&apos;: &apos;Zophie&apos;, &apos;dog&apos;: &apos;Basil&apos;, &apos;mouse&apos;: &apos;Whiskers&apos;} print(&apos;The name of my pet zebra is &apos; + spam[&apos;zebra&apos;]) 12）尝试使用Python关键字作为变量名（导致“SyntaxError：invalid syntax”） Python关键不能用作变量名，该错误发生在如下代码中： class = &apos;algebra&apos; Python3的关键字有：and, as, assert, break, class, continue, def, del, elif, else, except, False, finally, for, from, global, if, import, in, is, lambda, None, nonlocal, not, or, pass, raise, return, True, try, while, with, yield 13）在一个定义新变量中使用增值操作符（导致“NameError: name ‘foobar’ is not defined”） 不要在声明变量时使用0或者空字符串作为初始值，这样使用自增操作符的一句spam += 1等于spam = spam + 1，这意味着spam需要指定一个有效的初始值。 该错误发生在如下代码中： spam = 0 spam += 42 eggs += 42 14）在定义局部变量前在函数中使用局部变量（此时有与局部变量同名的全局变量存在）（导致“UnboundLocalError: local variable ‘foobar’ referenced before assignment”） 在函数中使用局部变来那个而同时又存在同名全局变量时是很复杂的，使用规则是：如果在函数中定义了任何东西，如果它只是在函数中使用那它就是局部的，反之就是全局变量。 这意味着你不能在定义它之前把它当全局变量在函数中使用。 该错误发生在如下代码中： someVar = 42 def myFunction(): print(someVar) someVar = 100 myFunction() 15）尝试使用 range()创建整数列表（导致“TypeError: ‘range’ object does not support item assignment”） 有时你想要得到一个有序的整数列表，所以 range() 看上去是生成此列表的不错方式。然而，你需要记住 range() 返回的是 “range object”，而不是实际的 list 值。 该错误发生在如下代码中： spam = range(10) spam[4] = -1 也许这才是你想做： spam = list(range(10)) spam[4] = -1 （注意：在 Python 2 中 spam = range(10) 是能行的，因为在 Python 2 中 range() 返回的是list值，但是在 Python 3 中就会产生以上错误） 16）不错在 ++ 或者 – 自增自减操作符。（导致“SyntaxError: invalid syntax”） 如果你习惯于例如 C++ , Java , PHP 等其他的语言，也许你会想要尝试使用 ++ 或者 – 自增自减一个变量。在Python中是没有这样的操作符的。 该错误发生在如下代码中： spam = 1 spam++ 也许这才是你想做的： spam = 1 spam += 1 17）忘记为方法的第一个参数添加self参数（导致“TypeError: myMethod() takes no arguments (1 given)”） 该错误发生在如下代码中： class Foo(): def myMethod(): print(&apos;Hello!&apos;) a = Foo() a.myMethod() 原文链接：http://www.oschina.net/question/89964_62779","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://leo.dropsec.xyz/tags/Python/"}]},{"title":"实验吧逆向脱壳 汇总","slug":"实验吧逆向脱壳-汇总","date":"2017-09-01T06:05:41.000Z","updated":"2017-09-01T07:50:19.987Z","comments":true,"path":"2017/09/01/实验吧逆向脱壳-汇总/","link":"","permalink":"http://leo.dropsec.xyz/2017/09/01/实验吧逆向脱壳-汇总/","excerpt":"实验吧的五个逆向脱壳实验，汇总一下。","text":"实验吧的五个逆向脱壳实验，汇总一下。 第1节 ESP定律ESP定理脱壳（ESP在OD的寄存器中，我们只要在命令行下ESP的硬件访问断点，就会一下来到程序的OEP了！）（1）开始就点F8，注意观察OD右上角的寄存器中ESP有没突现（变成红色）（这只是一般情况下，更确切的说我们选择的ESP值是关键句之后的第一个ESP值）当有且只有ESP和EIP为红色时，我们可以用ESP定律了（2）在命令行下：dd XXXXXXXX(指在当前代码中的ESP地址，或者是hr XXXXXXXX)，按回车（3）选中下断的地址，断点—&gt;硬件访问—&gt;WORD断点（4）按一下F9运行程序，直接来到了跳转处，按下F8，到达程序OEP 第2节 SFX定律使用SFX法脱壳的常见步骤： 将OD设置为忽略所有异常 在OD的“调试选项”对话框的“SFX”选项中选择“字节模式跟踪实际入口”，确定 将待脱壳程序拖入OD，程序载入完成后会直接停在OEP处 关于SFX: 第3节 出口标志前面几个脱壳方法中有一个共同点，就是在单步跟踪到popad指令后面不远处的jmp指令的时候，就可以大胆的判断这个jmp指令的目的地址就是OEP。原因很简单，popad指令用于将壳运行之前保存的环境恢复，使原程序能正常运行。有些壳的popad指令很少，我们就可以查看被这种壳加壳的程序的所有popad指令，找到后面存在jmp指令的popad指令，然后来到其后的jmp指令的目的地址，这很可能就是OEP，然后就可以进行dump脱壳了。 使用出口标志法脱壳的常见步骤：1、将待脱壳程序载入OD中，在OD的反汇编客人口中单击鼠标右键，在弹出的右键菜单中单击“查找”→“所有命令”，在弹出的输入框中输入“popad”并按“查找”按钮；2、逐一尝试跟踪查找到的所有“popad”指令，最终达到程序的OEP。 第4节 单步跟踪单步跟踪法的步骤：（1）用OD载入，点“不分析代码”（2）单步向下跟踪F8，实现向下的跳。也就是说向上的跳不让其实现（通过F4）（3）遇到程序往回跳的（包括循环），我们在下一句代码处按F4（或者右健单击代码，选择断点—&gt;运行到所选）（4）绿色线条表示跳转没实现，不用理会，红色线条表示跳转已经实现（5）如果刚载入程序，在附近就有一个CALL的，我们就F7跟进去，不然程序很容易跑飞，这样很快就能到程序的OEP（6）在跟踪的时候，如果运行到某个CALL程序就运行的，就在这个CALL中F7进入（7）一般有很大的跳转（大跨段），比如 jmp XXXXXX 或者 JE XXXXXX 或者有RETN 的一般很快就会到程序的OEP 第5节 内存镜像法内存镜像法的步骤：（1）用OD打开软件（2）点击选项——调试选项——异常，把里面的忽略全部√上。CTRL+F2重载入程序（3）按ALT+M,打开内存镜象，找到程序的第一个.rsrc.按F2下断点，然后按SHIFT+F9运 行到断点，接着再按ALT+M,打开内存镜象，找到程序的第一个.rsrc.上面的代码段.text（或者CODE）（也就是00401000处），按F2下断点。然后按SHIFT+F9（或者是在没异常情况下按F9）， 直接到达程序OEP (亲自在试验机里试了试，怎么发现不可行…)","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"实验吧逆向破解 汇总","slug":"实验吧逆向破解-汇总","date":"2017-08-31T12:40:54.000Z","updated":"2017-08-31T13:29:36.211Z","comments":true,"path":"2017/08/31/实验吧逆向破解-汇总/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/31/实验吧逆向破解-汇总/","excerpt":"用了好长时间看完了这十九个实验，总该有些收获吧，简单汇总一下，方便之后的记忆…","text":"用了好长时间看完了这十九个实验，总该有些收获吧，简单汇总一下，方便之后的记忆… 第1节 暴力破解程序用查找字符串的方法找到关键跳，NOP掉，实现暴力破解。 第2节 获得注册码用查找字符串的方法找到关键代码，追出注册码。 第3节 跳转破解先00401000到达程序入口，查找字符串的方法找到关键跳，修改关键跳指令实现爆破。 第4节 带壳破解 本题是不脱ASPack2.12壳直接寻找注册码 加壳程序载入OD是先载入壳程序，壳程序解密软件。所以需要先跳转到软件解密的地方才可以搜索字符串，加密下是无法找到的 本程序在搜索字符串的时候看到了S哦反弹ware\\engydt，即程序在启动时访问了注册表，提取了用户名与序列号，然后进行对比 然后运用API断点操作后可以跟到注册码第5节 软件文件大小自校验首先用ESP定律脱壳，然后用ImportRECR获取导入表、修正转存…然后在用OD解除文件自校验。用到了API断点找到关键跳转NOP掉就OK了第6节 修改关键CALL返回值先字符串查找到关键跳，关键跳是根据关键CALL返回的值执行的，so,想办法控制CALL返回的值就KO了。第7节 重启验证读取文件字符串查找到关键跳，下断点设置API断点 第8节 万能断点利用万能断点追出注册码，万能断点可以吧程序中可以断下的地方都断下 第9节 VB弹出窗口利用VB弹出函数追出注册码，对于VB程序，在rtcMsBox函数处下断点，然后追出（最后也是NOP的） 第10节 删除弹窗找到弹窗的代码，改变指令跳过或NOP就可以了。 第11节 真码保存在系统文件这个实验没什么好说的… 第12节 BC++手动查找IAT脱壳后手动修复地址表。 第13节 利用dede查找按钮事件如题： 利用dede查找按钮事件，找到关键跳NOP 第14节 ALT+F9关键CALL追注册码ALT+F9关键CALL追注册码 搞得我都不知道如何写。。。 第15节 加壳软件打补丁就是用特定软件改写了一下相关指令的地址，本质类似于jmp 第16节 易语言窗体法更改易语言主窗口弹出代码，使程序跳过注册口，直接弹出用户界面（满满的我不知道的套路） 第17节 易语言退出暗桩修改跳转 第18节 VB按钮脚本破解（满满的我不知道的套路，请看原指导书） 第19节 修改软件标题图标利用PE Explorer修改一下caption选项内容 记忆力下降 理解能力下降","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"OK 天津","slug":"OK-天津","date":"2017-08-28T13:29:17.000Z","updated":"2017-08-30T05:34:57.005Z","comments":true,"path":"2017/08/28/OK-天津/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/28/OK-天津/","excerpt":"8.24–8.28 与三友共浪天津，回来之后迫不及待的想记录一点东西…","text":"8.24–8.28 与三友共浪天津，回来之后迫不及待的想记录一点东西… 多年前的我对天津是有某种情感的，小时候姥爷长期工作于天津，年时总会讲起它的点滴，渐渐的渐渐的便对它有了亲近感。但等姥爷去世后，时间一长那种情感也就渐渐随风而去，数一数，六七年了吧… 如今，走近天津，除了开始的要去追寻这座城的历史，其间也产生了去了解姥爷之前生活的土地的念头。 之于在天津的游玩，是没有必要细说的，简单记录下行踪便可：天津大学北洋园校区、天津市奥体中心全运会预演、东疆建设开发纪念公园、天津之眼(海河)、天津大学老校区、南开大学老校区、五大道古建筑群。 然后要说的便是自己的一些体会了：首先，重新谈一下天津印象，由于地处北方，跟之前有去过的广州、深圳等南方城市相比它是北方味道十足，不论是周遭的植被，还是建筑。其次便是资金流，天津身为直辖市之一本身就极具吸引力，又由于历史、地理位置等因素使其一直稳步向前发展，虽然自我感觉没有前几年发展的快了，但是实力并未减弱，稳中有实形容天津感觉比较恰当。最后便是天津人了，之前知道老北京人说话比较有特点，听后会感觉特别带劲，对于天津人的概念是比较模糊的，今日听闻，发现天津当地人说话同样自带特色，并且感觉和老北京人说话神似，听后心中默念：正宗正宗。 最后的最后抛开天津，谈一谈感想：其一：虽然我们几个可以说都是自诩肚子里有点笔墨的人，但是并不意味着在现实生活中就会比其他人具有某些优势，很多东西我们只会在书本上熟练的运用，实际生活中的行为总会显得有点幼稚、可笑…其二：城市穿梭之间，一浪友对我说感觉大城市都是一样的、都是单调的高楼与乏味的繁华。细细一想，一方水土一方人，人与文化是一座城市的灵魂，现如今我们大部分人都将重心放在了其他地方，对主体的人与人所产生的文化有所忽略，又怎么会去深入的了解这方水土，这座城市呢？因此会感觉不到这方水土这座城市的特色，发出“一样”的感叹。不怪本地的建设者，也怪不得他方的游人。。。 其三：年轻的时候还是有必要到处走走的，去多一点的地方、见多一点的人，虽然这是我的一贯看法，其实自我感觉我做的也不好，有点优柔、有点寡断。读书与运动总要有一个在路上，其中读书不只是表象的阅读有字书本还应包含无字的天地之书。而反思一下，读书与运动这两者我怠慢了好多。 其四：让我发句牢骚：好多你坚信行不通的东西在别人看来可能是行得通的。","categories":[],"tags":[{"name":"杂儿","slug":"杂儿","permalink":"http://leo.dropsec.xyz/tags/杂儿/"}]},{"title":"CrackMe 008","slug":"CrackMe-008","date":"2017-08-24T02:48:28.000Z","updated":"2017-08-28T13:03:45.723Z","comments":true,"path":"2017/08/24/CrackMe-008/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/24/CrackMe-008/","excerpt":"经过了前两天的煎熬，总算遇到一个简单点的题了。。。呜呜呜，我也是很激动(。・∀・)ノ","text":"经过了前两天的煎熬，总算遇到一个简单点的题了。。。呜呜呜，我也是很激动(。・∀・)ノ 观察简单一个KEY，输入后弹出错误提示PEID查看一下，无壳，VB写的载入OD，智能搜索字符串双击succesful进入对应汇编代码简单分析可以看到关键跳然后向上找到这个函数入口，往下单步执行，容易看到在获得输入KEY后紧接着有个strcmp,其上一行出现了正确KEY.验证一下OK 结束","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"CrackMe 007 补","slug":"CrackMe-007-补","date":"2017-08-23T14:12:04.000Z","updated":"2017-08-24T04:30:44.270Z","comments":true,"path":"2017/08/23/CrackMe-007-补/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/23/CrackMe-007-补/","excerpt":"标题创建于八月二十三，内容写于二十四。加油，Crack 007","text":"标题创建于八月二十三，内容写于二十四。加油，Crack 007","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"CrackMe 006 占位（总结五种语言按钮事件的找法）","slug":"CrackMe-006-占位（总结五种语言按钮事件的找法）","date":"2017-08-22T12:57:45.000Z","updated":"2017-08-28T12:54:12.968Z","comments":true,"path":"2017/08/22/CrackMe-006-占位（总结五种语言按钮事件的找法）/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/22/CrackMe-006-占位（总结五种语言按钮事件的找法）/","excerpt":"我想我可以去die了…CrackMe 006也有点难。。。伤心","text":"我想我可以去die了…CrackMe 006也有点难。。。伤心这里有个教程感觉也不是很好：http://www.dbgpro.com/archives/317.html中间就不照号了 其间看到一篇不同语言程序找按钮事件的方法，转载到此： 总结五种语言按钮事件的找法调试软件,最重要的就是下断点,那么如何下断点,就是一门重要的技巧.比如:弹提示框,就下MessageBoxA,注册表的,就下RegOpenKeyA等等.当然,能直接下到按钮事件,当然更为方便,因为到了按钮事件后,很快就会到达核心代码,离你的破解也就不远了.本文就总结一下各类语言找按钮事件的方法,当然也可以借助工具,如VBexplorer,DEDE,ECE等等. 一、VB程序其实,VB的按钮事件的找法是最为普遍的,也就是大家所谓的万能断点.其实也不仅仅是针对按钮事件,还有很多其他的用处,如取消NAG,启动框,灰色按钮或隐藏按钮,启动时的timer事件等等,具体的就自己去总结吧,这里只演示按钮事件! OD载入后,CTRL+B,816C24 然后,就在下面的JMP处F2下断,下完后CTRL+L,如果还有,就继续下断点. 下完断点后,运行程序,点击相应的按钮,OD就会断下来了 下面的任务就是考验大家的耐心,F8跟踪吧,不再赘述了. 当然,为了方便大家,可以写个简单的脚本,免的每次都去手动设置了,节省时间:复制内容到剪贴板代码: var Addr mov Addr,401000 loop: find Addr,#816C2404??000000# cmp $RESULT,0 je Exit add $RESULT,08 bp $RESULT add $RESULT,1 mov Addr,$RESULT jmp loop Exit: eval &quot;按钮事件查找完毕!&quot; msg $RESULT ret 二、Delphi和BC++程序Delphi和BC++都是同一公司开发的,故查找方法都一样,当然你也可以使用DEDE. OD载入后,CTRL+G,转到00401000处然后就CTRL+B,查找特征码740E8BD38B83????????FF93???????? 然后就会找到下面的地方: 然后就在下面的CALL处下断吧. 下面的工作就是不断的CTRL+L继续查找和F2下断了. 同样写个脚本,方便大家操作:复制内容到剪贴板代码: var Addr mov Addr,401000 loop: find Addr,#740E8BD38B83????????FF93????????# cmp $RESULT,0 je Exit add $RESULT,0A bp $RESULT add $RESULT,1 mov Addr,$RESULT jmp loop Exit: ret 三、易语言易语言的这种查找方法,同样适合有壳的程序,其他的就必须脱壳后再继续操作了. OD载入后,就F9运行程序吧,当程序运行后,ALT+E选中易语言的核心库krnln,双击进去 然后CTRL+B,查找FF 55 FC 查找到的这个CALL就是了,F2下断吧 现在输入必须的内容后,单击对应的按钮吧 断下了就F7跟进吧,就来到按钮事件处了 同样,写个脚本,方便大家复制内容到剪贴板代码: gpa&quot;GetProcessHeap&quot;,&quot;kernel32.dll&quot; cmp $RESULT,0 je err bp $RESULT run run run bc $RESULT rtu find 10001000,#FF55FC5F5E895D??8945# bp $RESULT find eip,#FFE0# cmp$RESULT,0 je err bp $RESULT run bc $RESULT sto MSG &quot;按钮事件查找完毕！&quot; ret err: MSG &quot;脚本运行错误！请检查错误后再继续运行脚本！&quot; ret 四、VC++程序(非MFC程序)OD载入后,单击鼠标右键,选择”查找”,然后是”所有命令”在弹出的输入框里,写入特征代码”sub eax,0a“ 在下面的sub eax,0A处,双击进去吧: 来找这里后,在下面的je处跟随过去 跟随来到的这个CALL,就是了,F2下断吧 然后断下后,F7跟进,F8几次,就来到按钮事件了. 五、MFC类程序当然判断MFC和非MFC的程序,靠大家自己去判断了OD载入后.ALT+E,来到可执行模块,找MFC的核心DLL:MFC42然后就双击进去 然后就CTRL+F,查找特征代码:sub eax,0a 同样,找到后,就在下面的je处跟随,跟随后看到的CALL,就是那个关键CALL了! 断下后F7跟进,F8几次,就会来到按钮事件代码处了! 方法就简单的介绍到这里了,当然只是抛砖引玉,其他的,还得多靠大家自己慢慢总结吧!","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"CrackMe 005 占位 {{{(>_<)}}}","slug":"CrackMe-005-占位","date":"2017-08-21T13:34:32.000Z","updated":"2017-08-31T12:46:56.447Z","comments":true,"path":"2017/08/21/CrackMe-005-占位/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/21/CrackMe-005-占位/","excerpt":"呃，CrackMe 005有点难…题解也老长了，暂时记下，日后等水平稍微提升一点点再来战它。","text":"呃，CrackMe 005有点难…题解也老长了，暂时记下，日后等水平稍微提升一点点再来战它。首先记下CrackMe 005的两个题解链接： https://www.52pojie.cn/thread-366291-1-1.html http://blog.csdn.net/liwz11/article/details/50726518","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"CrackMe 004","slug":"CrackMe-004","date":"2017-08-20T13:03:08.000Z","updated":"2017-08-20T14:09:49.629Z","comments":true,"path":"2017/08/20/CrackMe-004/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/20/CrackMe-004/","excerpt":"首先说一下，这个题是比较有“脾气”的。OK，咱们就来看看它到底是什么脾气…","text":"首先说一下，这个题是比较有“脾气”的。OK，咱们就来看看它到底是什么脾气… 观察当自己输入伪码后发现怎么没有确定键呀？进一步观察发现，当光标进入灰色区域是光标旁边会出现提示：注册成功时会在下面出现一张照片然后我们可以假想一下题目的思路：可能是当输入正确的信息后点击灰色区域就会出现照片，而输入伪码时就会陷入死循环… 查壳Delphi，没有加壳由于对Delphi不是很熟悉，因此网上查了一下大佬们在逆Delphi时的各种姿势，发现了一个很好用的工具Dede，于是下载下来然后拖入程序进行分析。查看过程发现过程窗口里面有chkcode事件，这就很有可能是我们要找的计算序列号的函数了，查看RVA是00457C40那么在OD当中，ctrl+G 找到这个位置，下断点分析 00457C40 /. 55 push ebp 00457C41 |. 8BEC mov ebp,esp 00457C43 |. 51 push ecx 00457C44 |. B9 05000000 mov ecx,0x5 00457C49 |&gt; 6A 00 /push 0x0 00457C4B |. 6A 00 |push 0x0 00457C4D |. 49 |dec ecx 00457C4E |.^ 75 F9 \\jnz short CKme.00457C49 00457C50 |. 51 push ecx 00457C51 |. 874D FC xchg [local.1],ecx 00457C54 |. 53 push ebx 00457C55 |. 56 push esi 00457C56 |. 8BD8 mov ebx,eax 00457C58 |. 33C0 xor eax,eax 00457C5A |. 55 push ebp 00457C5B |. 68 3D7E4500 push CKme.00457E3D 00457C60 |. 64:FF30 push dword ptr fs:[eax] 00457C63 |. 64:8920 mov dword ptr fs:[eax],esp 00457C66 |. 8BB3 F8020000 mov esi,dword ptr ds:[ebx+0x2F8] ; esi=len(name) 00457C6C |. 83C6 05 add esi,0x5 ; esi+=5 00457C6F |. FFB3 10030000 push dword ptr ds:[ebx+0x310] ; 黑头Sun Bird 00457C75 |. 8D55 F8 lea edx,[local.2] 00457C78 |. 8BC6 mov eax,esi 00457C7A |. E8 85FEFAFF call CKme.00407B04 00457C7F |. FF75 F8 push [local.2] ; 9 00457C82 |. FFB3 14030000 push dword ptr ds:[ebx+0x314] ; dseloffc-012-OK 00457C88 |. 8D55 F4 lea edx,[local.3] 00457C8B |. 8B83 D4020000 mov eax,dword ptr ds:[ebx+0x2D4] 00457C91 |. E8 B2B6FCFF call CKme.00423348 00457C96 |. FF75 F4 push [local.3] 00457C99 |. 8D83 18030000 lea eax,dword ptr ds:[ebx+0x318] 00457C9F |. BA 04000000 mov edx,0x4 00457CA4 |. E8 93BFFAFF call CKme.00403C3C 00457CA9 |. 33D2 xor edx,edx 00457CAB |. 8B83 F4020000 mov eax,dword ptr ds:[ebx+0x2F4] 00457CB1 |. E8 AAB5FCFF call CKme.00423260 00457CB6 |. 8B93 18030000 mov edx,dword ptr ds:[ebx+0x318] ; 黑头Sun Bird9dseloffc-012-OKtest 记为_str 00457CBC |. 8B83 F4020000 mov eax,dword ptr ds:[ebx+0x2F4] 00457CC2 |. E8 B1B6FCFF call CKme.00423378 00457CC7 |. 33F6 xor esi,esi 00457CC9 |&gt; 8D55 EC /lea edx,[local.5] 00457CCC |. 8B83 D4020000 |mov eax,dword ptr ds:[ebx+0x2D4] 00457CD2 |. E8 71B6FCFF |call CKme.00423348 00457CD7 |. 8B45 EC |mov eax,[local.5] 00457CDA |. E8 9DBEFAFF |call CKme.00403B7C 00457CDF |. 83C0 03 |add eax,0x3 00457CE2 |. 8D55 F0 |lea edx,[local.4] 00457CE5 |. E8 1AFEFAFF |call CKme.00407B04 00457CEA |. FF75 F0 |push [local.4] 00457CED |. 8D55 E8 |lea edx,[local.6] 00457CF0 |. 8B83 D4020000 |mov eax,dword ptr ds:[ebx+0x2D4] 00457CF6 |. E8 4DB6FCFF |call CKme.00423348 00457CFB |. FF75 E8 |push [local.6] 00457CFE |. 8D55 E4 |lea edx,[local.7] 00457D01 |. 8BC6 |mov eax,esi 00457D03 |. E8 FCFDFAFF |call CKme.00407B04 00457D08 |. FF75 E4 |push [local.7] 00457D0B |. 8D45 FC |lea eax,[local.1] 00457D0E |. BA 03000000 |mov edx,0x3 00457D13 |. E8 24BFFAFF |call CKme.00403C3C 00457D18 |. 46 |inc esi 00457D19 |. 83FE 13 |cmp esi,0x13 00457D1C |.^ 75 AB \\jnz short CKme.00457CC9 00457D1E |. 8D55 E0 lea edx,[local.8] 00457D21 |. 8B83 D8020000 mov eax,dword ptr ds:[ebx+0x2D8] 00457D27 |. E8 1CB6FCFF call CKme.00423348 ; get input serial 00457D2C |. 8B45 E0 mov eax,[local.8] 00457D2F |. 8B93 18030000 mov edx,dword ptr ds:[ebx+0x318] ; 出现 _str+name 黑头Sun Bird9dseloffc-012-OKtest 00457D35 |. E8 52BFFAFF call CKme.00403C8C ; compare 这里就是分析之后的结果，先计算name的长度，然后加5，之后与指定字符串进行拼接，最后结尾接上name。keygen: #coding:gb18030 def keygen(name): serial=len(name)+5 serial=&apos;黑头Sun Bird&apos;+str(serial)+&apos;dseloffc-012-OK&apos;+name print serial name=raw_input(&apos;please input the name: &apos;) keygen(name) 随便生成一个name/serial组合试一下name:111serial:黑头Sun Bird8dseloffc-012-OK111 最终破解完成. ………………………………………………………………………………………………… 其实这个题的内部结构远比以上分析的复杂，以上只是捡关键的在分析，正在交错的地方，或许根本没触及到…可以进一步参考如下链接：http://blog.csdn.net/liwz11/article/details/50717038","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"CrackMe 003","slug":"CrackMe-003","date":"2017-08-19T07:13:59.000Z","updated":"2017-08-19T09:11:48.526Z","comments":true,"path":"2017/08/19/CrackMe-003/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/19/CrackMe-003/","excerpt":"算法部分又出新花样，在第二题之上加入了浮点运算，加上战线拉的长，需要耐心分析方可得出Key… en,最后再加个解除延时… [多看看浮点汇编运算]","text":"算法部分又出新花样，在第二题之上加入了浮点运算，加上战线拉的长，需要耐心分析方可得出Key… en,最后再加个解除延时… [多看看浮点汇编运算] 观察运行程序ei？这里好像有一个延时吖，嗯，是的。输入test 1234 确定目标一.找到注册机二.解除延时 一.找到注册机加载进入OD，查找错误提示字符串，找到对应汇编代码查看上面相关代码，很容易找到关键跳然后就开始分析算法了…找到这个函数开始，下断，然后F9，一步步找到有用代码函数开始到关键跳代码比较冗长，只跳关键部分进行重点分析第一部分： 004081E3 FF15 18B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; **get input name 004081E9 8B95 50FFFFFF mov edx,dword ptr ss:[ebp-0xB0] 004081EF 8B45 E4 mov eax,dword ptr ss:[ebp-0x1C] ; **eax=name 004081F2 50 push eax 004081F3 8B1A mov ebx,dword ptr ds:[edx] 004081F5 FF15 F8B04000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBs&gt;; **get length of name 004081FB 8BF8 mov edi,eax ; **edi=name length 004081FD 8B4D E8 mov ecx,dword ptr ss:[ebp-0x18] ; **ecx=name 00408200 69FF 385B0100 imul edi,edi,0x15B38 ; **edi*=0x15B38 00408206 51 push ecx 00408207 0F80 B7050000 jo AfKayAs_.004087C4 ; *jump overflow 0040820D FF15 0CB14000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;] ; **get name[0] 00408213 0FBFD0 movsx edx,ax ; **edx=name[0] 计算第一个字符的ASCII码值 00408216 03FA add edi,edx ; **edi+=name[0] 00408218 0F80 A6050000 jo AfKayAs_.004087C4 ; *jump overflow 0040821E 57 push edi 0040821F FF15 F4B04000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;; **hex-&gt;dec EDI结果转成10进制数 00408225 8BD0 mov edx,eax 00408227 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20] 这段汇编代码与CrackMe2中的代码的流程是一样的，算法就是（name的长度）*0x15B38+第一个字符的ASCII码值，转成10进制字符串，这个简单。之后，我们再向后看，肯定有不同的位置，发现出现了浮点数运算:我们继续对代码进行分析，到跳转条件前一共主要出现了四段浮点数的汇编部分:第二部分： 004082E7 8B19 mov ebx,dword ptr ds:[ecx] 004082E9 FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; name转换成浮点数,结果在浮点寄存器里 004082EF D905 08104000 fld dword ptr ds:[0x401008] ; **将0401008中的硬编码实型存入st0 004082F5 833D 00904000 0&gt;cmp dword ptr ds:[0x409000],0x0 004082FC 75 08 jnz short AfKayAs_.00408306 004082FE D835 0C104000 fdiv dword ptr ds:[0x40100C] 00408304 EB 0B jmp short AfKayAs_.00408311 00408306 FF35 0C104000 push dword ptr ds:[0x40100C] 0040830C E8 578DFFFF call &lt;jmp.&amp;MSVBVM50._adj_fdiv_m32&gt; 00408311 83EC 08 sub esp,0x8 00408314 DFE0 fstsw ax ; **将st0中的值复制到ax中 00408316 A8 0D test al,0xD 00408318 0F85 A1040000 jnz AfKayAs_.004087BF 0040831E DEC1 faddp st(1),st ; **将st(num)和st相加，用和来替换st(num),将st出栈 00408320 DFE0 fstsw ax 00408322 A8 0D test al,0xD 00408324 0F85 95040000 jnz AfKayAs_.004087BF 0040832A DD1C24 fstp qword ptr ss:[esp] 0040832D FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt; 00408333 8BD0 mov edx,eax 其实这部分并没有做什么实质上的工作，不过通过浮点数运算对内存中的数据进行改动(我们后面会发现这些内存地址都用了，但我们并不需要考虑这些，直接当做硬编码处理就可以了)。第三部分： 004083F3 8B19 mov ebx,dword ptr ds:[ecx] 004083F5 FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt; 004083FB DC0D 10104000 fmul qword ptr ds:[0x401010] ; **name=name*3 00408401 83EC 08 sub esp,0x8 00408404 DC25 18104000 fsub qword ptr ds:[0x401018] ; **name=name-2 0040840A DFE0 fstsw ax 0040840C A8 0D test al,0xD 0040840E 0F85 AB030000 jnz AfKayAs_.004087BF 00408414 DD1C24 fstp qword ptr ss:[esp] ; **结果存入堆栈 00408417 FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt; 0040841D 8BD0 mov edx,eax 可以看到，这部分对输入的name进行了简单的浮点运算:name=name*3-2第四部分： 004084DD 8B19 mov ebx,dword ptr ds:[ecx] 004084DF FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt; 004084E5 DC25 20104000 fsub qword ptr ds:[0x401020] ; **str-(-15) 004084EB 83EC 08 sub esp,0x8 004084EE DFE0 fstsw ax 004084F0 A8 0D test al,0xD 004084F2 0F85 C7020000 jnz AfKayAs_.004087BF 004084F8 DD1C24 fstp qword ptr ss:[esp] 004084FB FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt; 00408501 8BD0 mov edx,eax 又对name进行了简单的操作，name=name-(-0x15);第五部分： 004085C8 FF15 18B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt; 004085CE 8B45 E8 mov eax,dword ptr ss:[ebp-0x18] ; **eax=input serial 004085D1 50 push eax ; **serial转换成浮点数 004085D2 FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; 004085D8 8B4D E4 mov ecx,dword ptr ss:[ebp-0x1C] 004085DB DD9D 1CFFFFFF fstp qword ptr ss:[ebp-0xE4] 004085E1 51 push ecx ; **我们输入的serila转化成浮点数 004085E2 FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt; 004085E8 833D 00904000 0&gt;cmp dword ptr ds:[0x409000],0x0 004085EF 75 08 jnz short AfKayAs_.004085F9 004085F1 DCBD 1CFFFFFF fdivr qword ptr ss:[ebp-0xE4] ; **name/serial值存入st0 004085F7 EB 11 jmp short AfKayAs_.0040860A 004085F9 FFB5 20FFFFFF push dword ptr ss:[ebp-0xE0] 004085FF FFB5 1CFFFFFF push dword ptr ss:[ebp-0xE4] 00408605 E8 888AFFFF call &lt;jmp.&amp;MSVBVM50._adj_fdivr_m64&gt; 0040860A DFE0 fstsw ax 0040860C A8 0D test al,0xD 0040860E 0F85 AB010000 jnz AfKayAs_.004087BF 00408614 FF15 34B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFpR8&gt;&gt; 0040861A DC1D 28104000 fcomp qword ptr ds:[0x401028] ; **判断name/serial==1？ 00408620 DFE0 fstsw ax 00408622 F6C4 40 test ah,0x40 00408625 74 07 je short AfKayAs_.0040862E 这一部分实现的就是上面步骤生成的serial与我们输入的serial进行比较，只不过利用了有一点迷糊性质的浮点数除法，判断结果是否等于1而已。我们在总结一下算法，Name/Serial关系为： Serial = (strlen(Name)0x15B38+Name[0]+2.0)3.0-2.0+15写出注册机:（python） # coding=utf8 s = raw_input(&quot;name:&quot;) print &quot;password:&quot;+str((len(s)*0x15B38+ord(s[:1])+2)*3-2+15) 最后总结一下，其实算法很简单，不过用浮点数汇编来迷惑罢了。 二.解除延时打开程序，首先会出现如下界面程序会停在该界面若干秒，然后才进入主界面，我们要去掉这个延时界面。使用OllyDbg工具打开程序，进入调试运行，程序首先断在系统领空右键-&gt;查找-&gt;所以模块中的名称，在弹出的All names窗口中找到SetTimer双击SetTimer代码所在位置，然后设置断点调试运行，程序断在刚才设置的断点处，此时查看堆栈：可知延时界面的滞留时间为7000ms，相应的十六进制值为0x00001B58去掉这个延时界面只需将该时间修改得足够小但是该时间位于系统领空，无法直接用OllyDbg进行修改保存，我们借助WinHex工具使用WinHex工具打开程序，在菜单中选择Search -&gt; Find Hex Values，查找十六进制值581B0000将该值修改为01000000，即延时时间为0x00000001ms，保存即可。然后运行程序，发现不再延迟喽… ………………………………………………………分割线…………………………………………….其实自己也没必要太过灰心，毕竟自己也是刚开始学逆向没多久，根据汇编代码来推出算法对自己来说虽然还有难度，其实多遇到些题目，多总结经验慢慢的就很容易了。（其实现在做的题还是蛮难的，高手也得吮吮手指头呢…) hhh","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"CrackMe 002","slug":"CrackMe-002","date":"2017-08-18T13:45:03.000Z","updated":"2017-08-19T07:14:05.105Z","comments":true,"path":"2017/08/18/CrackMe-002/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/18/CrackMe-002/","excerpt":"直接转入正题…","text":"直接转入正题… 观察程序随便输入数据可知还是老思路 查壳，并且获取语言信息无壳，VB写的 破解加载进OD，字符串搜索Try Again,找到对应汇编代码，上下观看相关代码，发现战线拉得有点长，不过没关系，耐心一点就没问题。向上翻会找到关键跳转然后分析跳转上面的代码，找到函数开头（有点远），下断点，开始分析 00402310 &gt; \\55 push ebp 00402311 . 8BEC mov ebp,esp 00402313 . 83EC 0C sub esp,0xC 00402316 . 68 26104000 push &lt;jmp.&amp;MSVBVM50.__vbaExceptHandler&gt; ; SE 处理程序安装 0040231B . 64:A1 0000000&gt;mov eax,dword ptr fs:[0] 00402321 . 50 push eax 00402322 . 64:8925 00000&gt;mov dword ptr fs:[0],esp 00402329 . 81EC B0000000 sub esp,0xB0 0040232F . 53 push ebx 00402330 . 56 push esi 00402331 . 8B75 08 mov esi,dword ptr ss:[ebp+0x8] ; Afkayas_.&lt;ModuleEntryPoint&gt; 00402334 . 57 push edi 00402335 . 8BC6 mov eax,esi 00402337 . 83E6 FE and esi,-0x2 0040233A . 8965 F4 mov dword ptr ss:[ebp-0xC],esp 0040233D . 83E0 01 and eax,0x1 00402340 . 8B1E mov ebx,dword ptr ds:[esi] 00402342 . C745 F8 08104&gt;mov dword ptr ss:[ebp-0x8],Afkayas_.0040&gt; 00402349 . 56 push esi 0040234A . 8945 FC mov dword ptr ss:[ebp-0x4],eax 0040234D . 8975 08 mov dword ptr ss:[ebp+0x8],esi 00402350 . FF53 04 call dword ptr ds:[ebx+0x4] 00402353 . 8B83 10030000 mov eax,dword ptr ds:[ebx+0x310] 00402359 . 33FF xor edi,edi 0040235B . 56 push esi 0040235C . 897D E8 mov dword ptr ss:[ebp-0x18],edi 0040235F . 897D E4 mov dword ptr ss:[ebp-0x1C],edi 00402362 . 897D E0 mov dword ptr ss:[ebp-0x20],edi 00402365 . 897D DC mov dword ptr ss:[ebp-0x24],edi 00402368 . 897D D8 mov dword ptr ss:[ebp-0x28],edi 0040236B . 897D D4 mov dword ptr ss:[ebp-0x2C],edi 0040236E . 897D C4 mov dword ptr ss:[ebp-0x3C],edi 00402371 . 897D B4 mov dword ptr ss:[ebp-0x4C],edi 00402374 . 897D A4 mov dword ptr ss:[ebp-0x5C],edi 00402377 . 897D 94 mov dword ptr ss:[ebp-0x6C],edi 0040237A . 8985 40FFFFFF mov dword ptr ss:[ebp-0xC0],eax 00402380 . FFD0 call eax 00402382 . 8D4D D4 lea ecx,dword ptr ss:[ebp-0x2C] 00402385 . 50 push eax 00402386 . 51 push ecx 00402387 . FF15 0C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaObjSe&gt;; msvbvm50.__vbaObjSet 0040238D . 8B9B 00030000 mov ebx,dword ptr ds:[ebx+0x300] 00402393 . 56 push esi 00402394 . 8985 50FFFFFF mov dword ptr ss:[ebp-0xB0],eax 0040239A . 899D 3CFFFFFF mov dword ptr ss:[ebp-0xC4],ebx 004023A0 . FFD3 call ebx 004023A2 . 8D55 DC lea edx,dword ptr ss:[ebp-0x24] 004023A5 . 50 push eax 004023A6 . 52 push edx ; ntdll.KiFastSystemCallRet 004023A7 . FF15 0C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaObjSe&gt;; msvbvm50.__vbaObjSet 004023AD . 8BD8 mov ebx,eax 004023AF . 8D4D E8 lea ecx,dword ptr ss:[ebp-0x18] 004023B2 . 51 push ecx 004023B3 . 53 push ebx 004023B4 . 8B03 mov eax,dword ptr ds:[ebx] 004023B6 . FF90 A0000000 call dword ptr ds:[eax+0xA0] 004023BC . 3BC7 cmp eax,edi 004023BE . 7D 12 jge short Afkayas_.004023D2 004023C0 . 68 A0000000 push 0xA0 004023C5 . 68 5C1B4000 push Afkayas_.00401B5C 004023CA . 53 push ebx 004023CB . 50 push eax 004023CC . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj 004023D2 &gt; 56 push esi 004023D3 . FF95 3CFFFFFF call dword ptr ss:[ebp-0xC4] 004023D9 . 8D55 D8 lea edx,dword ptr ss:[ebp-0x28] 004023DC . 50 push eax 004023DD . 52 push edx ; ntdll.KiFastSystemCallRet 004023DE . FF15 0C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaObjSe&gt;; msvbvm50.__vbaObjSet 004023E4 . 8BD8 mov ebx,eax 004023E6 . 8D4D E4 lea ecx,dword ptr ss:[ebp-0x1C] 004023E9 . 51 push ecx 004023EA . 53 push ebx 004023EB . 8B03 mov eax,dword ptr ds:[ebx] 004023ED . FF90 A0000000 call dword ptr ds:[eax+0xA0] ; **get the Name we input** 004023F3 . 3BC7 cmp eax,edi 004023F5 . 7D 12 jge short Afkayas_.00402409 004023F7 . 68 A0000000 push 0xA0 004023FC . 68 5C1B4000 push Afkayas_.00401B5C 00402401 . 53 push ebx 00402402 . 50 push eax 00402403 . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj 00402409 &gt; 8B95 50FFFFFF mov edx,dword ptr ss:[ebp-0xB0] 0040240F . 8B45 E4 mov eax,dword ptr ss:[ebp-0x1C] ; **save Name to EAX** 00402412 . 50 push eax 00402413 . 8B1A mov ebx,dword ptr ds:[edx] 00402415 . FF15 E4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBs&gt; **get length of Name** 0040241B . 8BF8 mov edi,eax ; **EDI = length of Name** 0040241D . 8B4D E8 mov ecx,dword ptr ss:[ebp-0x18] ; **save Name to ECX** 00402420 . 69FF FB7C0100 imul edi,edi,0x17CFB ; **EDI *= 0x17CFB** 00402426 . 51 push ecx 00402427 . 0F80 91020000 jo Afkayas_.004026BE 判断是否溢出的，溢出就直接ERROR 0040242D . FF15 F8404000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;] **get the 1&apos;st char of Name** 00402433 . 0FBFD0 movsx edx,ax ; edx=a[0] 00402436 . 03FA add edi,edx ** EDI += Name[0] remember as _res** 00402438 . 0F80 80020000 jo Afkayas_.004026BE 0040243E . 57 push edi 0040243F . FF15 E0404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;; _str = itos(_res) 00402445 . 8BD0 mov edx,eax 00402447 . 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20] 0040244A . FF15 70414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrMo&gt;; msvbvm50.__vbaStrMove 00402450 . 8BBD 50FFFFFF mov edi,dword ptr ss:[ebp-0xB0] 00402456 . 50 push eax 00402457 . 57 push edi 00402458 . FF93 A4000000 call dword ptr ds:[ebx+0xA4] 0040245E . 85C0 test eax,eax 00402460 . 7D 12 jge short Afkayas_.00402474 00402462 . 68 A4000000 push 0xA4 00402467 . 68 5C1B4000 push Afkayas_.00401B5C 0040246C . 57 push edi 0040246D . 50 push eax 0040246E . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj 00402474 &gt; 8D45 E0 lea eax,dword ptr ss:[ebp-0x20] 00402477 . 8D4D E4 lea ecx,dword ptr ss:[ebp-0x1C] 0040247A . 50 push eax 0040247B . 8D55 E8 lea edx,dword ptr ss:[ebp-0x18] 0040247E . 51 push ecx 0040247F . 52 push edx ; ntdll.KiFastSystemCallRet 00402480 . 6A 03 push 0x3 00402482 . FF15 5C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;; msvbvm50.__vbaFreeStrList 00402488 . 83C4 10 add esp,0x10 0040248B . 8D45 D4 lea eax,dword ptr ss:[ebp-0x2C] 0040248E . 8D4D D8 lea ecx,dword ptr ss:[ebp-0x28] 00402491 . 8D55 DC lea edx,dword ptr ss:[ebp-0x24] 00402494 . 50 push eax 00402495 . 51 push ecx 00402496 . 52 push edx ; ntdll.KiFastSystemCallRet 00402497 . 6A 03 push 0x3 00402499 . FF15 F4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeO&gt;; msvbvm50.__vbaFreeObjList 0040249F . 8B06 mov eax,dword ptr ds:[esi] 004024A1 . 83C4 10 add esp,0x10 004024A4 . 56 push esi 004024A5 . FF90 04030000 call dword ptr ds:[eax+0x304] 004024AB . 8B1D 0C414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaOb&gt;; msvbvm50.__vbaObjSet 004024B1 . 50 push eax 004024B2 . 8D45 DC lea eax,dword ptr ss:[ebp-0x24] 004024B5 . 50 push eax 004024B6 . FFD3 call ebx ; &lt;&amp;MSVBVM50.__vbaObjSet&gt; 004024B8 . 8BF8 mov edi,eax 004024BA . 8D55 E8 lea edx,dword ptr ss:[ebp-0x18] 004024BD . 52 push edx ; ntdll.KiFastSystemCallRet 004024BE . 57 push edi 004024BF . 8B0F mov ecx,dword ptr ds:[edi] 004024C1 . FF91 A0000000 call dword ptr ds:[ecx+0xA0] 004024C7 . 85C0 test eax,eax 004024C9 . 7D 12 jge short Afkayas_.004024DD 004024CB . 68 A0000000 push 0xA0 004024D0 . 68 5C1B4000 push Afkayas_.00401B5C 004024D5 . 57 push edi 004024D6 . 50 push eax 004024D7 . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj 004024DD &gt; 56 push esi 004024DE . FF95 40FFFFFF call dword ptr ss:[ebp-0xC0] 004024E4 . 50 push eax 004024E5 . 8D45 D8 lea eax,dword ptr ss:[ebp-0x28] 004024E8 . 50 push eax 004024E9 . FFD3 call ebx 004024EB . 8BF0 mov esi,eax 004024ED . 8D55 E4 lea edx,dword ptr ss:[ebp-0x1C] 004024F0 . 52 push edx ; ntdll.KiFastSystemCallRet 004024F1 . 56 push esi 004024F2 . 8B0E mov ecx,dword ptr ds:[esi] 004024F4 . FF91 A0000000 call dword ptr ds:[ecx+0xA0] 004024FA . 85C0 test eax,eax 004024FC . 7D 12 jge short Afkayas_.00402510 004024FE . 68 A0000000 push 0xA0 00402503 . 68 5C1B4000 push Afkayas_.00401B5C 00402508 . 56 push esi 00402509 . 50 push eax 0040250A . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj 00402510 &gt; 8B45 E8 mov eax,dword ptr ss:[ebp-0x18] ** eax=input serial** 00402513 . 8B4D E4 mov ecx,dword ptr ss:[ebp-0x1C] 00402516 . 8B3D 00414000 mov edi,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaSt&gt;; msvbvm50.__vbaStrCat 0040251C . 50 push eax ; push the serial we input 0040251D . 68 701B4000 push Afkayas_.00401B70 ; **AKA-** 00402522 . 51 push ecx ; **_str** 00402523 . FFD7 call edi ; **get the correct serial &quot;AKA-&quot;+_str** 00402525 . 8B1D 70414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaSt&gt;; msvbvm50.__vbaStrMove 0040252B . 8BD0 mov edx,eax 0040252D . 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20] 00402530 . FFD3 call ebx ; &lt;&amp;MSVBVM50.__vbaStrMove&gt; 00402532 . 50 push eax ; push the correct serial 00402533 . FF15 28414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCm&gt;; **compare** 00402539 . 8BF0 mov esi,eax ; ESI = 0 if equal，1 if not 0040253B . 8D55 E0 lea edx,dword ptr ss:[ebp-0x20] 0040253E . F7DE neg esi ; ESI = -ESI 00402540 . 8D45 E8 lea eax,dword ptr ss:[ebp-0x18] 00402543 . 52 push edx ; ntdll.KiFastSystemCallRet 00402544 . 1BF6 sbb esi,esi ; ESI = ESI-ESI-CF 00402546 . 8D4D E4 lea ecx,dword ptr ss:[ebp-0x1C] 00402549 . 50 push eax 0040254A . 46 inc esi ; ESI++ 0040254B . 51 push ecx 0040254C . 6A 03 push 0x3 0040254E . F7DE neg esi ; ESI = -ESI =&gt; -1 if equal，0 if not 00402550 . FF15 5C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;; msvbvm50.__vbaFreeStrList 00402556 . 83C4 10 add esp,0x10 00402559 . 8D55 D8 lea edx,dword ptr ss:[ebp-0x28] 0040255C . 8D45 DC lea eax,dword ptr ss:[ebp-0x24] 0040255F . 52 push edx ; ntdll.KiFastSystemCallRet 00402560 . 50 push eax 00402561 . 6A 02 push 0x2 00402563 . FF15 F4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeO&gt;; msvbvm50.__vbaFreeObjList 00402569 . 83C4 0C add esp,0xC 0040256C . B9 04000280 mov ecx,0x80020004 00402571 . B8 0A000000 mov eax,0xA 00402576 . 894D 9C mov dword ptr ss:[ebp-0x64],ecx 00402579 . 66:85F6 test si,si 0040257C . 8945 94 mov dword ptr ss:[ebp-0x6C],eax 0040257F . 894D AC mov dword ptr ss:[ebp-0x54],ecx 00402582 . 8945 A4 mov dword ptr ss:[ebp-0x5C],eax 00402585 . 894D BC mov dword ptr ss:[ebp-0x44],ecx 00402588 . 8945 B4 mov dword ptr ss:[ebp-0x4C],eax 0040258B . 74 58 je short Afkayas_.004025E5 分析可得： Name/Serial关系为： _res = strlen(Name)* 0x17CFB +Name[0] Serial = “AKA-_res” python脚本如下： name = raw_input(&apos;please input name:&apos;) serial = len(name)*int(&apos;17cfb&apos;,16) + ord(name[0]) print &apos;AKA-%d&apos;%serial 测试几组数据，正确.","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"点滴算法","slug":"点滴算法","date":"2017-08-18T08:03:20.000Z","updated":"2017-10-05T10:58:12.341Z","comments":true,"path":"2017/08/18/点滴算法/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/18/点滴算法/","excerpt":"我是有一点算法情节的。而我也一直认为学好算法是从事计算机相关行业人员所必备的。里面是我收集的对学习算法有帮助的一些知识。","text":"我是有一点算法情节的。而我也一直认为学好算法是从事计算机相关行业人员所必备的。里面是我收集的对学习算法有帮助的一些知识。 字符转数字、数字转字符: http://blog.sina.com.cn/s/blog_4c8a2a870100qgq7.html 计算任意一天是星期几的一种常用方法 W = ([Y-1] + [(Y-1)/4] - [(Y-1)/100] + [(Y-1)/400] + D) mod 7 Y是年份数，D是这一天在这一年中的累积天数，也就是这一天在这一年中是第几天。 为了求出Y年M月D日是星期几,只需求从公元1年1月1日至公元Y年M月D日包含的总天数除以7的余数,自然关键是求这个总天数如下分析:(1)假设只有在平年的情况下,Y年之前Y-1中包含的天数为365（Y-1）(2)考虑闰年的情况,每4年一闰,但逢100年除外,然而每400年又要加一个闰日.于是Y-1年共有闰日[(Y-1)/4] - [(Y-1)/100] + [(Y-1)/400] ,再加上M月D日包含的天数,即可得总天数(3)因为365≡1（mod 7）,所以365（Y-1）≡（Y-1)（mod 7）,这样,在求总天数除以7的余数时,可把365*（Y-1）简化为（Y-1）即W =( [Y-1] + [(Y-1)/4] - [(Y-1)/100] + [(Y-1)/400] + D ) mod 7","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://leo.dropsec.xyz/tags/ACM/"}]},{"title":"CrackMe 001","slug":"CrackMe-001","date":"2017-08-17T14:02:50.000Z","updated":"2017-08-18T02:05:08.806Z","comments":true,"path":"2017/08/17/CrackMe-001/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/17/CrackMe-001/","excerpt":"适合新手破解的160个crackme练手…好难呀，理解不了我能有什么办法~~ 我也是很无奈哦… 想了想还是需要硬着头皮做下去，谁让我是学计算机的呢？立个flag，之后每天攻克一道crackme…","text":"适合新手破解的160个crackme练手…好难呀，理解不了我能有什么办法~~ 我也是很无奈哦… 想了想还是需要硬着头皮做下去，谁让我是学计算机的呢？立个flag，之后每天攻克一道crackme… 先来观察一下程序点击主界面Serial/Name按钮，进入Name Serial子界面：点击主界面Serial按钮，进入Serial子界面： 明确目标：1.破解Serial子界面的序列号2.破解Name Serial子界面的用户名/序列号 查壳：用PEiD查壳结果为Borland Delphi 3.0，无壳。 破解使用OllyDbg工具打开Acid burn.exe，先破解破解SerialSerial子界面的错误提示框为：智能查找字符串Failed,找到对应汇编代码往上寻找判断代码，很容易发现关键跳所以jnz上面那个Call是比较输入Serial与正确Serial的，下个断点，重载程序，运行，选择Serial模块，输入test程序断在call处，观察此时eax edx的值，结合汇编代码可以得出正确的Serial为:”Hello Dude!” 然后破解Name Serial子界面的用户名/序列号Name Serial子界面的错误提示框为：查找字符串Sorry,找到对应汇编代码 0042FA57 |. 83F8 04 cmp eax,0x4 //长度 &gt;=4 0042FA5A |. 7D 1D jge short 01.0042FA79 0042FA5C |. 6A 00 push 0x0 0042FA5E |. B9 74FB4200 mov ecx,01.0042FB74 ; Try Again! 0042FA63 |. BA 80FB4200 mov edx,01.0042FB80 ; Sorry , The serial is incorect ! 0042FA68 |. A1 480A4300 mov eax,dword ptr ds:[0x430A48] 0042FA6D |. 8B00 mov eax,dword ptr ds:[eax] 0042FA6F |. E8 FCA6FFFF call 01.0042A170 0042FA74 |. E9 BE000000 jmp 01.0042FB37 0042FA79 |&gt; 8D55 F0 lea edx,[local.4] 0042FA7C |. 8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC] 0042FA82 |. E8 D1AFFEFF call 01.0041AA58 0042FA87 |. 8B45 F0 mov eax,[local.4] ; kernel32.763D8744 0042FA8A |. 0FB600 movzx eax,byte ptr ds:[eax] 0042FA8D |. F72D 50174300 imul dword ptr ds:[0x431750] 0042FA93 |. A3 50174300 mov dword ptr ds:[0x431750],eax 0042FA98 |. A1 50174300 mov eax,dword ptr ds:[0x431750] 0042FA9D |. 0105 50174300 add dword ptr ds:[0x431750],eax 0042FAA3 |. 8D45 FC lea eax,[local.1] 0042FAA6 |. BA ACFB4200 mov edx,01.0042FBAC ; CW 0042FAAB |. E8 583CFDFF call 01.00403708 0042FAB0 |. 8D45 F8 lea eax,[local.2] 0042FAB3 |. BA B8FB4200 mov edx,01.0042FBB8 ; CRACKED 0042FAB8 |. E8 4B3CFDFF call 01.00403708 0042FABD |. FF75 FC push [local.1] 0042FAC0 |. 68 C8FB4200 push 01.0042FBC8 ; - 0042FAC5 |. 8D55 E8 lea edx,[local.6] 0042FAC8 |. A1 50174300 mov eax,dword ptr ds:[0x431750] 0042FACD |. E8 466CFDFF call 01.00406718 0042FAD2 |. FF75 E8 push [local.6] 0042FAD5 |. 68 C8FB4200 push 01.0042FBC8 ; - 0042FADA |. FF75 F8 push [local.2] ; kernel32.BaseThreadInitThunk 0042FADD |. 8D45 F4 lea eax,[local.3] 0042FAE0 |. BA 05000000 mov edx,0x5 0042FAE5 |. E8 C23EFDFF call 01.004039AC 0042FAEA |. 8D55 F0 lea edx,[local.4] 0042FAED |. 8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0] 0042FAF3 |. E8 60AFFEFF call 01.0041AA58 0042FAF8 |. 8B55 F0 mov edx,[local.4] ; kernel32.763D8744 0042FAFB |. 8B45 F4 mov eax,[local.3] 0042FAFE |. E8 F93EFDFF call 01.004039FC 0042FB03 |. 75 1A jnz short 01.0042FB1F 0042FB05 |. 6A 00 push 0x0 0042FB07 |. B9 CCFB4200 mov ecx,01.0042FBCC ; Congratz !! 0042FB0C |. BA D8FB4200 mov edx,01.0042FBD8 ; Good job dude =) 0042FB11 |. A1 480A4300 mov eax,dword ptr ds:[0x430A48] 0042FB16 |. 8B00 mov eax,dword ptr ds:[eax] 0042FB18 |. E8 53A6FFFF call 01.0042A170 0042FB1D |. EB 18 jmp short 01.0042FB37 0042FB1F |&gt; 6A 00 push 0x0 0042FB21 |. B9 74FB4200 mov ecx,01.0042FB74 ; Try Again! 0042FB26 |. BA 80FB4200 mov edx,01.0042FB80 ; Sorry , The serial is incorect ! 0042FB2B |. A1 480A4300 mov eax,dword ptr ds:[0x430A48] 0042FB30 |. 8B00 mov eax,dword ptr ds:[eax] 0042FB32 |. E8 39A6FFFF call 01.0042A170 0042FB37 |&gt; 33C0 xor eax,eax 分析可得0x0042FA57处的指令”CMP EAX,4”限制了输入的Name的长度必须大于等于40x0042FA79 - 0x0042FAFE的代码验证了输入的Name/Serial是否正确，根据验证结果进行跳转将0x0042FA87 - 0x0042FAFE的代码单独拎出来，分析如下： 0042FA87 |. 8B45 F0 mov eax,[local.4] ; save name sddress 0042FA8A |. 0FB600 movzx eax,byte ptr ds:[eax] ; save first char of name to eax 0042FA8D |. F72D 50174300 imul dword ptr ds:[0x431750] ; eax *= 41 0042FA93 |. A3 50174300 mov dword ptr ds:[0x431750],eax ; [0x431750] = EAX 0042FA98 |. A1 50174300 mov eax,dword ptr ds:[0x431750] ; EAX = [0x431750] 0042FA9D |. 0105 50174300 add dword ptr ds:[0x431750],eax ; eax*=2 标记为 _res 0042FAA3 |. 8D45 FC lea eax,[local.1] 0042FAA6 |. BA ACFB4200 mov edx,01.0042FBAC ; CW 0042FAAB |. E8 583CFDFF call 01.00403708 0042FAB0 |. 8D45 F8 lea eax,[local.2] 0042FAB3 |. BA B8FB4200 mov edx,01.0042FBB8 ; CRACKED 0042FAB8 |. E8 4B3CFDFF call 01.00403708 0042FABD |. FF75 FC push [local.1] ; push CW 0042FAC0 |. 68 C8FB4200 push 01.0042FBC8 ; - 0042FAC5 |. 8D55 E8 lea edx,[local.6] 0042FAC8 |. A1 50174300 mov eax,dword ptr ds:[0x431750] ; eax= _res 0042FACD |. E8 466CFDFF call 01.00406718 ; itos(), remember the result as _str 0042FAD2 FF75 E8 push dword ptr ss:[ebp-0x18] ; push _str 0042FAD5 68 C8FB4200 push 01.0042FBC8 ; - 0042FADA |. FF75 F8 push [local.2] ; push &quot;CRACKED&quot; 0042FADD |. 8D45 F4 lea eax,[local.3] 0042FAE0 |. BA 05000000 mov edx,0x5 0042FAE5 |. E8 C23EFDFF call 01.004039AC ; get the correct serial &quot;CW-&quot;+_str+&quot;-CRACKED&quot; 0042FAEA |. 8D55 F0 lea edx,[local.4] 0042FAED |. 8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0] 0042FAF3 |. E8 60AFFEFF call 01.0041AA58 0042FAF8 |. 8B55 F0 mov edx,[local.4] ; get the real serial we input 0042FAFB |. 8B45 F4 mov eax,[local.3] ; the real serial 0042FAFE |. E8 F93EFDFF call 01.004039FC ; compare 可知正确的Name/Serial关系为 _res = Name[0] 0x29 2，Serial = “CW-_res-CRACKED”能够写注册机了： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #define N 10000 using namespace std; int main() { char buffer[N]; short int c; cout&lt;&lt;&quot;please input name:\\n&quot;; gets(buffer); if(strlen(buffer)&lt;4) //判断序列号长度 { cout&lt;&lt;&quot;Error!&quot;&lt;&lt;endl; } else { c=buffer[0]; c=c*0x29; c=c*2; cout&lt;&lt;&quot;serial:&quot;&lt;&lt;endl; printf(&quot;Serial: CW-%4d-CRACKED\\r\\n&quot;,c); } return 0; } PS:分析算法真是让人头疼…","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"在线小工具推介","slug":"在线小工具推介","date":"2017-08-16T07:24:58.000Z","updated":"2017-08-16T07:37:33.708Z","comments":true,"path":"2017/08/16/在线小工具推介/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/16/在线小工具推介/","excerpt":"这里对你而言可能会有一些比较好用的在线小工具哦。 更新ing…","text":"这里对你而言可能会有一些比较好用的在线小工具哦。 更新ing… 草料二维码生成器 http://cli.im电脑二维码扫描器 https://cli.im/deqrMD5加密 https://md5jiami.51240.com各种查询工具 https://www.51240.com有道翻译 http://fanyi.youdao.com进制转换 http://tool.oschina.net/hexconvert二级域名查询 http://i.links.cn/subdomain","categories":[],"tags":[{"name":"工具or软件","slug":"工具or软件","permalink":"http://leo.dropsec.xyz/tags/工具or软件/"}]},{"title":"合天 CTF-REVERSE练习之.NET WP","slug":"合天-CTF-REVERSE练习之-NET-WP","date":"2017-08-13T11:37:47.000Z","updated":"2017-08-13T11:55:50.495Z","comments":true,"path":"2017/08/13/合天-CTF-REVERSE练习之-NET-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/13/合天-CTF-REVERSE练习之-NET-WP/","excerpt":"想学好逆向、想打好CTF，想学好网安，需要掌握的知识很多吖，就一个简单的逆向想做好就关系到.NET、C#，还要熟悉其语法写出脚本，而我现在什么都还不会…唉，骚年，在最平静的大学生活中努力吧。","text":"想学好逆向、想打好CTF，想学好网安，需要掌握的知识很多吖，就一个简单的逆向想做好就关系到.NET、C#，还要熟悉其语法写出脚本，而我现在什么都还不会…唉，骚年，在最平静的大学生活中努力吧。REVERSE是CTF竞赛中的一种常见题型，除了对常见的二进制程序进行逆向分析之外，对.NET程序的分析也是一个考查点。本实验通过实例讲解如何对简单的.NET程序进行逆向分析，并介绍.NET逆向分析工具ILSpy的使用。 这个实验的核心在于熟练.NET及其反编译软件，也涉及到加密与解密的算法，而我还很菜很菜，目前这个水平还不能完全驾驭它，故请大家来看标准的实验指导书","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"合天 CTF-REVERSE练习之病毒分析 WP","slug":"合天-CTF-REVERSE练习之病毒分析-WP","date":"2017-08-13T10:28:17.000Z","updated":"2017-08-13T10:51:52.899Z","comments":true,"path":"2017/08/13/合天-CTF-REVERSE练习之病毒分析-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/13/合天-CTF-REVERSE练习之病毒分析-WP/","excerpt":"病毒分析，停起来很厉害的一个名字，首次接触，在做完这个实验之后，感觉也没什么好写的，可能是自己水平还是太低，没能体会到其精髓吧…故暂且将实验指导书拿来。","text":"病毒分析，停起来很厉害的一个名字，首次接触，在做完这个实验之后，感觉也没什么好写的，可能是自己水平还是太低，没能体会到其精髓吧…故暂且将实验指导书拿来。其中推荐的三个沙箱都用不了哦。………………………………………..在查询“后门文件”是什么的时候，偶然发现这个:https://zhidao.baidu.com/question/1669211327117057667.html可以尝试一下哦… 小小分享：MD5在线加密 https://md5jiami.51240.com/有道在线翻译 http://fanyi.youdao.com/各种查询工具 https://www.51240.com/ （ ￣︶￣ ）↗","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"合天 CTF-REVERSE练习之信息提取 WP","slug":"合天-CTF-REVERSE练习之信息提取-WP","date":"2017-08-13T08:02:40.000Z","updated":"2017-08-13T09:05:56.591Z","comments":true,"path":"2017/08/13/合天-CTF-REVERSE练习之信息提取-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/13/合天-CTF-REVERSE练习之信息提取-WP/","excerpt":"有两个比较喜欢的女歌手我一直搞混，曲婉婷、范玮琪。总是想起来这个而记不起那个，记得之前高三的时候跟二百说这个，他说这两个人风格完全不一样，怎么会混淆…( ╯□╰ )OK,开始切入正题…","text":"有两个比较喜欢的女歌手我一直搞混，曲婉婷、范玮琪。总是想起来这个而记不起那个，记得之前高三的时候跟二百说这个，他说这两个人风格完全不一样，怎么会混淆…( ╯□╰ )OK,开始切入正题…本实验主要介绍了CTF-REVERSE信息提取，通过本实验的学习，你能够掌握十六进制编辑器C32Asm的基本用法，了解图片Exif信息，以及快速提取二维码中信息的方法，了解PNG图片格式的基本特征。我也是首次接触这个吖 预备知识一：C32Asm一款非常不错的国产静态反编译工具，C32Asm现具有如下功能：快速静态反编译PE格式文件(Exe、Dll等)，提供Hex文件编辑功能，功能强大，提供内存Dump、内存编辑、PE文件Dump、PE内存ImageSize修正等多种实用功能。通常主要讲C32Asm当做16进制编辑器来使用，因为成熟的静态反编译工具如IDA等已经非常强大了，本实验中也只使用C32Asm的十六进制编辑器功能。C32Asm可以十分方便的进行十六进制编辑操作，同时支持对指定的数据块进行各种运算操作，包括异或运算等。 二：二维码二维码（Quick Response Code），又称二维条码。它是用特定的几何图形按一定规律在平面（二维方向）上分布的黑白相间的图形，是所有信息数据的一把钥匙。在现代商业活动中，二维码的应用十分广泛，如：产品防伪/溯源、广告推送、网站链接、数据下载、商品交易、定位/导航、电子商务应用、车辆管理、信息传递等。如今的二维码应用十分的广泛，许多手机APP都可以进行二维码信息的识别以及二维码图片生成等，互联网上也有许多支持二维码生成以及二维码信息提取的网站，如http://cli.im 等。 三：Exif信息Exif是一种图象文件格式，它的数据存储与JPEG格式是完全相同的。实际上Exif格式就是在JPEG格式头部插入了数码照片的信息，包括拍摄时的光圈、快门、白平衡、ISO、焦距、日期时间等各种和拍摄条件以及相机品牌、型号、色彩编码、拍摄时录制的声音以及全球定位系统（GPS）、缩略图等。简单地说，Exif=JPEG+拍摄参数。因此，你可以利用任何可以查看JPEG文件的看图软件浏览Exif格式的照片，但并不是所有的图形程序都能处理Exif信息。 操作打开给的文件，发现是一张图片,提示语：奇怪的狗尾巴！汪汪汪通常拿到图片之后，首先查看图片的属性信息中是否存在Exif提示信息，我们通过查看文件属性，发现程序没有Exif信息，如图所示：然后用C32Asm打开文件，发现文件开头字节是BM说明它确实是BMP位图。根据“奇怪的狗尾巴！汪汪汪”给我们的提示，可能是在文件末尾有信息。拉到最下面，在C32Asm中拖动到文件末尾，发现了一个IEND字符串，如图所示注意在PNG图片格式中，PNG数据由一个一个数据块（Data Chunk）组成。每个数据块都有一个4字节长度的标识，典型的有IHDR、IDAT、IEND等。完整的PNG数据总是以一个IHDR块开头，最终以一 个IEND块结束的，而真正表示图像数据的IDAT块则嵌在IHDR块和IEND块之间。这里可以猜测在BMP图片的末尾附加了一个PNG图片，那么继续往上查找，我们看到了IHDR标志，找到IHDR前面的PNG标志，复制出PNG数据。详细步骤如下1）在C32Asm中使用鼠标选择从0xB6C16开始的数据，直到文件末尾2）右键，拷贝-&gt;拷贝3）在文件中新建十六进制文件，在新键文件中选中自带的00右键粘贴4）文件中保存文件为test.png图片打开这张图片发现是一张二维码，保存，打开http://cli.im/deqr ，选择“上传二维码图片”，将刚刚保存的二维码图片进行上传识别，得到一个URLhttp://blog.sina.com.cn/s/blog_703d65470102v6tf.html 访问这个URL，看到一篇文章“一张美美的图片”，提示信息为“二维码图片末尾还有数据哦，尝试进行异或运算，key为0x88”。再次使用C32Asm打开test.png二维码图片，按下Ctrl+A选择所有数据，单击鼠标右键，在弹出的菜单中选择“修改数据”， 在弹出的“修改数据”对话框中，选择“异或”运算，后边填入88，单击确定按钮，就可以看到flag信息了，如图所示：我们看到图片的末尾为“flag{CtF_Re_iS_FuN}”，这就是我们要找的flag了。 小小提示：电脑扫二维码网址：http://cli.im/deqr二维码制作网址：http://cli.im","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"合天 CTF-REVERSE练习之脱壳分析 WP","slug":"合天-CTF-REVERSE练习之脱壳分析-WP","date":"2017-08-13T03:28:40.000Z","updated":"2017-08-15T04:26:37.565Z","comments":true,"path":"2017/08/13/合天-CTF-REVERSE练习之脱壳分析-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/13/合天-CTF-REVERSE练习之脱壳分析-WP/","excerpt":"这个脱壳分析实验和之前写的“壳与ESP定律“内容有些是重复的，因为这个实验就使用了ESP定律来脱壳的，但是这个实验在某些方面比较详细，是一个不错的补充，特别是脱壳后对软件的修复…","text":"这个脱壳分析实验和之前写的“壳与ESP定律“内容有些是重复的，因为这个实验就使用了ESP定律来脱壳的，但是这个实验在某些方面比较详细，是一个不错的补充，特别是脱壳后对软件的修复… 运行这个软件是这样的用PEID查壳，发现是UPX壳这个时候如果拖进IDA去分析的话会弹出一些提示意味着程序经过加壳处理，最好不要用IDA去进行分析，因为加壳后的程序很难通过IDA的静态分析来理解程序的内部执行逻辑。所以我们用OD打开，接下来就是运用ESP定律来脱壳了F8单步，发现只有ESP、EIP寄存器变红的时候就可以用ESP了然后选择ESP的内容，右键-&gt;数据窗口中跟随，然后在数据窗口中选中对应数据 ，右键，断点-&gt;硬件访问-&gt;对应字节。然后就设置好硬件断点了。F9运行到断点然后就可以删除断点了 ，调试-&gt;硬件断点-&gt;删除。F7单步，会有一个循环很烦人，所以选中循环下的语句，F4直接运行到这里F8单步到004094F8，这就是OEP，右键选择用OD脱壳注意94F8才是程序入口。然后脱壳输入文件名保存。现在请不要关闭OD，后面还需要进行修复操作。对UPX脱壳而言，进行到这一步就可以了，但是如果是另外一些壳，可能还需要对程序的输入表进行修复操作。 修复脱壳后的程序注意在继续进行实验之前，请确保你停留在实验步骤二中最后的一步。现在打开桌面上的ImportREC程序，首先在进程列表中选择C:\\Reverse\\6\\crackme6.exe，然后在OEP中填入94F8（也就是在OD中找到的一个信息），然后点击“IAT AutoSearch”按钮，接着点击“GetImports”按钮，就可以看到程序的输入表信息了。点击右侧的“Show Invalid”按钮，看看是否存在无效的输入表项目。无效的输入表项目前面带有问号（？），如果有可以使用右键菜单删除。这里没有无效的输入表项目，所以选择“Fix Dump”按钮，对我们的dumped.exe进行修复，得到dumped.exe程序。现在对程序的脱壳以及修复操作已经全部完成，使用PEiD对dumped.exe程序查壳，可以看到提示“Microsoft Visual C++ 6.0”信息，dumped_.exe程序也可以正常运行，至此脱壳完成。…………………………………………………………………………………………………………………………..以上是合天的一个实验指导，当我在实验吧看到一个类似的实验时，发现实验吧对这个类似题目处理的步骤增多了，下面简单补充： 在用OD的脱壳工具查看OEP之后，发送到LordPE软件，选择带脱壳的软件，右键选择“修正镜像大小”，单机确定按钮；然后再次选择带脱壳软件，右键选择“完整保存”，保存即可。 然后将它发送到ImportREC软件，下拉对话框中选择程序，输入OEP，单击IAT自动查找，然后单击获取导入表，然后单击显示无效函数，有的话右键删除，没有就单击修正转存，保存即可。（完成脱壳）…………………………………………………………………………………………………………………………..以上两步应该算是软件的修复吧，有些软件还需要去除软件大小自校验将脱壳后的软件发送到OD，菜单栏选择插件-&gt;APId断点设置工具-&gt;常用断点设置，弹出窗口选择文件处理-&gt;GetFileSize,F9运行，断点处暂停单击堆栈窗口，右键选择在反汇编窗口中跟随单击反汇编窗口调用函数的代码行，F2，然后切换到断点窗口（B），删除GetFileSize断点 ，程序中的GetFileSize函数获取了脱壳后程序的大小，然后利用命令cmp eax,0xc6c8命令比较，不相等则跳转 ，脱壳后程序要比源程序大，所以跳转退出程序。。把两个Ja的命令NOP掉，去除软件大小限制，然后选择所以修改保存即可。然后运行程序发现可以正常运行了…(有些软件以上三步缺一步就不可以正常 运行…)","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"合天 CTF-REVERSE练习之算法分析2 WP","slug":"合天-CTF-REVERSE练习之算法分析2-WP","date":"2017-08-12T13:27:21.000Z","updated":"2017-08-13T10:55:35.460Z","comments":true,"path":"2017/08/12/合天-CTF-REVERSE练习之算法分析2-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/12/合天-CTF-REVERSE练习之算法分析2-WP/","excerpt":"本实验以自定义算法为例，讲解如何编写一个注册机。 积累经验喽…","text":"本实验以自定义算法为例，讲解如何编写一个注册机。 积累经验喽…本题的核心在于分析自定义算法，进而写出注册机，所以这里直接看关键代码。长方形括住的的是核心代码，简化为 szUsername[v1] ^ byte_423678[v1] == szPassword[v1]根据异或运算的性质，上述条件可以转换为 szPassword [v1] ^ byte_423678[v1] == szUsername [v1]我们需要把byte_423678的内容提取出来，为： 1, 2, 3, 4, 1, 5, 1, 5, 1, 3, 6, 5, 4, 8, 5, 3, 1, 2, 3, 4, 5, 3, 5, 7, 2, 3, 2, 4, 8, 2, 5, 6, 4 这就是我们找到的XOR密钥数组。程序的注册算法为：将用户名的每一个字符与XOR密钥数组中的对应下标的字符进行异或运算，产生注册码字符串对应的字符。 我们编写这样一段Python脚本即可： def crack(username): key = [1, 2, 3, 4, 1, 5, 1, 5, 1, 3, 6, 5, 4, 8, 5, 3, 1, 2, 3, 4, 5, 3, 5, 7, 2, 3, 2, 4, 8, 2, 5, 6, 4] pwd = [] for i in xrange(0, len(username)): pwd.append(chr(ord(username[i]) ^ key[i])) return &quot;&quot;.join(pwd) if __name__ == &quot;__main__&quot;: while True: username = raw_input(&quot;input username:&quot;) serial = crack(username) print &quot;serial: %s&quot; % serial 我们输入用户名Wins0n，就可以得到注册码为Vkmw1k，输入程序可以成功注册","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"合天 CTF-REVERSE练习之算法分析1 WP","slug":"合天-CTF-REVERSE练习之算法分析1-WP","date":"2017-08-12T09:48:25.000Z","updated":"2017-08-13T10:55:22.615Z","comments":true,"path":"2017/08/12/合天-CTF-REVERSE练习之算法分析1-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/12/合天-CTF-REVERSE练习之算法分析1-WP/","excerpt":"有点伤心、有的无奈，实验指导书中并不是全部步骤都十分理解，但是我还是需要尝试着写一下，万一再琢磨一下就懂了呢？","text":"有点伤心、有的无奈，实验指导书中并不是全部步骤都十分理解，但是我还是需要尝试着写一下，万一再琢磨一下就懂了呢？算法分析是CTF REVERSE题型中的一个常见考察点，相对于字符串明文跟踪而言，算法分析具有更大的挑战性，参赛选手需要仔细理解程序内部关键算法的过程，才能编写出注册机（Keygen）。本实验以MD5算法为例，讲解如何识别程序内部使用的算法类型，并讲解IDA的一些基本功能来加速我们的理解过程。 实验准备一、PEiD密码算法分析插件PEiD有一个叫做Krypto ANALyzer的插件，使用这个插件可以对程序进行扫描，通过特征匹配来识别程序内部可能用到的一些标准算法。Krypto ANALyzer的使用方法为：点击PEiD主界面右下角的“=&gt;”按钮，选择“插件”菜单项，然后选择“Krypto ANALyzer”，就可以弹出Krypto ANALyzer插件了。Krypto ANALyzer插件会自动分析程序内部可能用到的标准算法下图中显示了程序中在地址00401E5C处存在MD5算法的特征： 二、IDA重命名等功能在IDA中，我们可以通过按下N键来对一个变量/函数/标记等进行重命名操作，函数和变量命名对于帮主我们理解程序的内部逻辑非常重要，就好比我们在编程的时候，培养良好的编程风格非常重要一样。比如如果函数sub_4012E0经过我们分析之后，确定其功能为将传入的字符串转为大写形式，那么我们可以选中sub_4012E0后按下N键对其进行重命名（将函数名命名为fnStringToUpper）：IDA通过还可以给汇编指令或者伪代码来添加注释。如果要对某一条汇编指令添加注释，只需要在汇编指令所在行按下封号（即;）即可弹出对话框来接收注释；如果要给伪代码添加注释，则只需在伪代码所在行按下斜杠（即/）即可弹出对话框来接收注释。OD也可以给汇编指令添加注释，只需要在汇编指令所在行后一列的空白处双击鼠标左键即可，如图所示： 实际操作通过API交叉引用快速定位关键代码观察程序，运行这个程序后要求输入一个用户名和密码进行注册，当注册失败的时候，程序将弹出一个消息框提示不正确，如图所示：那么我们可以通过IDA的交叉引用功能来定位这一块的代码。使用IDA载入CrackMe4.exe程序，待分析结束后，通过Imports TAB页面找到MessageBoxA，双击来到反汇编视图，在MessageBoxA按下X按键对其进行交叉引用查找，经过一个一个进行分析，我们发现sub_4016B0就是我们所要找的关键函数，我们通过F5得到这个函数的伪代码。通过对伪代码添加注释，以及对变量进行重命名操作，我们得到如下的代码片段：上面的伪代码有两个错误，就是在第一个if语句中会判断密码的长度是否为33，如果不是33就弹出错误提示。其实这里是32（而用户名的长度则不能大于10）只是Hex-Rays Decompiler这个插件生成伪代码时出错了，所以需要记住，F5生成的伪代码并不保证完全正确。32这个长度对应汇编指令中的代码片段如下：通过上面的伪代码的分析，我们发现只有sub_401510这个函数的功能并不清楚，通过双击sub_401510查看对应的伪代码，发现有点复杂，暂时无法理解，不过这并不要紧。 使用PEiD的Krypto ANALyzer识别算法如果程序使用了标准算法进行处理，那么可以使用PEiD的Krypto ANALyzer进行快速识别，将CrackMe4.exe载入PEiD，点击PEiD主界面右下角的“=&gt;”按钮，选择“插件”菜单项，然后选择“Krypto ANALyzer”，就可以弹出Krypto ANALyzer插件了，Krypto ANALyzer提示程序使用了MD5算法，如下图所示：我们记住00401E5C这个地址，在IDA的反汇编指令视图（IDA View）中按下G键，输入00401E5C，就会自动跳转到计算MD5的函数代码中，如图所示：从这里并不能得到什么有用的信息，我们需要通过不断的回溯来理解程序的代码逻辑。通过往上查阅代码，我们知道00401E5C 位于函数sub_401D10之中，我们对sub_401D10进行交叉引用查找，如图所示：可以从sub_401D10回溯到sub_4026F0，继续通过交叉引用往上回溯，依次为sub_4027B0、sub_401C00、sub_401BB0、sub_401510，而sub_401510就是我们在实验步骤一种为一个暂时不理解的函数。那么我们可以猜测sub_401510这个函数就是用来计算用户名的MD5值的，我们可以通过OD动态调试来验证我们的想法。通过阅读IDA中的反汇编代码，我们知道在00401752处调用了sub_401510这个函数现在OD载入CrackMe4.exe程序，在00401752处设置一个断点，然后按F9运行程序，用户名输入test，密码输入一个32个字符的任意字符串，单击“注册”按钮，程序便会自动断下，断下后按F8进行单步跟踪，执行sub_401510这个函数后，我们看到eax寄存器的值为098F6BCD4621D373CADE4E832627B4F6，这个恰好就是test的MD5值。 编写注册机现在我们已经将程序的注册算法分析清楚了，下面就可以编写一个注册机了。程序的注册算法为：将用户名进行MD5计算得到一个哈希值，将哈希值转换为大写字符串即可，其中用户名的长度在1~10之间，不能超过10.Python内置了MD5算法，可以非常方便的计算MD5值，我们编写这样一段脚本即可： import hashlib while True: username = raw_input(&quot;input username:&quot;) md5 = hashlib.md5(username).hexdigest().upper() serial = md5[::-1] # 翻转字符串 print &quot;serial: %s&quot; % serial 我们输入用户名Wins0n，就可以得到注册码为51F561458ADAEEBA43A57CF7E59F6CC4，输入程序可以成功注册，如图所示： “抄”完的我快难受死了….","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"合天 CTF-REVERSE练习之API断点 WP","slug":"合天-CTF-REVERSE练习之API断点-WP","date":"2017-08-12T06:28:27.000Z","updated":"2017-08-13T10:55:05.511Z","comments":true,"path":"2017/08/12/合天-CTF-REVERSE练习之API断点-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/12/合天-CTF-REVERSE练习之API断点-WP/","excerpt":"通过OD的API参考断点以及IDA中针对API的交叉引用查找功能，可以快速定位到调用特定API的位置。但通过API动态调用技术，可以有效对抗这种逆向分析方法。本实验通过对API直接设置断点以及利用MessageBox的阻塞特性，介绍了针对API动态调用的逆向分析方法。","text":"通过OD的API参考断点以及IDA中针对API的交叉引用查找功能，可以快速定位到调用特定API的位置。但通过API动态调用技术，可以有效对抗这种逆向分析方法。本实验通过对API直接设置断点以及利用MessageBox的阻塞特性，介绍了针对API动态调用的逆向分析方法。这个程序基本上和前两个是一样的马甲，但是如果你尝试用之前的方法来找到密码，是很难行的通的。so,我们来学习新东西… 一：利用API断点跟踪关键函数代码该程序外形和之前的一样，再次不在赘述，直接OD载入，Ctrl+G,在窗口中输入MessageBoxA,确定,来到MessageBoxA的调用点，F2下断点F9运行，在弹出窗口输入test，确定。程序在MessageBoxA的第一条指令断下，点击菜单栏调试-&gt;执行到用户代码，这时候CrackMe的错误提示消息框将会弹出来，我们点击消息框的“确定”按钮，程序在OD中会再次断下。这次是因为点击了“执行到用户代码”的原因，OD会在调用了MessageBoxA的下一条指令自动断下，如图所示：可以知道004015F6处的call就是调用了MessageBoxA函数F8单步跟踪，消息框中出现字符串，它就是我们想要的密码…………………………………………………… 在上面步骤中，我们在MessageBoxA断下后，通过“执行到用户代码”回到CrackMe空间的代码，通过简单的F8单步跟踪，就很幸运的看到了过关密码。然而在实际调试过程中，可能需要跟踪很久才能发现一点蛛丝马迹，那么我们可以结合IDA的静态分析功能来加速我们的逆向过程。在前面的分析中，我们知道在004015F6这个地址调用了MessageBoxA函数，现在使用IDA载入CrackMe3.exe，待分析结束后按下G，然后输入“004015F6”后点击OK按钮，就会自动跳转到004015F6这个地方了，如图所示：F5查看伪代码，很容易发现密码 实际逆向过程中，要学会OD与IDA熟练结合使用。扬长避短。 …………………………………………………… 二：利用MessageBox的阻塞特性定位关键代码我们知道MessageBox是一个阻塞的API，就是当调用这个API的时候，会弹出一个消息框，此时程序的代码执行流就会自动阻塞在调用MessageBox的地方，直到点击提示框上的按钮或者关闭提示框时，程序才会继续往下执行。那么在程序弹出MessageBox的时候，我们可以在OD中让程序断下来，然后通过“执行到用户代码”来回到调用MessageBox的地方，这就是说MessageBox本身就类似于“断点”。使用OD载入CrackMe3.exe，如果之前设置了断点，为了防止干扰，我们需要先清除掉之前设置的断点。F9运行程序，在窗口输入test，点击确定，出现错误提示窗口，不要点击确定。F12暂停程序。选择菜单调试-&gt;执行到用户代码。错误提示窗口点击确定，程序在OD中会再次断下。这次是因为点击了“执行到用户代码”的原因，OD会在调用了MessageBoxA的下一条指令自动断下，如图所示然后你突然就懂了…(F8。。。)","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"合天 CTF REVERSE练习之API定位 WP","slug":"合天-CTF-REVERSE练习之API定位-WP","date":"2017-08-11T08:56:14.000Z","updated":"2017-08-13T10:54:02.869Z","comments":true,"path":"2017/08/11/合天-CTF-REVERSE练习之API定位-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/11/合天-CTF-REVERSE练习之API定位-WP/","excerpt":"通过字符串引用查找来定位关键函数代码是一种常用的简单有效的分析方法，而在字符串经过处理时，这种方法就失效了，本实验将介绍一种新的分析方法：通过关键API交叉引用查找以及通过对关键API下断点来定位关键函数的代码。","text":"通过字符串引用查找来定位关键函数代码是一种常用的简单有效的分析方法，而在字符串经过处理时，这种方法就失效了，本实验将介绍一种新的分析方法：通过关键API交叉引用查找以及通过对关键API下断点来定位关键函数的代码。一样，先用PEID查看程序是否加壳，发现没壳。然后观察程序，发现貌似和第一题一样加载进OD，不妨按照第一题的思路那样查找字符串，发现找不到这是因为字符串是通过LoadString加载的，OD无法通过字符串查找的方法来定位资源中定义的字符串条目。so，只能开辟新的途径喽…右键反汇编窗口选择查找-&gt;当前模块中的名称（标签），在跳出的窗口中直接输入messageboxa,右键这条语句，窗口中选择“在每个参考上设置断点”，在OD最下方的状态栏上会看到“已设置 2 个断点”的提示。F9运行，弹出窗口输入test，确定，暂停到对messageboxa调用的地方然后，查看其附近的代码，发现上方出现了密码。…………………………………………………………..接下来用IDA实现，载入程序，点击Imports TAB页面，直接输入messageboxa，双击这条语句，来到messageboxa定义的位置，选中messageboxa后按X键，弹出交叉引用列表窗口，共有四条我们并不能直接看出哪一个引用就是我们所要找的引用，所以需要一个一个进行查看（根据前面使用OD对程序的分析，我们知道在MessageBoxA之前有许多对LoadString的调用，因此通过对比几个交叉引用，可以断定sub_401450就是我们要找的函数）使用F5还原sub_401450函数的伪代码，伪代码如下：我们断定LoadString加载资源ID为0x6A的字符串就是我们要找的密码，现在使用Restorator打开CrackMe2.exe程序来查看字符串资源，如图所示，0x6A的十进制即106，因此可以知道密码就是HeeTianLab了。 额外补充： IDA的交叉引用功能能针对系统API，也能对自定义函数发挥作用 即使对字符串做加密处理也不能阻止通过API来定位关键函数代码 IDA也无法通过Strings Window来查看资源中定义的字符串条目","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"合天 CTF-REVERSSE练习之逆向初探 WP","slug":"合天-CTF-REVERSSE练习之逆向初探-WP","date":"2017-08-11T06:31:26.000Z","updated":"2017-08-13T10:56:00.418Z","comments":true,"path":"2017/08/11/合天-CTF-REVERSSE练习之逆向初探-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/11/合天-CTF-REVERSSE练习之逆向初探-WP/","excerpt":"暑假任务书上让做实验吧上的实验，并且需要写下WP，那我就听话写一写呗…","text":"暑假任务书上让做实验吧上的实验，并且需要写下WP，那我就听话写一写呗…拿到题目先观察，是这个样子的：不输入密码点确定是这个样子的：随便输入一个密码(比如test)是这个样子的“然后开始逆向，先用PEID查看 是否带壳：发现没有带壳，然后选择OD或IDA进行逆向分析，这里先用OD查看，载入程序，右键选择智能查找字符串-&gt;ASCII,出现字符串窗口Ctrl+f查找关键字，如密码错误找到关键字符双击进入对应反汇编窗口发现关键字上边有一个明显的jnz向错误提示跳转，它就是关键跳转，NOP掉就可以实现爆破了。这里我们来寻找注册码。从jnz往上看代码，会发现有部分风格完全变的不一样，就在这里下个断点重新载入程序，F9，在弹出的窗口中输入test，F8单步运行，运行到00401490出时在信息窗口中出现输入的错误密码test，及HeeTianLab猜测HeeTianLab就是正确的密码，结合附近上下的代码分析，此处在拿输入的密码和正确的进行一一比较，不一样则跳转到错误语句。把HeeTianLab输入到另外一个新程序中,密码正确。………………………………………………….也可以用IDA进行分析，载入程序，shift+F12，查找关键字符串，双击进入，选中对应字符串，按X进行交叉引用查找，来到引用字符串的地方F5查看伪代码，发现就是那输入字符串与HeeTianLab进行比较。故得到正确密码。 注意：按F5查看伪代码，有时候会发现界面没反应，原因有可能是没有选对正确位数的IDA。","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"壳与ESP定律","slug":"壳与ESP定律","date":"2017-08-10T12:58:45.000Z","updated":"2017-08-16T06:09:38.809Z","comments":true,"path":"2017/08/10/壳与ESP定律/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/10/壳与ESP定律/","excerpt":"好不容易略懂了一点ESP…","text":"好不容易略懂了一点ESP… 一：知识准备 通过前面的学习，学会了利用暴力破解达到绕过注册机制和追踪注册码来达到“合法”用软件的方法，但是我们往往会遇到代码经过混淆器混淆的程序，此类混淆器可以称之为壳，壳又可分为压缩壳（常见的有UPX、北斗、ASDPack、Npack、PECompact等）和保护壳（如强壳Safengine、VMprotect、winlicense、Themida等），压缩壳作用是把程序进行体积缩小化处理，保护壳主要作用是混淆或加密代码防止他人进行逆向程序、破解程序。我们可以通过一些侦壳程序进行识别，但有些壳会采用伪装技术来混淆侦壳程序。 ESP定律的原理：堆栈平衡原理。ESP定律是堆栈平衡原理在实践中的一个应用。所谓堆栈平衡原理，即加壳程序运行时，需要先保存原程序的初始现场，将现场状态压入堆栈，待壳运行完毕后，将原程序的现场状态出栈，此时开始运行原程序。在具体应用时，通过记录堆栈寄存器存储原程序初始现场状态的地址，并使程序在为将初始状态出栈而访问以记录的地址时中断，程序中断处便在OEP附近。 ESP定律的适用范围是什么？几乎全部的压缩壳，部分加密壳。只要是在JMP到OEP后，ESP=0012FFC4的壳，理论上我们都可以使用。但是在何时下断点避开校验，何时下断OD才能断下来，这还需要多多总结和多多积累。ESP定律法的步骤ESP定理脱壳（ESP在OD的寄存器中，我们只要在命令行下ESP的硬件访问断点，就会一下来到程序的OEP了！）（1）开始就点F8，注意观察OD右上角的寄存器中ESP有没突现（变成红色）（这只是一般情况下，更确切的说我们选择的ESP值是关键句之后的第一个ESP值）当有且只有ESP和EIP为红色时，我们可以用ESP定律了（2）在命令行下：dd XXXXXXXX(指在当前代码中的ESP地址，或者是hr XXXXXXXX)，按回车（3）选中下断的地址，断点—&gt;硬件访问—&gt;WORD断点（4）按一下F9运行程序，直接来到了跳转处，按下F8，到达程序OEP二：实战操作1.查壳用PEID查壳结果如下：2.寻找OEP(1)OD载入程序(2).按F8，发现只有ESP、EIP是红色。记下此时ESP的值0019FF64（每个人机器上运行这个值有可能不同）(3).在Command命令行中输入dd 0019FF64,回车(4).选中要下断点的0019FF64那一行，右键，依次选择断点 -&gt; 硬件访问 -&gt; Word(5).在菜单栏调试（D）下的硬件断点（H）下选项下可以看到我们设置的硬件断点,确定。(6).然后按一下F9运行程序，如下：(7).运用F8很快会到达程序的OEP(8).然后我们就可以脱壳了，脱壳前我们先把断点清理掉，以免出错【调试→硬件断点→删除】3.脱壳（使用OD自带插件）右击程序当前位置第一行代码，选择OllyDump脱壳调试进程,然后我们在弹出的窗口中选择脱壳，然后输入要另存为的文件名此时，我们已经脱壳结束，检查下程序能否正常运行,再看下PEID对比脱壳前和脱壳后的不同.到此，脱壳就完成了。 小小总结文中用到的加壳程序下载地址：http://download.csdn.net/detail/qiurisuixiang/4363770 参考链接1：http://blog.csdn.net/qiurisuixiang/article/details/7649799参考链接2：http://www.cnblogs.com/ichunqiu/p/6213852.html参考链接3：http://www.52pojie.cn/thread-236872-1-1.html","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"十天的放逐","slug":"十天的放逐","date":"2017-08-08T02:59:26.000Z","updated":"2017-08-13T10:56:54.601Z","comments":true,"path":"2017/08/08/十天的放逐/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/08/十天的放逐/","excerpt":"就是这样如此巧合 2017.8.7 返校 立秋我已经进入了秋天","text":"就是这样如此巧合 2017.8.7 返校 立秋我已经进入了秋天7.27–8.7 整整在家呆了十天上大学以来 这是第三次回家自小到大 跟大部分同龄人相比回家好像对于我来说好像没有特别大的诱惑力 小学一个月回一次家高中几个星期回一次家到现在可能一年回几次家都是如此我不会像其他人那样焦急地去等待 该回家的时候拎起书包回家不该回家回家的时候不去过多的想念这好像就是我回家的一贯原则因此 不止一个人曾称呼我为野孩子哈哈哈。。。 十天的前几天回老家看望爷爷其他时间都在县城里和一部分好友聚了聚骑车在熟悉的县城里逛了逛其他时间也就那样什么也没干 让我感到惭愧的是我没能正真的、深层次的去理解自己的父母与家庭几天之中还是把自己最坏的脾气展示给了最亲的人 对于我来说每回一次家都是对自己精神的一次洗礼让我重新认识自己其中，我的亲人是主要的讲师 ………………………………….暑假还剩不到一个月其中大约有五天计划和朋友去趟天津剩下大约二十天对我来说是一个黄金时间也应该是我暑假浓墨重彩的一笔简单立个Flag: 每天至少上传一个自己感觉有价值的逆向题目WP。最后至少需要有二十个题解。 抽时间学习一下Py,能写出简单的脚本。 多看别人的博客，学习新东西。 追随逐梦者的脚步","categories":[],"tags":[{"name":"杂儿","slug":"杂儿","permalink":"http://leo.dropsec.xyz/tags/杂儿/"}]},{"title":"暑假一练 WriteUp","slug":"暑假一练-WriteUp","date":"2017-07-20T07:36:24.000Z","updated":"2017-08-11T10:25:53.549Z","comments":true,"path":"2017/07/20/暑假一练-WriteUp/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/20/暑假一练-WriteUp/","excerpt":"也算是第一次正式的接触这种题目吧，在聪大佬的指引下大概领悟了点，咱也写一些WriteUp…","text":"也算是第一次正式的接触这种题目吧，在聪大佬的指引下大概领悟了点，咱也写一些WriteUp… 第一题 Hellow 分值:50首先运行一下程序，看看是什么样子： 可知本题应该是输入用户名、注册码之类。然后将程序加载进IDA，shift+F12查询程序中的关键字符串 在前几行会看到有我们需要找到字符串，选择程序开始的提示“Please input your name”双击进入。 这个界面是数据段，选中对应语句，按ctrl+x出现一个弹框，选择对应语句并OK 按F5尝试得到伪代码发现不行 按空格键结合流程图大致看看程序的思路，再回到主界面根据白色提示信息，往下浏览代码，发现在输入name之后有聚集的cmp比较语句，在输入password后也有聚集的cmp比较语句 再结合验证机制，可以确定这部分语句就是核心所在。然后依次把比较语句中的十六进制数字选中按“R”键转换成对应字符。便可得到用户名与注册码 注意：1.不要漏字符 2.留意字符是否存在顺序 3.看清楚0和O和o最后用户名是：Syclover 注册码是：Hell0_W0rld 第二题 注册码 分值:100依然是先运行程序 可知此题与第一题有些相似，均为求注册码类型的题目。但是考察的内容可能略有不同，毕竟分值大了，也就是说难了，或者说需要略有思考或者计算才能解决。不管那么多，先拖进IDA再说。按照第一题的步骤一步步来，当按下shift+F12后感觉目的字符串不好找的话可以按ctrl+f查找关键字符串。比如此题可以用“name”作为关键字来查找。 找到之后双击进入，选中，ctrl+x进入调用段，F5查看伪代码 仔细分析算法，依次算出V7便是答案。最后注册码为：Ygspiqcb (聪哥之前写的脚本…) 第三题 R_KEY 分值:200 &lt;敬请期待&gt;","categories":[],"tags":[{"name":"二进制逆向","slug":"二进制逆向","permalink":"http://leo.dropsec.xyz/tags/二进制逆向/"}]},{"title":"汇编语言 王爽 章节知识点总结","slug":"汇编语言 王爽 章节知识点总结","date":"2017-07-15T12:04:11.000Z","updated":"2017-08-13T10:56:22.866Z","comments":true,"path":"2017/07/15/汇编语言 王爽 章节知识点总结/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/15/汇编语言 王爽 章节知识点总结/","excerpt":"王爽老师的书差不多看了一半，听很多人说这位老师的书写的很不错，为了看完之后不至于很容易的忘记，故结合前人笔记草草回顾一遍…","text":"王爽老师的书差不多看了一半，听很多人说这位老师的书写的很不错，为了看完之后不至于很容易的忘记，故结合前人笔记草草回顾一遍… 第一章 基础知识1.存储单元为1Byte，即字节。微小信息单位为1bit，其中1Byte=8bit。（一个存储单元可以存储8个bit，即8位二进制数。） 1GB=1024MB 1MB=1024KB 1KB=1024B 1B=8bit2.存储单元从零开始顺序编号。 第二章 寄存器3.8086CPU有14个寄存器，AX(accumulate) BX(base) CX(count) DX(data) SI DI指针寄存器：SP BP IP段寄存器：CS SS DS ES标志寄存器：PSW4.AX可分为AH(高8位）和AL(低8位)，均可以当做独立寄存器使用，互不影响。5.对于实验中溢出的数据，由PSW寄存器保存溢出值。6.8086CPU采用段地址和偏移地址，通过地址加法器来合成物理地址物理地址=段地址x 16 + 偏移地址（段的大小=偏移地址的长度）7.偏移地址16位，其变化范围为0—FFFFH；仅用偏移地址来寻址最多可寻64KB个内存单元。 第三章 寄存器（内存访问）8.字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元，将起始地址为N的字单元简称为N地址字单元。9.8086CPU不支持数据直接入段寄存器10.栈：LIFO（后进先出） 8086CPU入栈（PUSH）和出栈（POP）以字为单位；11.SS：SP 任意时刻始终指向栈顶元素，PUSH AX由下面两步构成：（1）SP=SP-2，SS：SP指向当前栈顶前面的单元，以当前栈顶前面的单元作为新的栈顶；（2）将AX中的内容送入SS：SP指向的内存单元处，SS：SP此时指向新栈顶. （栈顶指针指向的元素最终都是有效的）12.8086CPU入栈时，栈顶从高地址向低地址方向移动，栈为空的时候，SS：SP指向最底部的字单元的偏移地址+2。13.出栈后，SS：SP指向新的栈顶，但之间栈顶的元素还在，只是不在栈中，在之后PUSH移动至此后，此数据将会被覆盖。 第4章 第一个程序14.一个汇编程序由多个段组成，这些段分别用来存放代码，数据，后者当做栈空间，一个有意义的汇编程序中至少有一个段，这个段用来存放代码。 第5章 【bx】和loop指令15.① 【 】表示偏移地址，也表示一个内存单元 ②（ ）表示“一个寄存器或一个内存单元中的内容” ③ Idata表示常量16.Loop指令的格式：loop 标号①（CX）＝（CX）- 1；②（CX）≠0，则转至标号处循环执行（CX）＝0，则继续向下执行 第7章 更灵活的定位内存地址的方法17.在汇编程序中，数据不能以字母开头(+0)18.伪指令：dw 定义字型数据；db 定义字节型数据；dd 定义双字型数据19.Si和Di不能够分成两个8位寄存器，功能和BX相近。20.大小写的转化方法：and al，11011111 b（大写）or al，00100000 b (小写) 第8章 数据处理的两个基本问题21.Reg（寄存器）：AX，BX，CX，DX（及其8位高低寄存器），SP，BP，Si, DiSreg（段寄存器）：DS，SS，CS，ES8086CPU只有BX，Si，Di, BP可以用【】来进行内存单元寻址，可以单独出现，或BXBX BPBP SiDi SiDi 组合出现22.在【】中使用BP，如果指令没有显性给出段地址，默认在SS中23.指令在执行前，所要处理的数据可以在3个地方：CPU内部，内存，端口24.div指令（除法指令）8位除数 16位除数16位被除数 32位被除数{ AX （低16位）DX（高16位）}AL（商）AH（余数） AX（商）DX（余数）25.伪指令dupdb/dw/dd 重复次数 dup（重复的字节/字型/双字型）dw 0, 0, 0, 0, 0, 0 ,0, 0 = dw 8 dup（0） 第9章 转移指令的原理26.转移指令：可以修改IP，或同时修改CS和IP的指令。8086CPU的转移行为：段间转移（修改CS：IP）段内转移（只修改IP）短转移：IP修改范围-128—127 近转移：IP修改范围 -32768—3276727.offset 取得标号处的偏移地址nop 空指令（占位置/用于程序对齐/设标号/延时）28.jmp指令 依据位移转移的jmp指令（CPU在执行jmp指令的时候不要需要转移的目的地址）jmp short 标号 段内短转移 功能：IP=IP+8位位移（标号处地址-jmp指令后第一个字节地址）jmp near ptr 标号 段内近转移 功能：IP=IP+16位位移 转移的目的地址在指令中的jmp指令jmp far ptr 标号 段间转移 功能：CS=标号所在段的段地址，IP=标号在段中的偏移地址 转移地址在寄存器中的jmp指令jmp 16位reg 功能：IP=（16位reg） 转移地址在内存中的jmp指令Jmp word ptr 内存单元地址（段内转移）功能：转移的偏移地址是内存单元中的内容Jmp dword ptr 内存单元地址（段间转移）功能：内存单元中的高地址处为转移的段 地址，低地址处是转移的目的偏移地址29.jcxz指令jcxz 标号 功能：相当于if(（cx）==0）jmp short 标号30.loop指令loop 标号 功能：相当于（cx）– ； if（（cx）!=0）jmp short 标号 第10章 CAll和RET指令31.call指令（和jmp指令进行比较） 依据位移转移的call指令（CPU在执行call指令的时候不要需要转移的目的地址）call 标号 相当于push IP /jmp near ptr 标号； 转移的目的地址在指令中的call指令call far ptr 标号 相当于push CS / push IP / jmp far ptr 标号 转移目的地址在寄存器中的call指令call 16位reg 相当于push IP / jmp 16位reg； 转移地址在内存中的call指令call word ptr 内存单元地址 相当于push IP / jmp word ptr 内存单元地址；call dword ptr 内存单元地址 相当于push CS / push IP /jmp dword ptr 标号32.ret和retf指令ret指令用栈中的数据，修改IP的内容，从而实现近转移，相当于pop IP；retf指令用栈中的数据，修改CS和IP中的内容，从而实现远转移；相当于pop IP/pop CS33.mul指令格式：mul reg 或者mul 内存单元；结果：8位乘法，结果放在AX中，16位乘法，则高位放在DX中，低位放在AX中 第11章 标志寄存器34.8086CPU的flag寄存器的结构35.adc指令（带进位的加法指令）格式：adc 操作对象1 操作对象2功能：操作对象1=操作对象1 + 操作对象2 + CF36.sbb指令（带借位的减法指令）格式：sbb 操作对象1 操作对象2功能：操作对象1=操作对象1 - 操作对象2 - CF37.cmp指令 （比较指令，不保存结果，影响相关标志位的值）格式：cmp 操作对象1 操作对象2功能： 操作对象1 - 操作对象238.检验比较结果的条件转移指令 （e:equal ；a:above ；b:below；）39.rep movsb相当于： s:movsb loop s rep的作用是根据CX的值，重复执行后面的穿传送指令。由于每执行一次movsb指令si和di都会递增或递减指向后一个单元或前一个单元，则rep movsb就可以循环实现(CX)个字符的传送。执行movsb相当于进行以下几步操作： ((es)16+(di))=((ds)16+(si)) 如果df=0 则si=si+1 di=di+1如果df=1 则si=si-1 di=di-1 40.cld 将标志寄存器的DF置0，正向std 将标志寄存器的DF置1，逆向pushf 将标志寄存器入栈popf 将标志寄存器出栈 第12章 内中断41.内中断就是CPU不再处理执行中的指令，而是转去处理这个特殊的信息 内中断的产生包括以下几个：除法错误（div指令产生的除法溢出） 中断类型码：0单步执行 中断类型码：1执行into指令 中断类型码：4执行int指令 中断类型码：n （int n） 42.关于中断过程CPU收到中断信息—生成中断类型码—查找中断向量表—找到中断处理程序入口（设置段地址和偏移地址）对于8086CPU，中断向量表存在于内存0000:0000—0000:03FF的1024个单元中，由于其中有一些空白的地方，所以我们一般将自己编写的中断程序放在0000:0020—0000:02FF的256个字节空间里。PC机的中断例程是由CPU硬件完成，在接受到中断信息后，会执行一下操作：① 产生中断类型码② 标志寄存器的值入栈（pushf）③ 设置标志寄存器中的IF和TF的值为0（原因在书P250和P273）④ CS内容入栈 （push CS）⑤ IP内容入栈 （push IP）⑥ IP=中断类型码4 （N4）⑦ CS=中断类型码4+2 （N4+2）43.编写中断处理程序的步骤① 保存用到的寄存器② 处理中断③ 恢复用到的寄存器④ 用iret指令返回44.Iret指令的功能用汇编语言描述为： POP IPPOP CSpopf 第13章 int指令45.int指令引发的中断（int n）过程：1.取得中断类型码n2.标志寄存器入栈，IF，TF设置为03.CS，IP入栈4.（IP）=（n 4），（CS）=（n 4 + 2） 46.BIOS中主要包含的内容 硬件系统的检测和初始化程序外部中断和内部中断的中断例程用于对硬件设备进行的I/O操作的中断例程其他和硬件系统相关的中断例程 第14章 端口47.shl（左移）和shr（右移）指令将一个寄存器或内存单元中的数据向左（向右）移位将最后移出的一位写入CF中最低位（最高位）用0补充 第15章 外中断48.外中断：对外部设备进行控制外放的输入—相关接口芯片的端口—CPU内存…………………………………………………….. 指令系统总结 8086CPU 提供以下几大类指令：1、数据传送指令比如：mov、push、pop、pushf、popf、xchg等都是数据传送指令，这些指令实现寄存器和内存、寄存器和寄存器之间的单个数据传送。2、算术运算指令比如：add、sub、adc、sbb、inc、dec、cmp、imul、idiv、aaa等都是算术运算指令，这些指令实现寄存器和内存中的数据的算数运算。它们的执行结果影响标志寄存器的：sf、zf、of、cf、pf、af位。3、逻辑指令比如：and、or、not、xor、test、shl、shr、sal、sar、rol、ror、rcl、rcr 等都是逻辑指令。除了not指令外，它们的执行结果都影响标志寄存器的相关标志位。4、转移指令可以修改IP ，或同时修改CS 和IP 的指令统称为转移指令。转移指令分为以下几类：（1）无条件转移指令，比如：jmp；（2）条件转移指令，比如：jcxz、je、jb、ja、jnb、jna等；（3）循环指令，比如：loop；（4）过程，比如：call、ret、retf；（5）中断，比如int、iret。5、处理机控制指令这些指令对标志寄存器或其他处理机状态进行设置，比如：cld、std、cli、sti、nop、clc、cmc、stc、hlt、wait、esc、lock等都是处理机控制指令。6、串处理指令这些指令对内存中的批量数据进行处理比如：movsb、movsw、cmps、scas、lods、stos等。若要使用这些指令方便地进行批量数据的处理，则需要和rep、repe、repne等前缀指令配合使用。 end","categories":[],"tags":[{"name":"Assembly","slug":"Assembly","permalink":"http://leo.dropsec.xyz/tags/Assembly/"}]},{"title":"所谓的废纸篓","slug":"所谓的废纸篓","date":"2017-07-14T02:11:36.000Z","updated":"2017-09-25T12:39:45.119Z","comments":true,"path":"2017/07/14/所谓的废纸篓/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/14/所谓的废纸篓/","excerpt":"我喜欢随手记录一些杂而不乱的东西…","text":"我喜欢随手记录一些杂而不乱的东西…MarkDown使用小技巧[http://www.jianshu.com/p/9d94660a96f1]MarkDown使用小技巧[http://www.cnblogs.com/rossoneri/p/4446440.html]看一看ta博客[http://www.cnseay.com/]","categories":[],"tags":[{"name":"废纸篓","slug":"废纸篓","permalink":"http://leo.dropsec.xyz/tags/废纸篓/"}]},{"title":"Summer  第一周","slug":"Summer-第一周","date":"2017-07-11T09:07:40.000Z","updated":"2017-07-11T13:37:23.955Z","comments":true,"path":"2017/07/11/Summer-第一周/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/11/Summer-第一周/","excerpt":"留校第一周的学习周报","text":"留校第一周的学习周报 本周做了哪些学习记录？请分享你做的笔记、博客7.1–7.71.刘爽老师的《汇编语言》看到了第五章。了解了汇编语言的一些基础知识，比如汇编语言的产生、存储器、总线、主板等基本概念。以及寄存器是什么，有哪几种寄存器，不同寄存器的特定作用，怎么读写寄存器，和一些修改寄存器的指令，包括：mov、add、sub、jmp以及栈操作的指令push、pop。还有就是“段”在内存中的概念。 2.搭建了一个自己的博客。用了大约2天的时间，终于搭建好了自己的博客空间，以后自己学到的感觉有趣的知识以及自己的心得感悟都会实时更新到上面，一来是记录，二来是分享。附博客链接[http://leo.dropsec.xyz/] 3.这几天还做了一个事情就是帮助了一位小学妹报志愿。又经历了一次报志愿，其中选择学校时的犹豫、面对高录取分的无奈、未来握在自己手中时的不安。。。有一次经历、又一次感悟。骚年，努力学习吧。 下周的学习目标是什么？1.感觉自己现在还没有真正走进汇编，接下来的几天主要任务就是继续研读汇编，同时多熟悉OD、IDA等相关软件的使用，能读懂汇编语言写的程序。 2.接下来的学习肯定少不了学姐学长在方向上的引领和问题方面的解答，感谢学长学姐。最后一起努力。","categories":[],"tags":[{"name":"杂儿","slug":"杂儿","permalink":"http://leo.dropsec.xyz/tags/杂儿/"}]},{"title":"年少无为，卖马为生","slug":"年少无为，卖马为生","date":"2017-07-08T12:48:06.000Z","updated":"2017-08-13T10:56:44.908Z","comments":true,"path":"2017/07/08/年少无为，卖马为生/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/08/年少无为，卖马为生/","excerpt":"前几天在浏览博客的时候无意间看到有人用“年少无为，卖马为生”来介绍自己，顿时心里五味陈杂…","text":"前几天在浏览博客的时候无意间看到有人用“年少无为，卖马为生”来介绍自己，顿时心里五味陈杂…我自认为我也算是一个有故事的人经历的缘故，在别人眼中我是一个沉稳、严肃、不怎么爱说话的大男孩大一这一年，对我来说无疑是一个有纪念意义的一年 那天刚好是我的生日，独自一人踏上了外地求学的旅程，临走之前我这样都自己说： 新的开始总要拿些新的东西去面对，“勇敢做自己，开拓XX滩。”是我送给每位即将远行好友的一句话，现在亦讲给自己。高考前100天曾这样写过：只知道彼时的我不会大喜也不会大悲，只是怀一颗平静、明朗的心接受自己努力学习的结果，继而换上行装、双手插兜、面带笑容走向远方…… 2016.9.7 踏进北门的那一刻，四年的大学生活就这样拉开了帷幕紧接着竞选了军训负责人并顺利的当选班长我的记忆只存在几秒如果说大一有记忆的话那么班长工作基本就是全部 必须承认这一年在学习上我是没怎么用心的没有长时间投入的做一件事情因此，有些时候会有一种滑稽可笑的想法感觉大一一年什么也没学到哈哈，这不是真的（严肃脸）‘非时’说：你至少学会怎么跟陌生人相处虽然她是一个“奇怪”的人 寒假是我大一生活中浓墨重彩的一笔和几个可以说是陌生人的陌生人去广州打工美资企业 Jabil十个白天九个黑夜自我感觉也没真正的吃到苦除夕前一天晚上游荡在广州塔下其间去了一趟深圳在大梅沙触摸到了沙滩和大海然后穿过亚热带到达了温带重新回到了我喜欢的冬天记忆特别清晰下火车后我内心一阵窃喜同时身体也在发抖…总之第一次远程，整体感觉不错喜欢上了那里一景一物给我带来的特有感觉聆听了我娜姐的故事 娜姐，今晚你给我讲你的故事，几年后，我会找到你给你讲我的故事，到时候请认真听。娜姐，勇敢追寻你的幸福吧，你幸福我便会幸福。2017.2.14 现在我的记忆还停留在寒假结束拉着行李箱走进学校谁会料到转眼之间暑假已经来到 这便是我的大一记忆不多却愈发珍贵 大一的暑假我选择了留校跟着实验室的学长学姐学点东西希望接下来的一年里自己可以静下心、低下头掌握一些真本领做一个技术控、IT男 最后简单整理一下这一年来零碎写下的便签 20160907-20161016，四十天。结束了很多，开始的也很多。遗憾的是其间诸多瞬间感受没有来得及记录下来。发现无论走到哪里，新结识的人很多都可以在某方面与之前的身边的人产生一一对应的关系，比如杰含、东浩、科鹏、雯静、娴梦……除此之外，还有便是以往的瞬间场景经常会与现在的瞬间场景出现惊人的一致性，而每到这个时候，总会不自主的颤抖几下。我想说的，还有，明天的我，明天的我们将会变成什么模样。对了，明天星期一。 既然睡的比较晚，那就晚点睡吧。真的不知道自己一天都干了些什么。微笑不出来。加强时间分配利用能力。睡喽，明天继续微笑。 浮现。管家。佛性童心。纯粹。朴。羽烬。自我与本我。光影低雕灯。冷暖。life&amp;light。书独慰藉。果然(燃)美。缬美。目送。chris。红格调。 我知道每天早起后我会忘记从床上拿下来眼镜、我知道我的眼镜会坏的、我知道 《周鸿祎自述》他们选择和拒绝一款产品，往往来源于人性很小的点。 ——周鸿祎 渐发现，熬夜其实很困，只是心中一直有所期待，有所牵挂的东西，它迟迟让你感觉下一秒可能就会有所惊喜，也许是你孤独惯了，幸福的人是从来不晚睡的。——季箐 每个人年轻的时候，都想离开自己的父母，离的越远越好，不知不觉真就走出很远，与他们相隔千山万水，有一天猛一回头你会发现，无论走多远，总有一根线连着你和他们，那时候父母已经变老，腿脚不再利索，于是你又折回头重回他们身边，和以前不一样的是，你变成了大人，他们变成了孩子。 ​​​​ Notebook that makes your wish come true with fairy magic. 最容易实现的目标是最成功的目标。 想听音乐，闭上眼睛，轻轻地把音响放到左耳边，感觉音量小了点，于是我把音量增加了一点点。再次闭上眼睛，感觉音量又大了一点。我尝试把音量再减一点，结果是感觉音量又小了点。 有些时候，我会循环这样的无聊的动作，然而大部分的时候我是无奈的。 真的想把白天的时间利用起来，晚上该睡就睡。以后每天我要尽量不在宿舍待。除了晚上睡觉回宿舍，其他时间尽量去实验室学点技术。 走过小径，枝叶还能摇摆、；走过楼道，电灯还能变亮；走进窄门，管缝还能喷水；站在那里，影子还能出现。原来，你依然是你，再怎么堕落你依然是你。请善待自己。 现在你拥有的很多东西，甚至是你不想要的，正是其他人想尽各种办法想得到的。这些东西随时都可能丢失，你要学会珍惜你所拥有的。 这个世界上哪里有什么岁月静好，只不过有人替你负重前行。 四年很长，它可以像青春那样长；四年也很短，它也可以像南北苑的距离一样短。 很奇怪，听着一个陌生人的歌，一遍又一遍的循环。我不喜欢晚睡，但我总是不自觉的想晚睡。 大家晚安","categories":[],"tags":[{"name":"杂儿","slug":"杂儿","permalink":"http://leo.dropsec.xyz/tags/杂儿/"}]},{"title":"搭建博客后的资源整合","slug":"搭建博客后的资源整合","date":"2017-07-08T05:14:29.000Z","updated":"2017-08-16T07:46:27.694Z","comments":true,"path":"2017/07/08/搭建博客后的资源整合/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/08/搭建博客后的资源整合/","excerpt":"对于我这样的小白，从开始搭建博客到搭建好，到配置博客的小功能，，再到基本熟悉用Markdown语法写文章并熟悉上传文章的命令，差不多用了三四天的时间。下面就简单整合一下此过程中接触到的一些较为有用的资源。。。","text":"对于我这样的小白，从开始搭建博客到搭建好，到配置博客的小功能，，再到基本熟悉用Markdown语法写文章并熟悉上传文章的命令，差不多用了三四天的时间。下面就简单整合一下此过程中接触到的一些较为有用的资源。。。 如果你想自己动手用GitHub搭建一个属于自己的博客，不妨先去了解一下什么是GitHub,为什么不直接去其他博客平台上注册一个账号，多省事。等你了解完之后，再动手不迟。 首先推荐一个搭建教程[http://www.jianshu.com/p/863f3f2d1733]我就是按他这个教程一步步来的，讲的比较详细。 其中在输入第一条命令时，他讲的不算特别清楚，没有说明是在哪个命令框内输入 这个命令可以去运行命令框中执行。然后继续跟着他的步骤来，后面在设置SSH的时候，需要从Vim编辑器中提取一大串字符，这时候你如果还用Ctrl+C的话会发现复制不下来，这时候你需要使用Vim认可的复制快捷键，这时候你就可以去搜索一下了。其他的都会比较顺利，最后出现博客的基本模型。（其中你可能会遇到一个或两个404错误页面，第一个可能是你在设置GitHub用户名和域名不一样，第二个404需要去仓库中操作一下CNAME，具体怎么搞，这里不再详细解释，可以网上搜索一下，实在搞不清可以邮件联系我。基本模型搭建好以后就该设置它的小功能了。你可能会需要以下工具：功能强大的文本编辑器：Notepad++在线制作网址图标(ico):[http://www.bitbug.net/]小功能设置教程(注意主题的不同）：[http://moxfive.coding.me/yelee/]编辑.md文件的MarkDown下载，win10的下载好之后不能直接用，还需要下载一个软件：awesomium才能使用。同时可以搜一个在线MarkDown编辑器使用。 最后的最后附上主题设计者的博客[http://litten.me/]供大家参考学习。搭建好自己的博客之后，就需要我们坚持写博客喽。 ……………………………………………………………………………………………………………………………..在写博客的过程中，你可能会想怎么写出其他颜色的字体呢？别急，请看下面的链接…CSDN-markdown编辑器语法——字体、字号与颜色 http://blog.csdn.net/testcs_dn/article/details/45719357","categories":[],"tags":[{"name":"工具or软件","slug":"工具or软件","permalink":"http://leo.dropsec.xyz/tags/工具or软件/"}]},{"title":"Markdown 使用语法","slug":"Markdown 使用语法","date":"2017-07-06T12:32:32.000Z","updated":"2017-08-16T07:21:14.094Z","comments":true,"path":"2017/07/06/Markdown 使用语法/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/06/Markdown 使用语法/","excerpt":"Markdown是一个轻量、简单、通用的文档快速排版的标记语言 Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。","text":"Markdown是一个轻量、简单、通用的文档快速排版的标记语言 Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。 欢迎使用Markdown编辑器写博客本Markdown编辑器使用StackEdit修改而来，用它写博客，将会带来全新的体验哦： Markdown和扩展Markdown简洁的语法 代码块高亮 图片链接和图片上传 LaTex数学公式 UML序列图和流程图 离线写博客 导入导出Markdown文件 丰富的快捷键 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z 重做 Ctrl + Y Markdown及扩展 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— [ 维基百科 ] 使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接等，详细语法参考帮助？。 本编辑器支持 Markdown Extra , 扩展了很多好用的功能。具体请参考Github. 表格Markdown Extra 表格语法： 项目 价格 Computer $1600 Phone $12 Pipe $1 可以使用冒号来定义对齐方式： 项目 价格 数量 Computer 1600 元 5 Phone 12 元 12 Pipe 1 元 234 定义列表Markdown Extra 定义列表语法：项目１项目２: 定义 A: 定义 B 项目３: 定义 C : 定义 D &gt; 定义D内容 代码块代码块语法遵循标准markdown代码，例如：12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' 脚注生成一个脚注[^footnote]. [^footnote]: 这里是 脚注 的 内容. 目录用 [TOC]来生成目录： [TOC] 数学公式使用MathJax渲染LaTex 数学公式，详见math.stackexchange.com. 行内公式，数学公式为：$\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。 块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 更多LaTex语法请参考 这儿. UML 图:可以渲染序列图： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 或者流程图： 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 关于 序列图 语法，参考 这儿, 关于 流程图 语法，参考 这儿. 离线写博客即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入write.blog.csdn.net/mdeditor即可。Markdown编辑器使用浏览器离线存储将内容保存在本地。 用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。 博客发表后，本地缓存将被删除。 用户可以选择 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。 注意：虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，请务必及时发表或者保存到服务器草稿箱。 浏览器兼容 目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。 IE９以下不支持 IE９，１０，１１存在以下问题 不支持离线功能 IE9不支持文件导入导出 IE10不支持拖拽文件导入","categories":[],"tags":[{"name":"工具or软件","slug":"工具or软件","permalink":"http://leo.dropsec.xyz/tags/工具or软件/"}]},{"title":"Hello Word","slug":"Hello-Word","date":"2017-07-04T13:53:56.000Z","updated":"2017-07-12T05:34:00.537Z","comments":true,"path":"2017/07/04/Hello-Word/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/04/Hello-Word/","excerpt":"在实验室鹏哥和某些学长的推荐和帮助下，这个博客终于搭建起来了。","text":"在实验室鹏哥和某些学长的推荐和帮助下，这个博客终于搭建起来了。折腾了两天多，在github page上看到自己的博客加载下来时，突然有种错综复杂的恍惚感。是的，它不是qq空间，不是新浪博客，不是豆瓣小站，也不是贴吧。它更像是属于自己的一块小小的领地，因而我满足于这种归属感。我愿在上面安静劳作。 一个农民，通过自身努力终于分到了一块地，不再需要在地主的土地上创造流量价值时，于是翻身作主的他可以宣告说：Hello World。当然这个农民确切来说是个小小的码农。 感谢在搭建过程中给予我帮助的友人们。","categories":[],"tags":[{"name":"杂儿","slug":"杂儿","permalink":"http://leo.dropsec.xyz/tags/杂儿/"}]}]}